define("DS/ShaderBuilders/ShaderBuilder",["DS/Mesh/ThreeJS_Base"],function(n){"use strict";var e=new Set;return class{constructor(n,t=null){if(this.builder=n,this.uniqueID=t,t&&e.has(t))throw"Invalid Operation: "+t+" has already been declared";t&&e.add(t)}getUniqueID(){if(!this.uniqueID)throw"Not implemented exception";return this.uniqueID}buildLib(n,e){return this.builder(n,e)}}}),define("DS/ShaderBuilders/ShaderUtils/AttributeUtils",["DS/Mesh/ThreeJS_Base"],function(n){"use strict";return{_context:null,_addAttribute:function({attributeName:e,attributeType:t,size:r=0,attributeCategory:a,locationName:o=null,checkName:i=!0}){const s=n.ToGLSLTypes[t];if(i&&"a"!==e[0]&&console.warn('Bad Practice: start the name of your attributes with "a"'),!s)return console.warn(`Invalid Operation: ${t} for ${e} is not a proper type`),"";if(0===r&&s.isArray)return console.warn(`Invalid Operation: ${t} for ${e} is not a proper array`),"";if(r>0&&!s.isArray)return console.warn(`Invalid Operation: ${t} for ${e} is can not be an array`),"";let l={type:t,locationName:o||null,dynamic:!0};return l[a+"Attribute"]=!0,this._context.__attributes__[e]=l,r>0?`\n                        attribute ${s.t} ${e}[${r}];\n                    `:`\n                    attribute ${s.t} ${e};\n                `},addAttribute:function({attributeName:n,attributeType:e,size:t=0,locationName:r=null}){return this._addAttribute({attributeName:n,attributeType:e,locationName:r,size:t,attributeCategory:"core"})},addPDSFXAttribute:function({attributeName:n,attributeType:e,size:t=0}){return this._addAttribute({attributeName:"INTERNAL_PDSFX_CUSTOM_ATTRIBUTE"+n,attributeType:e,locationName:n,size:t,attributeCategory:"core",checkName:!1})},addInstancingAttribute:function({attributeName:n,attributeType:e,size:t=0,locationName:r=null}){return this._addAttribute({attributeName:n,attributeType:e,locationName:r,size:t,attributeCategory:"instancing"})},addPDSFXInstancingAttribute:function({attributeName:n,attributeType:e,size:t=0}){return this._addAttribute({attributeName:"INTERNAL_PDSFX_CUSTOM_ATTRIBUTE"+n,attributeType:e,locationName:n,size:t,attributeCategory:"instancing",checkName:!1})},getAttribute:function(n){return this._context.isWebGPU?"input."+n:n}}}),define("DS/ShaderBuilders/ShaderUtils/UniformUtils",["DS/Mesh/ThreeJS_Base"],function(n){"use strict";const e={GLOBAL:"global",LIGHT:"light",MATERIAL:"material",PDSFX:"pdsfx",OBJECT:"object"},t={material:e.MATERIAL,pdsfx:e.PDSFX,global:e.GLOBAL,postPro:e.GLOBAL,light:e.LIGHT,shadow:e.LIGHT,object:e.OBJECT,clipping:e.OBJECT};return{UBOs:e,_context:null,_addUniform:function({uniformName:e,uniformType:r,size:a=0,checkName:o=!1,uniformCategory:i=null,locationName:s=null,precision:l=null,defaultValue:u=null,materialName:m=null,materialType:$=null,functionLoad:c=null,functionContext:p=null}){const d=n.ToGLSLTypes[r];if(o&&"u"!==e[0]&&console.warn('Bad Practice: start the name of your uniforms with "u"'),!d)return console.error(`Invalid Operation: ${r} for ${e} is not a proper type`),"";if(0===a&&d.isArray)return console.error(`Invalid Operation: ${r} for ${e} is not a proper array`),"";a>0&&!d.isArray&&(a=0,console.warn(`Invalid Operation: ${r} for ${e} can not be an array, overriding to single`));var f=i||"material",h=t[f];if(void 0===h)throw"Missing ubo for category "+f;let g={name:e,type:r,value:null,size:a,locationName:s||null,dynamic:!0,ubo:h,defaultValue:u,materialName:m,materialType:$,functionLoad:c,functionContext:p};return g[f+"Uniform"]=!0,this._context.__uniforms__[e]=g,this._context.isWebGPU?"":a>0?`\n                        uniform ${l||""} ${d.t} ${e}[${a}];\n                    `:`\n                    uniform ${l||""} ${d.t} ${e};\n                `},addUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"material",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addGlobalUniform:function({uniformName:n,uniformType:e,shaderOptions:t,size:r=0,locationName:a=null,precision:o=null,defaultValue:i=null,materialName:s=null,materialType:l=null,functionLoad:u=null,functionContext:m=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:a,precision:o,size:r,uniformCategory:"global",defaultValue:i,materialName:s,materialType:l,functionLoad:u,functionContext:m})},addLightUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"light",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addShadowUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"shadow",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addObjectUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"object",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addPostProUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"postPro",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addClippingUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null,defaultValue:o=null,materialName:i=null,materialType:s=null,functionLoad:l=null,functionContext:u=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,size:t,uniformCategory:"clipping",defaultValue:o,materialName:i,materialType:s,functionLoad:l,functionContext:u})},addPDSXUniform:function({uniformName:n,uniformType:e,size:t=0,locationName:r=null,precision:a=null}){return this._addUniform({uniformName:n,uniformType:e,locationName:r,precision:a,checkName:!1,size:t,uniformCategory:"pdsfx"})},_getUniform({uniformName:n,uniformCategory:e}){return this._context||(this._context={}),this._context.__fetchedUniforms__||(this._context.__fetchedUniforms__={}),this._context.__fetchedUniforms__[e]||(this._context.__fetchedUniforms__[e]={}),this._context.__fetchedUniforms__[e][n]=!0,this._context.isWebGPU?`${t[e]}_uniforms.${n}`:n},getUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"material"})},getGlobalUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"global"})},getLightUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"light"})},getShadowUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"shadow"})},getObjectUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"object"})},getPostProUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"postPro"})},getClippingUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"clipping"})},getPDSFXUniform({uniformName:n}){return this._getUniform({uniformName:n,uniformCategory:"pdsfx"})},_getTextureUniform({uniformName:n,uniformCategory:e}){return this._context||(this._context={}),this._context.__fetchedUniforms__||(this._context.__fetchedUniforms__={}),this._context.__fetchedUniforms__[e]||(this._context.__fetchedUniforms__[e]={}),this._context.__fetchedUniforms__[e][n]=!0,n},getTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"material"})},getGlobalTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"global"})},getLightTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"light"})},getShadowTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"shadow"})},getObjectTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"object"})},getPostProTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"postPro"})},getClippingTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"clipping"})},getPDSFXTextureUniform({uniformName:n}){return this._getTextureUniform({uniformName:n,uniformCategory:"pdsfx"})}}}),define("DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils",["DS/Mesh/ThreeJS_Base"],function(n){"use strict";const e={out0:"gl_FragColor",fragCoord:"gl_FragCoord",frontFacing:"gl_FrontFacing",position:"gl_Position"};return{_context:null,ShaderStages:{in:"input",out:"out"},addVarying:function({varyingName:e,varyingType:t,size:r=0,checkName:a=!1}){const o=n.ToGLSLTypes[t];return a&&"v"!==e[0]&&console.warn('Bad Practice: start the name of your varyings with "v"'),o?o.canBeVarying?0===r&&o.isArray?(console.error(`Invalid Operation: ${t} for ${e} is not a proper array`),""):(r>0&&!o.isArray&&(r=0,console.warn(`Invalid Operation: ${t} for ${e} can not be an array, overriding to single`)),this._context.__varyings__[e]={type:t,size:r,dynamic:!0},this._context.isWebGPU?"":r>0?`\n                        varying ${o.t} ${e}[${r}];\n                    `:`\n                    varying ${o.t} ${e};\n                `):(console.error(`Invalid Operation: ${t} for ${e} can not be a varying`),""):(console.error(`Invalid Operation: ${t} for ${e} is not a proper type`),"")},getVarying(n,e){return this._context.isWebGPU?`${e}.${n}`:n},getPDSFXVarying:(n,e)=>n,getBuiltin:function(n,t){return this._context.__builtins__[t]=this._context.__builtins__[t]||{},this._context.__builtins__[t][n]=!0,this._context.isWebGPU?`${t}.${n}`:e[n]},getShaderOutput(n){return this.getBuiltin(n,this.ShaderStages.out)},getShaderInput(n){return this.getBuiltin(n,this.ShaderStages.int)}}}),define("DS/ShaderBuilders/ShaderUtils/TypeUtils",["DS/Mesh/ThreeJS_Base"],function(n){"use strict";const e={_context:null,_isValid:function({type:e,size:t=0,custom:r=!1,addressSpace:a=""}){if(r)return!0;const o=n.ToGLSLTypes[e];return o?0===t&&o.isArray?(console.warn(`Invalid Operation: ${e} is not a proper array`),!1):!(t>0&&!o.isArray)||(console.warn(`Invalid Operation: ${e} is can not be an array`),!1):(console.warn(`Invalid Operation: ${e} is not a proper type`),!1)},declareStructure:function({name:n,size:e=0,constant:t=!1,addressSpace:r="",structName:a}){return this.declareVariable({name:n,constant:t,type:a,size:e,custom:!0,addressSpace:r})},createStructure:function({structName:e,attributes:t=[]}){if(!t||0===t.length)throw"Invalid create structure usage, expected attributes";let r="";for(let e=0;e<t.length;e++){const o=t[e],i=o.name;if(!i||!this._isValid(o))return"";const s=!!o.custom,l=o.type;if(this._context.isWebGPU){r=`\n                        ${r}\n                        ${i} : ${(a=s?{t:l}:n.ToWGSLTypes[l]).t},\n                    `}else{var a=s?{t:l}:n.ToGLSLTypes[l];const e=o.size;r=e>0?`\n                            ${r}\n                            ${a.t} ${i}[${e}];\n                        `:`\n                            ${r}\n                            ${a.t} ${i};\n                        `}}return`\n                struct ${e} {\n                    ${r}\n                };\n            `},declareVariable:function({name:e,type:t,size:r=0,addressSpace:a="",constant:o=!1,custom:i=!1}){const s=e;let l=this._context&&this._context.isWebGPU;if(!s||!this._isValid({type:t,size:r,custom:i,addressSpace:a}))return"";const u=i?{t:t}:l?n.ToWGSLTypes[t]:n.ToGLSLTypes[t];if(l)return o?`const ${s}`:`var${""!==a?"<"+a+">":""} ${s} : ${u.t} `;let m;return m=r>0?`${u.t} ${s}[${r}]`:`${u.t} ${s}`,o&&(m=`const ${m}`),m},getType:function({type:e,custom:t=!1}){if(!this._isValid({type:e}))return"";return`${(t?{t:e}:this._context&&this._context.isWebGPU?n.ToWGSLTypes[e]:n.ToGLSLTypes[e]).t}`},reference(){return this._context.isWebGPU?"&":""},dereference(){return this._context.isWebGPU?"*":""}};{const n=[{name:"float",type:"f",typeV:"fv1"},{name:"vec2",type:"v2",typeV:"fv2"},{name:"vec3",type:"v3",typeV:"fv3"},{name:"vec4",type:"v4",typeV:"fv4"},{name:"int",type:"i",typeV:"iv1"},{name:"ivec2",type:"i2",typeV:"iv2"},{name:"ivec3",type:"i3",typeV:"iv3"},{name:"ivec4",type:"i4",typeV:"iv4"},{name:"bool",type:"b",typeV:"bv1"},{name:"bvec2",type:"b2",typeV:"bv2"},{name:"bvec3",type:"b3",typeV:"bv3"},{name:"bvec4",type:"b4",typeV:"bv4"},{name:"mat2",type:"m2",typeV:"m2v"},{name:"mat3",type:"m3",typeV:"m3v"},{name:"mat4",type:"m4",typeV:"m4v"}];function t(n){e[n.name]=function({name:e=null,size:t=0,addressSpace:r="",constant:a=!1}){const o=t?n.typeV:n.type;return e?this.declareVariable({name:e,type:o,size:t,addressSpace:r,constant:a}):this.getType({type:o})}}for(let e=0;e<n.length;e++){t(n[e])}}return e}),define("DS/ShaderBuilders/WebGPUShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/Materials/PostProMaterial"],function(n,e){"use strict";return class{constructor(){this.attributeOrder=["aPosition","aNormal","aUv","aUv2","aColor","aTangent","aBinormal","aLneDistance","aPatternStartEnd","aPreviousPos","aFollowingPos","aSideExtrusion","aInstanceId","aMorphTarget0","aMorphTarget1","aMorphTarget2","aMorphTarget3","aMorphNormals0","aMorphNormals1","aMorphNormals2","aMorphNormals3","aMorphNormals4","aMorphNormals5","aMorphNormals6","aMorphNormals7","aSkinIndex","aSkinWeight"]}isSupported(n,t){return n instanceof e||!(!n.isPhysicalMaterial||n.isInstancingMaterial)&&!(t.billboard||t.isDecal||t.fixedSize||t.maxPolygonSize>0||t.maxPolyLineSize>0||t.maxNbPolyLine>0||t.maxNbScissor>0)&&!(t.sslreflectionEnabled||t.sslrefractionEnabled||t.PDSFX||t.shadowMapEnabled||t.lightMap||t.useOIT||t.useSSAO||t.vertexColors)&&!(t.compressedColors||t.compressedNormals||t.compressedUVs||t.compressedVertices)&&!(t.maxDirIBLLights>0||t.maxDiskLights>0||t.maxPointLights>0||t.maxTubeLights>0||t.maxSphereLights>0||t.maxSpotLights>0||t.maxRectangleLights>0)&&!(t.needTangent||t.normalScaleMap||t.opacityMap||t.translucencyMap||t.transparencyMap||t.bumpMap||t.subsurface)}getAlignOf(n){switch(n){case"i":case"f":return 4;case"v2":return 8;case"v3":case"fv3":case"v4":return 16;case"m2":return 8;case"m3":case"m4":return 16}return 16}getSizeOf(n){switch(n){case"i":case"f":return 4;case"v2":return 8;case"fv3":case"v3":return 12;case"v4":case"m2":return 16;case"m3":return 48;case"m4":return 64}return 4}_computeOffsetsAndSize(n,e){var t=this,r=n.shaderContext.__uniforms__,a=0,o=1,i=0,s=[];for(var l in r)($=r[l]).ubo===e&&"t2"!==$.type&&s.push($);s.sort(function(n,e){return t.getAlignOf(e.type)-t.getAlignOf(n.type)});for(var u=s.length-1,m=0;m<s.length;m++){var $;if(($=s[m]).offset>=0)break;var c=$.size?$.size:1,p=(a=this.getSizeOf($.type),this.getAlignOf($.type)),d=(p-i%p)%p;if(p>o&&(o=p),c>1&&(a+=p-a%p),d>0&&m<u){var f=s[u],h=this.getSizeOf(f.type);4===d?4!==h||f.size?2!==h||f.size||(f.offset=i,m<--u&&(f=s[u],2!==(h=this.getSizeOf(f.type))||f.size||(f.offset=i+2,u--))):(f.offset=i,u--):2===d&&(2!==h||f.size||(f.offset=i,u--))}i+=d,$.offset=i,i+=c*a}s.sort(function(n,e){return n.offset-e.offset}),n.shaderIO.orderedUniforms||(n.shaderIO.orderedUniforms={}),n.shaderIO.orderedUniforms[e]=s;let g=i+(o-i%o)%o;return Math.max(g,16)}computeLayoutInfos(n){n.shaderIO.structSize.object=this._computeOffsetsAndSize(n,"object"),n.shaderIO.structSize.light=this._computeOffsetsAndSize(n,"light"),n.shaderIO.structSize.material=this._computeOffsetsAndSize(n,"material")}getVertexInCode(e){for(var t=e.attribute,r=0,a="struct VertexInput {\n",o=0;o<this.attributeOrder.length;o++){var i=this.attributeOrder[o];t[i]&&(a+="@location("+r+") "+i+" : "+n.ToWGSLTypes[t[i].type].t+",\n",t[i].location=r,r++)}return a+"};\n"}getVaryingCode(e){var t=e.shaderContext.__varyings__,r=0,a="";for(var o in t)"position"!==o&&(a+="@location("+r+") ",r++,a+=o+" : "+n.ToWGSLTypes[t[o].type].t+",\n");return a+"};\n"}getVertexOutCode(n){var e="struct VertexOutput {\n";return e+="@builtin(position) position : vec4f,\n",e+=this.getVaryingCode(n)}getFragmentInCode(n){var e="struct FragmentInput {\n";return e+="@builtin(front_facing) frontFacing: bool,\n",e+="@builtin(position) fragCoord: vec4f,\n",e+=this.getVaryingCode(n)}_getGenericUniformsCode(e,t,r){var a=e.orderedUniforms[t.toLowerCase()];if(!a.length)return"";for(var o="struct "+t+"Uniforms {\n",i=0;i<a.length;i++){var s=a[i];s.size?o+=s.name+" : array<"+n.ToWGSLTypes[s.type].t+", "+s.size+">,\n":o+=s.name+" : "+n.ToWGSLTypes[s.type].t+",\n"}return o+="};\n",o+="@group("+r+") @binding(0) var<uniform> "+t.toLowerCase()+"_uniforms : "+t+"Uniforms;\n"}_getFrameUniformsCode(e,t){var r=e.shaderContext.__uniforms__,a="struct FrameUniforms {\n";for(var o in r)"global"===r[o].ubo&&(a+=o+" : "+n.ToWGSLTypes[r[o].type].t+",\n");return a+="};\n",a+="@group("+t+") @binding(0) var<uniform> global_uniforms : FrameUniforms;\n"}_getMaterialUniformsCode(n,e){var t=n.shaderContext.__uniforms__,r=this._getGenericUniformsCode(n.shaderIO,"Material",e),a=1;for(var o in t)"material"===t[o].ubo&&"t2"===t[o].type&&(r+="@group("+e+") @binding("+a+++") var "+o+"Sampler : sampler;\n",r+="@group("+e+") @binding("+a+++") var "+o+" : texture_2d<f32>;\n");return r}getUniformsCode(n,e){var t=0,r="";for(let a=0;a<e.length;a++)switch(e[a]){case"Frame":r+=this._getFrameUniformsCode(n,t++)+"\n";break;case"Light":n.useLighting&&(r+=this._getGenericUniformsCode(n.shaderIO,"Light",t++)+"\n");break;case"Object":r+=this._getGenericUniformsCode(n.shaderIO,"Object",t++)+"\n";break;case"Material":r+=this._getMaterialUniformsCode(n,t++)+"\n"}return r}}}),define("DS/ShaderBuilders/ShaderUtils/FunctionUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e){"use strict";const t="",r=/(_[0-9]+$)/;function a(e,t){let r;if(e){n.ToGLSLTypes[e];r=e}else r="void";let a="";for(let e=0;e<t.length;e++){let r=t[e];if(!n.ToGLSLTypes[r.type]&&!r.custom)throw`Invalid Operation: ${r.type} for ${r.name} is not a proper type`;a+=r.type,r.inOut&&(a+="!io"),e!==t.length-1&&(a+=";")}return r+";"+a}class o{constructor(n){this.name=n,this.count=0,this.sigToName=new Map}addFunction(n,e,t){const r=a(n,e);this.sigToName.has(r)||(0===this.count?this.sigToName.set(r,this.name):this.sigToName.set(r,this.name+"_"+this.count),this.count++)}getFunction(n,e){const t=a(n,e);if(!this.sigToName.has(t))throw`Invalid Operation: ${t} for ${this.name} not declared`;return this.sigToName.get(t)}toWebGLDeclare(e,t,a){let o;if(e){const t=n.ToGLSLTypes[e];o=t?t.t:e}else o="void";let i=this.getFunction(e,t);a||(i=i.replace(r,""));let s="";for(let e=0;e<t.length;e++){const r=t[e],a=r.custom?r.type:n.ToGLSLTypes[r.type].t;s+=`${r.inOut?"inout":"const in"} ${a} ${r.name}`,e!==t.length-1&&(s+=",")}return`${o} ${i}(${s})`}toWebGLCall(n,a,o){let i=this.getFunction(n,a);o||(i=i.replace(r,""));let s="";for(let n=0;n<a.length;n++){const r=a[n];s+=`${r.toRef?e.reference():t}${r.name}`,n!==a.length-1&&(s+=",")}return`${i}(${s})`}toWebGPUDeclare(e,t){let r="";if(e){const t=n.ToWGSLTypes[e];r=t?" -> "+t.t:" -> "+e}const a=this.getFunction(e,t);let o="";for(let e=0;e<t.length;e++){const r=t[e],a=r.custom?r.type:n.ToWGSLTypes[r.type].t;var i=r.inOut?`ptr<function, ${a}>`:a;o+=`${r.name} : ${i}`,"t2"===r.type&&(o+=`, ${r.name}Sampler : sampler`),e!==t.length-1&&(o+=",")}return`fn ${a}(${o})${r}`}toWebGPUCall(n,r){const a=this.getFunction(n,r);let o="";for(let n=0;n<r.length;n++){const a=r[n],i=`${a.toRef?e.reference():t}${a.name}`;o+=i,"t2"===a.type&&(o+=","+i+"Sampler"),n!==r.length-1&&(o+=",")}return`${a}(${o})`}}return{FunctionHandler:new class{constructor(){this._context=null}declareFunction(n,e,t){this._context||(this._context={}),this._context.__functions__||(this._context.__functions__=new Map);let r=this._context.__functions__,a=r.get(n);return a||(a=new o(n),r.set(n,a)),a.addFunction(e,t,this._context.isWebGPU),this._context.isWebGPU?a.toWebGPUDeclare(e,t):a.toWebGLDeclare(e,t,this._context.isWebGPU)}callFunction(n,e,t){this.declareFunction(n,e,t);let r=this._context.__functions__.get(n);return this._context.isWebGPU?r.toWebGPUCall(e,t):r.toWebGLCall(e,t,this._context.isWebGPU)}sample2DTexture(n,e){if(!e)throw"Missing uv in sample2DTexture";return this._context.isWebGPU?`textureSample(${n}, ${n}Sampler, ${e})`:`texture2D(${n}, ${e})`}sampleCubeTexture(n,e){return this._context.isWebGPU?`textureSample(${n}, ${n}Sampler, ${e})`:`textureCube(${n}, ${e})`}getMainVertexStart(){return this._context.isWebGPU?"@vertex\n            fn vertex_main(input: VertexInput) -> VertexOutput {\n                var out: VertexOutput;\n            ":"void main() {"}getMainVertexEnd(){return this._context.isWebGPU?"\n                return out;\n            }\n            ":"}"}getMainFragmentStart(){return this._context.isWebGPU?"\n            struct FragmentOutput\n            {\n                @location(0) out0 : vec4f\n            };\n\n            @fragment\n            fn fragment_main(input : FragmentInput) -> FragmentOutput {\n                var out : FragmentOutput;\n            ":"void main() {"}getMainFragmentEnd(){return this._context.isWebGPU?"\n                return out;\n            }\n            ":"}"}getEarlyFragmentEnd(){return this._context.isWebGPU?"\n                return out;\n            ":"return;"}},ParameterUtils:{parameter:function(n,e,t=!1){return{inOut:!1,name:e,type:n,toRef:!1,custom:t}},parameterB:function(n){return this.parameter("b",n)},parameterF:function(n){return this.parameter("f",n)},parameterI:function(n){return this.parameter("i",n)},parameterV2:function(n){return this.parameter("v2",n)},parameterV3:function(n){return this.parameter("v3",n)},parameterV4:function(n){return this.parameter("v4",n)},parameterM2:function(n){return this.parameter("m2",n)},parameterM3:function(n){return this.parameter("m3",n)},parameterM4:function(n){return this.parameter("m4",n)},parameterT2:function(n){return this.parameter("t2",n)},parameterTC:function(n){return this.parameter("tc",n)},parameterInOut:function(n,e,t=!1){return{inOut:!0,name:e,type:n,toRef:!1,custom:t}},parameterInOutB:function(n){return this.parameterInOut("b",n)},parameterInOutF:function(n){return this.parameterInOut("f",n)},parameterInOutI:function(n){return this.parameterInOut("i",n)},parameterInOutV2:function(n){return this.parameterInOut("v2",n)},parameterInOutV3:function(n){return this.parameterInOut("v3",n)},parameterInOutV4:function(n){return this.parameterInOut("v4",n)},parameterInOutM2:function(n){return this.parameterInOut("m2",n)},parameterInOutM3:function(n){return this.parameterInOut("m3",n)},parameterInOutM4:function(n){return this.parameterInOut("m4",n)},parameterRef:function(n,e,t=!1){return{inOut:!0,name:e,type:n,toRef:!0,custom:t}},parameterRefB:function(n){return this.parameterRef("b",n)},parameterRefF:function(n){return this.parameterRef("f",n)},parameterRefI:function(n){return this.parameterRef("i",n)},parameterRefV2:function(n){return this.parameterRef("v2",n)},parameterRefV3:function(n){return this.parameterRef("v3",n)},parameterRefV4:function(n){return this.parameterRef("v4",n)},parameterRefM2:function(n){return this.parameterRef("m2",n)},parameterRefM3:function(n){return this.parameterRef("m3",n)},parameterRefM4:function(n){return this.parameterRef("m4",n)}}}}),define("DS/ShaderBuilders/FiniteEnvMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=n=>i.parameterF(n),u=n=>i.parameterV2(n),m=n=>i.parameterV3(n),$=n=>i.parameterT2(n),c=(n,e,t)=>s.declareFunction(n,e,t),p=(n,e,t)=>s.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},g=(n=null)=>{var e={name:n};return o.float(e)},v=(n=null)=>{var e={name:n};return o.vec2(e)},S=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},y=n=>{var e={name:n,constant:!0};return o.float(e)},_=n=>r.addVarying(n);return new e(function(e,t){let a=n._ShaderChunk,o=n._DefaultShaderChunk,i=`\n            #define FINITEENVMAP\n            ${t.useLatLongMap?`\n                ${d({uniformName:"tEnvMap",uniformType:"t2"})}\n                `:`\n                ${d({uniformName:"tEnvMap",uniformType:"tc"})}\n                `}\n\n            ${d({uniformName:"blurCoef",uniformType:"f"})}\n            ${d({uniformName:"withGround",uniformType:"f"})}\n            ${d({uniformName:"envMapExposure",uniformType:"f"})}\n            ${d({uniformName:"ambient",uniformType:"v3"})}\n            ${d({uniformName:"groundPosition",uniformType:"v3"})}\n            ${d({uniformName:"groundNormal",uniformType:"v3"})}\n            ${d({uniformName:"sceneHeight",uniformType:"v3"})}\n            ${d({uniformName:"groundHeight",uniformType:"v3"})}\n            ${d({uniformName:"groundOffset",uniformType:"f"})}\n            ${d({uniformName:"groundRadius",uniformType:"f"})}\n            ${d({uniformName:"groundScale",uniformType:"f"})}\n            ${d({uniformName:"invScreenSize",uniformType:"v2"})}\n            ${d({uniformName:"cameraSight",uniformType:"v3"})}\n            ${d({uniformName:"cameraUp",uniformType:"v3"})}\n            ${d({uniformName:"cameraRight",uniformType:"v3"})}\n            ${d({uniformName:"near",uniformType:"f"})}\n            ${d({uniformName:"right",uniformType:"f"})}\n            ${d({uniformName:"up",uniformType:"f"})}\n            ${d({uniformName:"startOffset",uniformType:"v2"})}\n            ${d({uniformName:"endOffset",uniformType:"v2"})}\n            ${d({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${d({uniformName:"projectionConic",uniformType:"f"})}\n\n            ${_({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${y("PI")} = 3.14159;\n            ${y("INV_PI")} = 0.31830988618;\n\n            ${t.useHDR&&!t.useHDRFloat?`\n                ${d({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${d({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})}\n    \n                ${o.rgbe_sample_methods(t)}\n\n                ${c("sampleMipMapRoughness","v4",[u("uv"),l("mip"),l("coef"),$("map0"),$("map1"),u("textureSize"),u("texelSize")])}{\n                    ${x("color1")} ;\n                    ${x("color2")} ;\n                    ${v("uv1")} ;\n                    ${v("uv2")} ;\n                    ${v("textureSize2")} = textureSize * ${f("envMapHDRToMipsRatio")} * ${v()}(1.0,2.0);\n                    ${v("texelSize2")}  = texelSize / ${f("envMapHDRToMipsRatio")} * ${v()}(1.0,2.0);\n                    if (mip < 1.0) {\n                        color1 = ${p("texture2DBilinearFromRGBE","v4",[$("map0"),u("uv"),u("textureSize"),u("texelSize")])};\n                    } else {\n                        ${g("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                        ${g("t10")}  = pow(2.0, -floor(log2(level1 + 1.0)));\n                        ${g("t11")}  = 2.0 - (level1 + 2.0) * t10;\n                        ${g("t12")}  = 0.5 * t10;\n\n                        uv1 = ${v()}(t11 + 1.5 * texelSize2.x + (2.0 * t12 - 3.0 * texelSize2.x) * uv.x, t12 + 1.5 * texelSize2.x + (t12 - 3.0 * texelSize2.x) * uv.y);\n                        color1 = ${p("texture2DBilinearFromRGBE","v4",[$("map1"),u("uv1"),u("textureSize2"),u("texelSize2")])};\n                    }\n\n                    ${g("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                    ${g("t20")}  = pow(2.0, -floor(log2(level2 + 1.0)));\n                    ${g("t21")}  = 2.0 - (level2 + 2.0) * t20;\n                    ${g("t22")}  = 0.5 * t20;\n\n                    uv2 = ${v()}(t21 + 1.5 * texelSize2.x + (2.0 * t22 - 3.0 * texelSize2.x) * uv.x, t22 + 1.5 * texelSize2.x + (t22 - 3.0 * texelSize2.x) * uv.y);\n                    color2 = ${p("texture2DBilinearFromRGBE","v4",[$("map1"),u("uv2"),u("textureSize2"),u("texelSize2")])};\n\n                    return mix(color1, color2, coef);\n                }\n                `:""}\n\n            ${c("MapNormalToTextureCoordinate","v2",[m("iNormal")])}{\n                ${g("phi")}  = atan(iNormal.y, iNormal.x);\n                ${g("theta")}  = acos(iNormal.z);\n                return ${v()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n            }\n\n            ${c("IntersectPlane","f",[m("iPos"),m("iRay"),m("iPlaneOrig"),m("iPlaneNormal")])} {\n                ${g("t")}  = dot(iPlaneNormal, iPlaneOrig-iPos);\n                ${g("cosNormalDir")}  = dot(iPlaneNormal, iRay);\n                if (cosNormalDir==0.0) return 0.0;\n                return t/cosNormalDir;\n            }\n\n            ${c("IntersectSphereFar","f",[m("iSphereCenter"),l("iSphereRadius"),m("iRayDir"),m("iRayOrig")])} {\n               ${S("dist")}  = iRayOrig - iSphereCenter;\n               ${g("B")}  = 2.0*dot(iRayDir, dist);\n               ${g("C")}  = dot(dist, dist) - iSphereRadius*iSphereRadius;\n               ${g("disc")}  = B*B - 4.0*C;\n               if (disc < 0.0) return -1.0;\n               return (-B + sqrt(disc)) / 2.0;\n            }\n\n            ${a.postprocess_pars_fragment(t)}\n            \n            void main() {\n                ${S("n")}  = normalize(${(n=>r.getVarying(n,r.ShaderStages.in))("vWorldPosition")} - ${h("cameraPosition")});\n                ${S("groundPos")}  = (${f("ambienceMatrix")} * ${x()}(${f("groundPosition")}, 1.0)).xyz;\n                ${S("groundNor")}  = (${f("ambienceMatrix")} * ${x()}(${f("groundNormal")}, 0.0)).xyz;\n                ${S("sphereCenter")}    = groundPos + groundNor * ${f("sceneHeight")} * ${f("groundRadius")};\n                ${S("offset")}    = ${S()}(0.0,0.0,${f("groundOffset")});\n                offset = (${f("ambienceMatrix")} * ${x()}(offset, 0.0)).xyz;\n\n                ${t.useAmbianceV2?`\n                    groundNor = ${f("groundNormal")};\n                    sphereCenter  = ${f("groundPosition")} +  ${f("sceneHeight")} * ${f("groundRadius")};\n                    offset = ${f("groundOffset")} * groundNor;\n                    groundPos = ${f("groundPosition")} + offset;\n                    `:""}\n\n                ${g("sphereRadius")}   = ${f("groundRadius")} * ${f("groundScale")};\n                ${S("rayDir")}        = ${S()}(0.0);\n                ${S("rayOrig")}       = ${S()}(0.0);\n                if (sphereRadius > 0.0) {\n                    if (${f("projectionConic")} > 0.0 ) {\n                        rayDir      = n;\n                        rayOrig     = ${h("cameraPosition")};\n                    } else {\n                        ${v("screenOffset")}  = 2.0 * mix(${f("startOffset")}, ${f("endOffset")}, gl_FragCoord.xy * ${f("invScreenSize")}) - 1.0;\n                        ${S("centerPosition")}  = ${h("cameraPosition")} - (${f("cameraSight")} * ${f("near")});\n                        n = normalize(${f("cameraSight")} + screenOffset.x * ${f("cameraRight")} + screenOffset.y * ${f("cameraUp")});\n                        rayOrig = centerPosition + screenOffset.x * (${f("cameraRight")}*${f("right")}) + screenOffset.y * (${f("cameraUp")} * ${f("up")});\n                        rayDir = ${f("cameraSight")};\n                    }\n                    ${g("t")} =  ${p("IntersectSphereFar","f",[m("sphereCenter"),l("sphereRadius"),m("rayDir"),m("rayOrig")])};\n                    ${S("planeNormal")} = groundNor;\n                    if (t>0.0) {\n                        if (dot(planeNormal, rayDir)<0.0){\n                            ${t.useAmbianceV2?`${g("planeT")} = ${p("IntersectPlane","f",[m("rayOrig"),m("rayDir"),m("groundPos"),m("planeNormal")])};`:`${g("planeT")} = ${p("IntersectPlane","f",[m("rayOrig"),m("rayDir"),m("groundPos + offset"),m("planeNormal")])};`}\n                            planeT = planeT * ${f("withGround")};\n                            if (${f("projectionConic")} > 0.0 ) {\n                                t = (planeT>0.0) ? min(planeT,t) : t;\n                            } else {\n                                t =  min(planeT,t);\n                            }\n                        }\n                        ${S("hitPos")}  = rayOrig + t*rayDir;\n                        ${t.useAmbianceV2?`${S("projectionCenter")}  = ${f("groundPosition")} + ${f("groundHeight")} * sphereRadius;`:`${S("projectionCenter")}  = groundPos + offset + groundNor * ${f("groundHeight")}*${f("groundRadius")};`}\n                        ${S("sn")}  = (hitPos - projectionCenter);\n                        n = normalize(sn);\n                    }\n                }\n                ${S("mapColor")};\n                ${t.useLatLongMap?`\n                    n = (${f("ambienceMatrix")} * ${x()}(n, 0.0)).xyz;\n                    ${t.useHDR?"":"n.y *= -1.0;"}\n                    ${v("coords")}  = ${p("MapNormalToTextureCoordinate","v2",[m("n")])};\n                    ${t.useHDR&&!t.useHDRFloat?`\n                        ${v("texelSize")} = ${v()}(1.0 / ${f("envMapHDRSize")});\n                        mapColor = ${p("texture2DBilinearFromRGBE","v4",[$("tEnvMap"),u("coords"),u(`${f("envMapHDRSize")}`),u("texelSize")])}.xyz;\n                        `:`mapColor = ${s.sample2DTexture("tEnvMap","coords")}.xyz;`}\n                    `:`\n                    n = (${f("ambienceMatrix")} * ${x()}(n, 0.0)).xyz;\n                    mapColor= ${s.sampleCubeTexture("tEnvMap",`${S()}(n.x, -n.z,n.y)`)}.xyz;\n                    `}\n                gl_FragColor.x = mapColor.x;\n                gl_FragColor.y = mapColor.y;\n                gl_FragColor.z = mapColor.z;\n                gl_FragColor.w = 1.0;\n                ${!t.gammaOutput&&t.useSRGB?`\n                    ${S("convertedColor")} = ${p("convertToLinear","v3",[m("gl_FragColor.xyz")])};\n                    gl_FragColor.x = convertedColor.x;\n                    gl_FragColor.y = convertedColor.y;\n                    gl_FragColor.z = convertedColor.z;\n                    `:""}\n\n                gl_FragColor *= ${x()}(${f("ambient")} * ${f("envMapExposure")}, 1.0);\n                ${a.postprocess_fragment(t)}\n                ${t.gammaOutput&&t.useHDR?a.linear_to_gamma_fragment(t):""}\n            }\n        `;return{vertexShader:`\n            #define FINITEENVMAP\n            ${_({varyingName:"vWorldPosition",varyingType:"v3"})}\n            void main() {\n                ${x("worldPosition")} = modelMatrix * ${x()}( position_, 1.0 );\n                ${(n=>r.getVarying(n,r.ShaderStages.out))("vWorldPosition")} = worldPosition.xyz;\n                ${o.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:i}})}),define("DS/ShaderBuilders/Commons/ShadowingShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=r.FunctionHandler,l=()=>a.dereference(),u=n=>i.parameterF(n),m=n=>i.parameterI(n),$=n=>i.parameterV2(n),c=n=>i.parameterV3(n),p=n=>i.parameterV4(n),d=n=>i.parameterT2(n),f=n=>i.parameterTC(n),h=(n,e,t)=>s.declareFunction(n,e,t),g=(n,e,t)=>s.callFunction(n,e,t),v=n=>e.addShadowUniform(n),S=n=>{var t={uniformName:n};return e.getShadowUniform(t)},x=n=>t.addVarying(n),y=n=>t.getVarying(n,t.ShaderStages.in),_=(n=null)=>{var e={name:n};return a.bool(e)},T=(n=null)=>{var e={name:n};return a.int(e)},D=(n=null,e=0)=>{var t={name:n,size:e};return a.float(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return a.vec2(t)},P=(n=null)=>{var e={name:n};return a.bvec2(e)},N=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},M=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},b=(n=null)=>{var e={name:n};return a.bvec4(e)},w=(n=null)=>{var e={name:n};return a.mat3(e)},U=n=>{var e={name:n,constant:!0};return a.int(e)},z=n=>{var e={name:n,constant:!0};return a.float(e)},V=(n,e,t)=>g("texture2DCompare","f",[d(n),$(e),u(t)]),F=n=>g("unpackDepthESM","f",[p(n)]),R=(n,e,t,r,a)=>g("texture2DShadowLerp","f",[d(n),$(e),$(t),$(r),u(a)]),A=(n,e,t,r,a)=>g("compESM","f",[d(n),$(e),u(t),$(r),$(a)]),I=(n,e,t,r)=>g("esmLinearSampling","f",[d(n),$(e),$(t),$(r)]),L=(n,e,t,r,a)=>g("texture2DShadowESMLerp","f",[d(n),$(e),$(t),$(r),u(a)]),B=(n,e,t)=>g("textureCubeCompare","f",[f(n),c(e),u(t)]);function k(n,e){var t=o;if(e){t=`\n                ${t}\n                ${h("getExposureFromIndexCube","f",[m("index"),c("worldPosition")])}{\n                    ${D("result")} ;\n            `;for(r=0;r<n.maxShadowsCube;r++)t=`\n                    ${t}\n                    if (index == ${r}) {\n                        result = ${g("getExposure","f",[c(`${S("shadowPointPosition")}[${r}].xyz`),c("worldPosition"),f(`shadowMapCube[${r}]`),u(`${S("shadowBiasCube")}[${r}]`),u(`${S("shadowPointPosition")}[${r}].w`),u(`${S("shadowNearCube")}[${r}]`),u(`${S("shadowFarCube")}[${r}]`)])};\n                    }\n                `;t=`\n                ${t}\n                    return result;\n                }\n            `}else{t=`\n                ${t}\n                ${h("getExposureFromIndex","f",[m("index")])}{\n                    ${D("result")} ;\n            `;for(var r=0;r<n.maxShadows;r++)t=`\n                    ${t}\n                    if (index == ${r}) {\n                        result = ${g("getExposure","f",[p(`gShadowCoord[${r}]`),d(`shadowMap[${r}]`),u(`${S("shadowBias")}[${r}]`),$(`${S("shadowMapSize")}[${r}]`)])};\n                    }\n                `;t=`\n                ${t}\n                    return result;\n                }\n            `}if(n.transparentShadowEnabled)if(e){t=`\n                    ${t}\n                    ${h("getTransparentExposureFromIndexCube","v4",[m("index"),c("worldPosition")])}{\n                        ${M("result")} ;\n                `;for(r=0;r<n.maxShadowsCube;r++)t=`\n                        ${t}\n                        if (index == ${r}) {\n                            ${M("lPosition")}  =  ${M()}( ${S("shadowPointPosition")}[${r}].xyz, 1.0 );\n                            ${N("pointVector")}  = normalize(worldPosition.xyz-lPosition.xyz);\n                            result = ${s.sampleCubeTexture(`transparentShadowMapCube[${r}]`,"pointVector")};\n                        }\n                    `;t=`\n                    ${t}\n                        return result;\n                    }\n                `}else{t=`\n                    ${t}\n                    ${h("getTransparentExposureFromIndex","v4",[m("index")])}{\n                        ${M("result")} ;\n                `;for(var r=0;r<n.maxShadows;r++)t=`\n                        ${t}\n                        if (index == ${r}) {\n                            ${N("shadowCoord")}  = gShadowCoord[${r}].xyz / gShadowCoord[${r}].w;\n                            ${D("isNotbehindFrustum")}  = step(0.0,gShadowCoord[${r}].w);\n                            result = isNotbehindFrustum * ${s.sample2DTexture(`transparentShadowMap[${r}]`,"shadowCoord.xy")} + (1.0-isNotbehindFrustum) * ${M()}(1.0);\n                        }\n                    `;t=`\n                    ${t}\n                        return result;\n                    }\n                `}return t}return{shadowmap_pars_fragment:function(e){var t="";if(e.shadowMapEnabled||e.shadowMapCubeEnabled){if(t=`\n                    ${t}\n                    ${h("unpackDepthESM","f",[p("rgba_depth")])}{\n                        ${D("depth")}  = ${g("unpackRGB","f",[c("rgba_depth.xyz")])} * pow(10.0,rgba_depth.w*255.0);\n                        return depth;\n                    }\n\n                    ${h("randomValue","f",[c("scale"),u("seed")])}{\n                        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n                    }\n                `,e.shadowMapEnabled){var r=e.maxShadows;t=`\n                        ${t}\n                        ${v({uniformName:"shadowMap",uniformType:"t2v",size:r})} \n                        ${v({uniformName:"shadowMapSize",uniformType:"fv2",size:r})} \n                        ${v({uniformName:"shadowDarkness",uniformType:"fv1",size:r})} \n                        ${v({uniformName:"shadowBias",uniformType:"fv1",size:r})} \n                        ${e.subsurface?`\n                            ${v({uniformName:"shadowMapNear",uniformType:"fv1",size:r})} \n                            ${v({uniformName:"shadowMapFar",uniformType:"fv1",size:r})} \n                            `:o}\n                        ${e.transparentShadowEnabled?`\n                            ${v({uniformName:"transparentShadowMap",uniformType:"t2v",size:r})} \n                            ${e.maxDirLights>0?v({uniformName:"directionalLightColorNoIntensity",uniformType:"fv4",size:e.maxDirLights}):o}\n                            ${e.maxSpotLights>0?v({uniformName:"spotLightColorNoIntensity",uniformType:"fv4",size:e.maxSpotLights}):o}\n                            `:o}\n                        ${U("SHADOWS_DIR_END")}  = ${e.maxDirShadows};\n                        ${U("SHADOWS_SPOT_START")}  = SHADOWS_DIR_END;\n                        ${U("SHADOWS_SPOT_END")}  = SHADOWS_SPOT_START + ${e.maxSpotShadows};\n                        ${U("SHADOWS_DIR_IBL_START")}  = SHADOWS_SPOT_END;\n                        ${U("SHADOWS_DIR_IBL_END")}  = SHADOWS_DIR_IBL_START + ${e.maxDirIBLShadows};\n                        ${U("SHADOWS_CASTABLE_END")}  = SHADOWS_DIR_IBL_START;\n                    `,e.shadowMapType!==n.PCFPoissonShadowMap&&e.shadowMapType!==n.PCFInterpolShadowMap||(t=`\n                            ${t}\n                            ${e.shadowMapQuality===n.MediumQuality?`\n                                ${v({uniformName:"poissonDisk",uniformType:"fv2",size:25})} \n                                ${U("poissonCount")}  = 25;\n                                ${z("poissonInvSamples")}  = 0.04;\n                                `:o}\n                            ${e.shadowMapQuality===n.HighQuality?`\n                                ${v({uniformName:"poissonDisk",uniformType:"fv2",size:49})} \n                                ${U("poissonCount")}  = 49;\n                                ${z("poissonInvSamples")}  = 0.02040816326;\n                                `:o}\n                            ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                                ${v({uniformName:"poissonDisk",uniformType:"fv2",size:9})} \n                                ${U("poissonCount")}  = 9;\n                                ${z("poissonInvSamples")}  = 0.111111;\n                                `:o}\n                        \n                        `),t=`\n                        ${t}\n                        ${M("gShadowCoord",r)};\n                        ${e.isDecal?`\n                            ${v({uniformName:"shadowMatrix",uniformType:"m4v",size:r})} \n                            ${v({uniformName:"shadowCameraPosition",uniformType:"fv4",size:r})} \n                            ${v({uniformName:"lowPartShadowCameraPosition",uniformType:"fv4",size:r})} \n                            `:x({varyingName:"vShadowCoord",varyingType:"fv4",size:r})}\n                    `,e.shadowMapType!==n.ESMShadowMap&&e.shadowMapType!==n.ESMImprovedShadowMap||(t=`\n                            ${t}\n                            ${h("esmLinearSampling","f",[d("iShadowMap"),$("coord"),$("iShadowMapSize"),$("invSize")])}{\n                                ${e.uintESM?`\n                                    ${C("fractCoord")}  = fract(coord*iShadowMapSize + 0.5);\n                                    ${C("centroidUV")}  = (coord*iShadowMapSize - fractCoord) * invSize;\n                                    ${D("lb")}  = ${F(`${s.sample2DTexture("iShadowMap","centroidUV")}`)};\n                                    ${D("lt")}  = ${F(`${s.sample2DTexture("iShadowMap",`centroidUV + ${C()}(0.0, invSize.y)`)}`)};\n                                    ${D("rb")}  = ${F(`${s.sample2DTexture("iShadowMap",`centroidUV + ${C()}(invSize.x, 0.0)`)}`)};\n                                    ${D("rt")}  = ${F(`${s.sample2DTexture("iShadowMap","centroidUV + invSize")}`)};\n                                    ${D("a")}  = mix(lb, lt, fractCoord.y);\n                                    ${D("b")}  = mix(rb, rt, fractCoord.y);\n                                    return mix(a, b, fractCoord.x);\n                                    `:`\n                                    return ${s.sample2DTexture("iShadowMap","coord")}.x;\n                                    `}\n                            }\n\n                            ${h("compESM","f",[d("iShadowMap"),$("coord"),u("depthFrag"),$("iShadowMapSize"),$("shadowPixelSize")])}{\n                                ${D("result")}  = ${I("iShadowMap","coord","iShadowMapSize","shadowPixelSize")} * exp(-80.0 * depthFrag);\n                                return result * result;\n                            }\n\n                            ${h("texture2DESMToPCFCompare","f",[d("iShadowMap"),$("coord"),u("depthFrag"),$("iShadowMapSize"),$("shadowPixelSize")])}{\n                                ${D("depthShadowMap")}  = log(${I("iShadowMap","coord","iShadowMapSize","shadowPixelSize")}) / 80.0;\n                                return step(depthShadowMap, depthFrag);\n                            }\n\n                            ${h("texture2DShadowESMLerp","f",[d("iShadowMap"),$("iShadowMapSize"),$("shadowPixelSize"),$("coord"),u("depthFrag")])}{ \n                                ${C("fractCoord")}  = fract(coord * iShadowMapSize + 0.5);\n                                ${C("centroidUV")}  = (coord * iShadowMapSize - fractCoord) * shadowPixelSize;\n                                ${D("lb")}  = clamp(${A("iShadowMap","centroidUV","depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${D("lt")}  = clamp(${A("iShadowMap",`centroidUV + ${C()}(0.0, shadowPixelSize.y)`,"depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${D("rb")}  = clamp(${A("iShadowMap",`centroidUV + ${C()}(shadowPixelSize.x, 0.0)`,"depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${D("rt")}  = clamp(${A("iShadowMap","centroidUV + shadowPixelSize","depthFrag","iShadowMapSize","shadowPixelSize")}, 0.0, 1.0);\n                                ${D("a")}  = mix(lb, lt, fractCoord.y);\n                                ${D("b")}  = mix(rb, rt, fractCoord.y);\n                                return 1.0 - mix(a, b, fractCoord.x);\n                            }\n                        `),t=`\n                        ${t}\n                        ${h("texture2DCompare","f",[d("iShadowMap"),$("coord"),u("depthFrag")])}{\n                            ${D("depthShadowMap")}  = ${g("unpackRGBA","f",[p(`${s.sample2DTexture("iShadowMap","coord")}`)])};\n                            return step(depthShadowMap, depthFrag);\n                        }\n                        ${h("texture2DShadowLerp","f",[d("iShadowMap"),$("iShadowMapSize"),$("shadowPixelSize"),$("coord"),u("depthFrag")])}{\n                            ${C("fractCoord")} = fract(coord * iShadowMapSize + 0.5);\n                            ${C("centroidUV")} = (coord * iShadowMapSize - fractCoord) * shadowPixelSize;\n                            ${D("lb")} = ${V("iShadowMap","centroidUV","depthFrag")};\n                            ${D("lt")} = ${V("iShadowMap",`centroidUV + ${C()}(0.0, shadowPixelSize.y)`,"depthFrag")};\n                            ${D("rb")} = ${V("iShadowMap",`centroidUV + ${C()}(shadowPixelSize.x, 0.0)`,"depthFrag")};\n                            ${D("rt")} = ${V("iShadowMap","centroidUV + shadowPixelSize","depthFrag")};\n                            ${D("a")} = mix(lb, lt, fractCoord.y);\n                            ${D("b")} = mix(rb, rt, fractCoord.y);\n                            return mix(a, b, fractCoord.x);\n                        }\n                        ${h("getExposureForShadowType","f",[d("iShadowMap"),c("shadowCoord"),$("iShadowMapSize")])}{\n                            ${function(e){function t(n,e){return`\n            for  (${T("i")} = 0; i < ${n}; i ++) {\n                for  (${T("j")} = 0; j < ${e}; j ++) {\n                    shadow += uw[i] * vw[j] *  ${R("iShadowMap","iShadowMapSize","pixelOffset",`base_uv + ${C()}(u[i],v[j])`,"shadowCoord.z")};\n                }\n            }\n            `}function r(n,e){for(var t=o,r=0;r<n;r++)for(var a=0;a<e;a++)t=`\n                        ${t}\n                        shadow += uw${r} * vw${a} *  ${L("iShadowMap","iShadowMapSize","pixelOffset",`base_uv + ${C()}(u${r},v${a})`,"depthFragOffset")};\n                    `;return t}switch(e.shadowMapType){case n.PCFShadowMap:return`\n                ${D("shadow")}  = 0.0;\n                ${e.shadowMapQuality===n.MediumQuality?`\n                    ${z("shadowDelta")}  = 1.0 / 25.0;\n                    ${U("fetchCount")}  = 5;\n                    `:o}\n                ${e.shadowMapQuality===n.HighQuality?`\n                    ${z("shadowDelta")}  = 1.0 / 49.0;\n                    ${U("fetchCount")}  = 7;\n                    `:o}\n                ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                    ${z("shadowDelta")}  = 1.0 / 9.0;\n                    ${U("fetchCount")}  = 3;\n                    `:o}\n                ${D("xPixelOffset")}  = 1.0 / iShadowMapSize.x;\n                ${D("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${D("dx0")}  = -1.25 * ${D()}((fetchCount-1)/2) *xPixelOffset;\n                ${D("dy0")}  = -1.25 * ${D()}((fetchCount-1)/2) *yPixelOffset;\n                ${D("dx1")}  = 1.25 * xPixelOffset;\n                ${D("dy1")}  = 1.25 * yPixelOffset;\n\n                ${D("fDepth")} ;\n                ${C("delta")}  = ${C()}(dx0,dy0);\n                for  (${T("i")} = 0; i < fetchCount; i ++) {\n                    for  (${T("j")} = 0; j < fetchCount; j ++) {\n                        shadow += shadowDelta * ${V("iShadowMap","shadowCoord.xy + delta","shadowCoord.z")};\n                        delta.y +=dy1;\n                    }\n                    delta.y =dy0;\n                    delta.x +=dx1;\n                }\n                return shadow;\n                `;case n.PCFSoftShadowMap:return`\n                ${D("shadow")} = 0.0;\n                ${D("xPixelOffset")}  = 1.0 / iShadowMapSize.x;\n                ${D("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${D("dx0")}  = -1.0 * xPixelOffset;\n                ${D("dy0")}  = -1.0 * yPixelOffset;\n                ${D("dx1")}  = 1.0 * xPixelOffset;\n                ${D("dy1")}  = 1.0 * yPixelOffset;\n\n                ${w("shadowKernel")} ;\n                ${C("delta")}  = ${C()}(dx0,dy0);\n                for  (${T("i")} = 0; i < 3; i ++) {\n                    for  (${T("j")} = 0; j < 3; j ++) {\n                        shadowKernel[i][j]= 0.25 * ${V("iShadowMap","shadowCoord.xy + delta","shadowCoord.z")};\n                        delta.y +=dy1;\n                    }\n                    delta.y =dy0;\n                    delta.x +=dx1;\n                }\n                ${C("fractionalCoord")} = 1.0 - fract( shadowCoord.xy * iShadowMapSize.xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                ${M("shadowValues")} ;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n                return shadow;\n                `;case n.PCFInterpolShadowMap:return`\n                ${D("shadow")}  = 0.0;\n                ${z("dimFilter")}  = 4.0;\n                ${z("sizeFilter")}  = dimFilter * dimFilter;\n                ${z("shadowDelta")}  = 1.0 / sizeFilter;\n                ${C("shadowPixelSize")}  = 1.0 / iShadowMapSize;\n                for (${D("xFilter")}  = -0.5 * dimFilter + 0.5; xFilter <= 0.5 * dimFilter; xFilter += 1.0) {\n                    for (${D("yFilter")}  = -0.5 * dimFilter + 0.5; yFilter <= 0.5 * dimFilter; yFilter += 1.0) {\n                        shadow += ${R("iShadowMap","iShadowMapSize","shadowPixelSize",`shadowCoord.xy + shadowPixelSize * ${C()}(xFilter, yFilter)`,"shadowCoord.z")};\n                    }\n                }\n                shadow *= shadowDelta;\n                return shadow;\n                `;case n.PCFPoissonShadowMap:return`\n                ${D("shadow")}  = 0.0;\n                ${D("xPixelOffset")}  = 1.0/ iShadowMapSize.x;\n                ${D("yPixelOffset")}  = 1.0 / iShadowMapSize.y;\n                ${D("randAngle")}  = ${g("randomValue","f",[c("shadowCoord.xyz"),u("fract(shadowCoord.x*shadowCoord.y)")])}* 2.0 * 3.14159265359;\n                for  (${T("i")} = 0; i < poissonCount; i ++) {\n                    ${C("p")}  = ${S("poissonDisk")}[i];\n                    ${D("posX")}  = (cos(randAngle)*p.x-sin(randAngle)*p.y)*xPixelOffset;\n                    ${D("posY")}  = (sin(randAngle)*p.x+cos(randAngle)*p.y)*yPixelOffset;\n                    shadow += ${V("iShadowMap",`shadowCoord.xy + ${C()}(posX,posY)`,"shadowCoord.z")};\n                }\n                shadow *= poissonInvSamples;\n                return shadow;\n                `;case n.PCFOptimizedShadowMap:return`\n                ${D("shadow")}  = 0.0;\n                ${C("fractCoord")}  = fract(shadowCoord.xy * iShadowMapSize + 0.5);\n                ${C("pixelOffset")}  = 1.0 / iShadowMapSize;\n                ${C("base_uv")}  = (shadowCoord.xy * iShadowMapSize - fractCoord) * pixelOffset;\n                ${e.shadowMapQuality===n.MediumQuality?`\n                    ${D("uw",3)};\n                    uw[0]  = (4.0 - 3.0 * fractCoord.x);\n                    uw[1]  = 7.0;\n                    uw[2]  = (1.0 + 3.0 * fractCoord.x);\n\n                    ${D("u",3)};\n                    u[0] = ((3.0 - 2.0 * fractCoord.x) / uw[0] - 2.0) * pixelOffset.x;\n                    u[1] = ((3.0 + fractCoord.x) / uw[1]) * pixelOffset.x;\n                    u[2] = (fractCoord.x / uw[2] + 2.0) * pixelOffset.x;\n\n                    ${D("vw",3)};\n                    vw[0] = (4.0 - 3.0 * fractCoord.y);\n                    vw[1] = 7.0;\n                    vw[2] = (1.0 + 3.0 * fractCoord.y);\n\n                    ${D("v",3)};\n                    v[0] = ((3.0 - 2.0 * fractCoord.y) / vw[0] - 2.0) * pixelOffset.y;\n                    v[1] = ((3.0 + fractCoord.y) / vw[1]) * pixelOffset.y;\n                    v[2] = (fractCoord.y / vw[2] + 2.0) * pixelOffset.y;\n\n                    ${t(3,3)}\n\n                    shadow *= 0.0069444;\n                    `:o}\n                ${e.shadowMapQuality===n.HighQuality?`\n                    ${D("uw",4)};\n                    uw[0]  = (5.0 * fractCoord.x - 6.0);\n                    uw[1]  = (11.0 * fractCoord.x - 28.0);\n                    uw[2]  = -(11.0 * fractCoord.x + 17.0);\n                    uw[3]  = -(5.0 * fractCoord.x + 1.0);\n\n                    ${D("u",4)};\n                    u[0] = ((4.0 * fractCoord.x - 5.0) / uw[0] - 3.0) * pixelOffset.x;\n                    u[1] = ((4.0 * fractCoord.x - 16.0) / uw[1] - 1.0) * pixelOffset.x;\n                    u[2] = (-(7.0 * fractCoord.x + 5.0) / uw[2] + 1.0) * pixelOffset.x;\n                    u[3] = (-fractCoord.x / uw[3] + 3.0) * pixelOffset.x;\n\n                    ${D("vw",4)};\n                    vw[0] = (5.0 *fractCoord.y - 6.0);\n                    vw[1] = (11.0 *fractCoord.y - 28.0);\n                    vw[2] = -(11.0 *fractCoord.y + 17.0);\n                    vw[3] = -(5.0 *fractCoord.y + 1.0);\n\n                    ${D("v",4)};\n                    v[0] = ((4.0 *fractCoord.y - 5.0) / vw[0] - 3.0) * pixelOffset.y;\n                    v[1] = ((4.0 *fractCoord.y - 16.0) / vw[1] - 1.0) * pixelOffset.y;\n                    v[2] = (-(7.0 *fractCoord.y + 5.0) / vw[2] + 1.0) * pixelOffset.y;\n                    v[3] = (-fractCoord.y / vw[3] + 3.0) * pixelOffset.y;\n\n                    ${t(4,4)}\n\n                    shadow *= 0.0003698225;\n                    `:o}\n                ${e.shadowMapQuality!==n.HighQuality&&e.shadowMapQuality!==n.MediumQuality?`\n                    ${D("uw",2)};\n                    uw[0]  = (3.0 - 2.0 * fractCoord.x);\n                    uw[1]  = (1.0 + 2.0 * fractCoord.x);\n\n                    ${D("u",2)};\n                    u[0] = ((2.0 - fractCoord.x) / uw[0] - 1.0) * pixelOffset.x;\n                    u[1] = (fractCoord.x / uw[1] + 1.0) * pixelOffset.x;\n\n                    ${D("vw",2)};\n                    vw[0] = (3.0 - 2.0 * fractCoord.y);\n                    vw[1] = (1.0 + 2.0 * fractCoord.y);\n\n                    ${D("v",2)};\n                    v[0] = ((2.0 - fractCoord.y) / vw[0] - 1.0) * pixelOffset.y;\n                    v[1] = (fractCoord.y / vw[1] + 1.0) * pixelOffset.y;\n\n                    ${t(2,2)}\n\n                    shadow *= 0.0625;\n                    `:o}\n                return shadow;\n                `;case n.ESMShadowMap:return`\n                ${D("shadow")}  = 0.0;\n                ${D("depthFragOffset")}  = shadowCoord.z;\n                ${C("pixelOffset")}  = 1.0 / iShadowMapSize.xy;\n\n                shadow = ${A("iShadowMap","shadowCoord.xy","depthFragOffset","iShadowMapSize","pixelOffset")};\n\n                ${function(){for(var n=`\n                        ${D("zMaxNeighbor")} = 0.0;\n                        ${C("coordDetect")};\n                    `,e=-1;e<=1;e++)for(var t=-1;t<=1;t++)if(0!==e||e!==t){var r=-1===e?"-pixelOffset.x":0===e?"0.0":"pixelOffset.x",a=-1===t?"-pixelOffset.y":0===t?"0.0":"pixelOffset.y";n=`\n                                ${n}\n                                coordDetect = shadowCoord.xy + ${C()}(${r}, ${a});\n                                zMaxNeighbor = max(zMaxNeighbor, ${I("iShadowMap","coordDetect","iShadowMapSize","pixelOffset")});\n                            `}return`\n                        ${n}\n                        zMaxNeighbor = log(zMaxNeighbor) * 0.0125;\n                    `}()}\n\n                if(zMaxNeighbor < 0.9999999 && (shadowCoord.z + 0.015) < zMaxNeighbor) {\n                    shadow = 0.0;\n\n                    ${C("fractCoord")}  = fract(shadowCoord.xy * iShadowMapSize + 0.5);\n                    ${C("base_uv")}  = (shadowCoord.xy * iShadowMapSize - fractCoord) * pixelOffset;\n\n                    ${D("uw0")}  = (4.0 - 3.0 * fractCoord.x);\n                    ${D("uw1")}  = 7.0;\n                    ${D("uw2")}  = (1.0 + 3.0 * fractCoord.x);\n\n                    ${D("u0")}  = ((3.0 - 2.0 * fractCoord.x) / uw0 - 2.0) * pixelOffset.x;\n                    ${D("u1")}  = ((3.0 + fractCoord.x) / uw1) * pixelOffset.x;\n                    ${D("u2")}  = (fractCoord.x / uw2 + 2.0) * pixelOffset.x;\n\n                    ${D("vw0")}  = (4.0 - 3.0 * fractCoord.y);\n                    ${D("vw1")}  = 7.0;\n                    ${D("vw2")}  = (1.0 + 3.0 * fractCoord.y);\n\n                    ${D("v0")}  = ((3.0 - 2.0 * fractCoord.y) / vw0 - 2.0) * pixelOffset.y;\n                    ${D("v1")}  = ((3.0 + fractCoord.y) / vw1) * pixelOffset.y;\n                    ${D("v2")}  = (fractCoord.y / vw2 + 2.0) * pixelOffset.y;\n\n                    ${r(3,3)}\n\n                    shadow *= 0.0069444;\n\n\n                    shadow = clamp(shadow * 2.0, 0.0, 1.0);\n\n                } else {\n\n                    shadow *= shadow * shadow;\n                    shadow = 1.0 - clamp(shadow, 0.0, 1.0);\n                }\n                return shadow;\n                `;case n.ESMImprovedShadowMap:return`\n                        ${D("shadow")}  = 0.0;\n                        ${D("depthFragOffset")}  = shadowCoord.z;\n\n                        ${C("uv")}  = shadowCoord.xy * iShadowMapSize;\n                        ${C("pixelOffset")}  = 1.0 / iShadowMapSize.xy;\n                        ${C("base_uv")}  = floor(uv + 0.5);\n                        ${C("fractCoord")}  = uv + 0.5 - base_uv;\n\n                        base_uv = (base_uv - 0.5) * pixelOffset;\n\n                        ${D("uw0")}  = (3.0 - 2.0 * fractCoord.x);\n                        ${D("uw1")}  = (1.0 + 2.0 * fractCoord.x);\n\n                        ${D("u0")}  = ((2.0 - fractCoord.x) / uw0 - 1.0) * pixelOffset.x;\n                        ${D("u1")}  = (fractCoord.x / uw1 + 1.0 ) * pixelOffset.x;\n\n                        ${D("vw0")}  = (3.0 - 2.0 * fractCoord.y);\n                        ${D("vw1")}  = (1.0 + 2.0 * fractCoord.y);\n\n                        ${D("v0")}  = ((2.0 - fractCoord.y) / vw0 - 1.0) * pixelOffset.y;\n                        ${D("v1")}  = (fractCoord.y / vw1 + 1.0) * pixelOffset.y;\n                 \n                        ${r(2,2)}\n\n                        shadow *= 0.0625;\n\n                        shadow = clamp(shadow * 1.5, 0.0, 1.0);\n                        \n                        return shadow;\n                \n                `;default:return`return ${V("iShadowMap","shadowCoord.xy","shadowCoord.z")};`}}(e)}\n                        }\n\n                        ${h("getExposure","f",[p("iShadowCoord"),d("iShadowMap"),u("iShadowBias"),$("iShadowMapSize")])}{\n                            ${N("shadowCoord")}  = iShadowCoord.xyz / iShadowCoord.w;\n                            ${b("inFrustumVec")}  = ${b()} ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n                            ${_("inFrustum")}  = all( inFrustumVec );\n                            \n                            ${D("exposureResult")}  = 0.0;\n                            ${P("frustumTestVec")}  = ${P()}( inFrustum, shadowCoord.z <= 1.0 );\n                            ${_("frustumTest")}  = all( frustumTestVec );\n\n                            if ( frustumTest ) {\n                                shadowCoord.z += iShadowBias;              \n                                exposureResult = ${g("getExposureForShadowType","f",[d("iShadowMap"),c("shadowCoord"),$("iShadowMapSize")])};\n                            }                \n                            return max(1.0-exposureResult,0.0);\n                        }\n                \n                        ${k(e,!1)}\n\n                        ${e.shadowMapCascade?`\n                            ${h("getExposureCascaded","f",[(n=>i.parameterInOutV4(n))("transparentExposure")])}{\n                                ${D("exposure")}  = 1.0;\n                                ${T("inFrustumCount")}  = 0;\n                                ${e.shadowMapDebug?`\n                                    ${N("frustumColors",3)};\n                                    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n                                    frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n                                    frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n                                    `:o}                       \n                                ${function(n){for(var e=`\n            ${N("shadowCoord")} ;\n            ${b("inFrustumVec")} ;\n            ${_("inFrustum")} ;\n            ${P("inFrustumAndZVec")} ;\n            ${_("inFrustumAndZ")} ;\n            ${P("frustumTestVec")} ;\n            ${_("frustumTest")} ;\n        `,t=0;t<n.maxDirShadows;t++)e=`\n                ${e}\n                shadowCoord = gShadowCoord[${t}].xyz / gShadowCoord[${t}].w;\n                inFrustumVec = ${b()} ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n                inFrustum = all( inFrustumVec );\n                inFrustumAndZVec = ${P()}(inFrustum, shadowCoord.z <= 1.0);\n                inFrustumAndZ = all(inFrustumAndZVec);\n                inFrustumCount += ${T()}( inFrustumAndZ );\n                frustumTestVec = ${P()}( inFrustumAndZ, inFrustumCount == 1 );\n                frustumTest = all( frustumTestVec );\n                if ( frustumTest ) {\n                    exposure = ${g("getExposure","f",[p(`gShadowCoord[${t}]`),d(`shadowMap[${t}]`),u(`${S("shadowBias")}[${t}]`),$(`${S("shadowMapSize")}[${t}]`)])};\n            `,n.transparentShadowEnabled&&(e=`\n                    ${e}\n                    ${N("shadowCoord")}  = gShadowCoord[${t}].xyz / gShadowCoord[${t}].w;\n                    ${D("isNotbehindFrustum")}  = step(0.0,gShadowCoord[${t}].w);\n                    ${l()}transparentExposure = isNotbehindFrustum * ${s.sample2DTexture(`transparentShadowMap[${t}]`,"shadowCoord.xy")} + (1.0-isNotbehindFrustum) * ${M()}(1.0);\n                `),n.shadowMapDebug&&(e=`\n                    ${e}\n                    if ( frustumTest ) {\n                        gl_FragColor.x *= frustumColors[ ${t} ].x;\n                        gl_FragColor.y *= frustumColors[ ${t} ].y;\n                        gl_FragColor.z *= frustumColors[ ${t} ].z;\n                    }\n                `),e=`\n                ${e}\n                }\n            `;return e}(e)}                       \n                                return exposure;                           \n                            }\n                            `:o}\n                    `}if(e.shadowMapCubeEnabled){var a=e.maxShadowsCube;t=`\n                        ${t}\n\n                        ${v({uniformName:"shadowMapCube",uniformType:"tcv",size:a})} \n                        ${e.transparentShadowEnabled?`\n                            ${v({uniformName:"transparentShadowMapCube",uniformType:"tcv",size:a})} \n                            ${e.maxPointLights>0?v({uniformName:"pointLightColorNoIntensity",uniformType:"fv4",size:e.maxPointLights}):o}\n                            `:o}\n                        ${v({uniformName:"shadowDarknessCube",uniformType:"fv1",size:a})} \n                        ${v({uniformName:"shadowBiasCube",uniformType:"fv1",size:a})} \n                        ${v({uniformName:"shadowNearCube",uniformType:"fv1",size:a})} \n                        ${v({uniformName:"shadowFarCube",uniformType:"fv1",size:a})} \n                        ${v({uniformName:"shadowPointPosition",uniformType:"fv4",size:a})} \n                        \n                        ${h("textureCubeCompare","f",[f("iShadowMap"),c("coord"),u("depthFrag")])}{\n                            ${M("fetchedValue")} = ${s.sampleCubeTexture("iShadowMap","coord")};\n                            ${D("depthShadowMap")}  = ${g("unpackRGBA","f",[p("fetchedValue")])};\n                            return step(depthShadowMap, depthFrag);\n                        }\n                        \n                        ${e.shadowMapType===n.ESMShadowMap||e.shadowMapType===n.ESMImprovedShadowMap?`\n                            ${h("esmLinearSamplingCube","f",[f("iShadowMap"),c("coord"),u("iShadowMapSize")])}{\n                                ${e.uintESM?`\n                                    ${N("absCoord")}  = abs(coord);\n                                \t${D("mainComp")}  = max(max(absCoord.x,absCoord.y),absCoord.z);\n                                \t${N("mainDir")}  = step(${N()}(mainComp),absCoord);\n                                \tif(dot(mainDir,${N()}(1.0))>1.0){\n                                        ${M("fetchedValue")} = ${s.sampleCubeTexture("iShadowMap","coord")};\n                                \t\treturn ${F("fetchedValue")};\n                                \t}else{                    \n                                \t\t${D("smSize")} =iShadowMapSize; \n                                \t\t${C("uv")} ;\n                                \t\t${N("uv3")} ;\n                                \t\t${D("lengthRatio")} ;\n                                \t\tif(mainDir.x == 1.0){\n                                \t\t\tuv = coord.yz;\n                                \t\t\tlengthRatio = abs(coord.x);\n                                \t\t}else if(mainDir.y == 1.0){\n                                \t\t\tuv = coord.xz;\n                                \t\t\tlengthRatio = abs(coord.y);\n                                \t\t}else{\n                                \t\t\tuv = coord.xy;\n                                \t\t\tlengthRatio = abs(coord.z);\n                                \t\t}\n\n                                \t\tuv/=lengthRatio;\n                                \t\tuv = (uv+${C()}(1.0)) * 0.5;\n\n                                \t\t${C("invSize")}  = ${C()}(1.0/smSize);\n\n                                        ${C("fractCoord")}  = fract(uv*smSize + ${C()}(0.5));\n                                        ${C("centroidUV")} = (uv*smSize - fractCoord) * invSize;\n                                \t\t${C("ltUv")}  =centroidUV + ${C()}(0.0, invSize.y);\n                                \t\t${C("rbUv")}  =centroidUV + ${C()}(invSize.x, 0.0);\n                                \t\t${C("rtUv")}  =centroidUV + invSize;\n\n                                \t\tcentroidUV = (centroidUV*2.0)-1.0;\n                                \t\tltUv = (ltUv*2.0)-1.0;\n                                \t\trbUv = (rbUv*2.0)-1.0;\n                                \t\trtUv = (rtUv*2.0)-1.0;\n\n                                \t\tcentroidUV *= lengthRatio;\n                                \t\tltUv *= lengthRatio;\n                                \t\trbUv *= lengthRatio;\n                                \t\trtUv *= lengthRatio;\n\n                                        ${N("centroidCoord")} ;\n                                \t\t${N("ltCoord")} ;\n                                \t\t${N("rbCoord")} ;\n                                \t\t${N("rtCoord")} ;\n                                \t\tif(mainDir.x == 1.0){\n                                   \t\t    centroidCoord = normalize( ${N()}(coord.x,centroidUV));\n                                \t\t\tltCoord = normalize(${N()}(coord.x,ltUv));\n                                \t\t\trbCoord = normalize(${N()}(coord.x,rbUv));\n                                \t\t\trtCoord = normalize(${N()}(coord.x,rtUv));\n                                \t\t}else if(mainDir.y == 1.0){\n                                   \t\t    centroidCoord = normalize(${N()}(centroidUV.x,coord.y,centroidUV.y));\n                                \t\t\tltCoord = normalize(${N()}(ltUv.x,coord.y,ltUv.y));\n                                \t\t\trbCoord = normalize(${N()}(rbUv.x,coord.y,rbUv.y));\n                                \t\t\trtCoord = normalize(${N()}(rtUv.x,coord.y,rtUv.y));\n                                \t\t}else{\n                                   \t\t    centroidCoord = normalize(${N()}(centroidUV,coord.z));\n                                \t\t\tltCoord = normalize(${N()}(ltUv,coord.z));\n                                \t\t\trbCoord = normalize(${N()}(rbUv,coord.z));\n                                \t\t\trtCoord = normalize(${N()}(rtUv,coord.z));\n                                \t\t}\n                    \n                                   \t${D("lb")} = ${F(`${s.sampleCubeTexture("iShadowMap","centroidCoord")}`)};\n                                   \t${D("lt")} = ${F(`${s.sampleCubeTexture("iShadowMap","ltCoord")}`)};\n                                   \t${D("rb")} = ${F(`${s.sampleCubeTexture("iShadowMap","rbCoord")}`)};\n                                   \t${D("rt")} = ${F(`${s.sampleCubeTexture("iShadowMap","rtCoord")}`)};\n                                   \t${D("a")} = mix(lb, rb, fractCoord.x);\n                                   \t${D("b")} = mix(lt, rt, fractCoord.x);\n                                   \treturn mix(a, b, fractCoord.y);\n                                   }\n                                    `:`return ${s.sampleCubeTexture("iShadowMap","coord")}.x;`}\n                            }\n                        \n                            ${h("compESMCube","f",[f("iShadowMap"),c("coord"),u("depthFrag"),u("iShadowMapSize")])}{\n                                ${D("result")}  = ${g("esmLinearSamplingCube","f",[f("iShadowMap"),c("coord"),u("iShadowMapSize")])} * exp(-80.0 * depthFrag);\n                                result = 1.0 - clamp(result * result * result * result,0.0,1.0);\n                                return result;\n                            }\n                            `:o}\n\n                        ${e.shadowMapType===n.PCFOptimizedShadowMap||e.shadowMapType===n.PCFPoissonShadowMap||e.shadowMapType===n.PCFShadowMap?`\n                            ${h("getExposureCubePCF","f",[c("normPointVector"),u("iShadowMapSize"),f("iShadowMap"),u("depth")])}{\n                                ${N("rndseed")}  = ${N()}(12.9898,78.233,45.5432);\n                                ${N("randomDir")}  = ${N()}( dot(normPointVector,rndseed) , dot(normPointVector.yzx,rndseed) , dot(normPointVector.zxy,rndseed) );\n                                randomDir = fract(sin(randomDir) * 43758.5453);\n                                \n                                ${D("pixelSize")}  = 2.0 / iShadowMapSize;\n                                \n                                ${N("xvec")}  = normalize(cross(normPointVector,randomDir))* pixelSize *1.1;\n                                ${N("yvec")}  = normalize(cross(normPointVector,xvec))* pixelSize *1.1;\n\n                                ${D("divider")}  = 8.0;\n                                \n                                ${D("inShadow")}  = 0.0;\n                                inShadow += ${B("iShadowMap","normPointVector+xvec+yvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector+xvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector+xvec-yvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector+yvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector-yvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector-xvec+yvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector-xvec","depth")};\n                                inShadow += ${B("iShadowMap","normPointVector-xvec-yvec","depth")};\n                                \n                                ${e.shadowMapQuality===n.HighQuality||e.shadowMapQuality===n.MediumQuality?`\n                                    divider = 20.0;\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*xvec+yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*xvec-yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*xvec+yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*xvec-yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*yvec+xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*yvec-xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*yvec+xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*yvec-xvec","depth")};\n                                    `:o}\n\n                                ${e.shadowMapQuality===n.HighQuality?`\n                                    divider = 36.0;\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*xvec+yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*xvec-yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*xvec+yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*xvec-yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*yvec+xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+3.0*yvec-xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*yvec+xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-3.0*yvec-xvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*xvec+2.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector+2.0*xvec-2.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*xvec-2.0*yvec","depth")};\n                                    inShadow += ${B("iShadowMap","normPointVector-2.0*xvec+2.0*yvec","depth")};\n                                    `:o}\n                                \n                                return inShadow / divider;\n                            }\n                            `:o}\n\n                        ${e.isDecal?`${M("decalShadowCubeWorldPosition")} ;`:o}\n                        \n                        ${h("getExposure","f",[c("pointPosition"),c("worldPosition"),f("iShadowMap"),u("iShadowBias"),u("iShadowMapSize"),u("shadowNear"),u("shadowFar")])}{\n                            ${M("lPosition")}  =  ${M()}( pointPosition, 1.0 );\n                            \n                            ${N("pointVector")};\n                            ${e.isDecal?"pointVector = decalShadowCubeWorldPosition.xyz-lPosition.xyz;":"pointVector = worldPosition.xyz-lPosition.xyz;"}\n                            \n                            ${D("exposureResult")}  = 0.0;\n                            \n                            ${N("absVector")}  = abs(pointVector);\n                            ${D("localZComp")}  = max(absVector.x,max(absVector.y,absVector.z));\n                            ${D("normZComp")}  = (shadowFar+shadowNear)/(shadowFar-shadowNear)-(2.0*shadowFar*shadowNear)/(shadowFar-shadowNear)/localZComp;\n                            normZComp = (normZComp + 1.0) * 0.5;\n                            \n                            ${D("depthCube")}  = normZComp +iShadowBias;\n                            \n                            ${N("normPointVector")}  = normalize( pointVector );\n                            \n                            ${e.shadowMapType===n.PCFOptimizedShadowMap||e.shadowMapType===n.PCFPoissonShadowMap||e.shadowMapType===n.PCFShadowMap?`exposureResult = ${g("getExposureCubePCF","f",[c("normPointVector"),u("iShadowMapSize"),f("iShadowMap"),u("depthCube")])};`:`\n                                ${e.shadowMapType===n.ESMShadowMap?`exposureResult = ${g("compESMCube","f",[f("iShadowMap"),c("normPointVector"),u("depthCube"),u("iShadowMapSize")])};`:`exposureResult = ${B("iShadowMap","normPointVector","depthCube")};`}\n                                `}\n                            \n                            return 1.0-exposureResult;\n                        }\n                        ${k(e,!0)}\t\t\n                    `}}return t},shadowmap_fragment_old:function(n){var e=`\n            ${D("shadowExposure")}  = 1.0;\n            ${M("transparentExposure")}  = ${M()}(1.0);\n            `;if(n.shadowMapEnabled||n.shadowMapCubeEnabled){if(n.shadowMapEnabled){var t=function(){return`\n                        currentExposure = ${g("getExposureFromIndex","f",[m("i")])};\n                        ${n.transparentShadowEnabled?`currentTransparentExposure = ${g("getTransparentExposureFromIndex","v4",[m("i")])};`:o}\n                        if (currentExposure < 1.0) {\n                            shadowExposure *=1.0 - (${S("shadowDarkness")}[ i ] * (1.0-currentExposure));\n                        }\n                        transparentExposure *= ${M()}(1.0) - (${S("shadowDarkness")}[ i ] * (${M()}(1.0)-currentTransparentExposure));\n                        `};e=`\n                        ${e}\n                        for( ${T("i")} = 0; i < ${n.maxShadows}; i ++ ) {\n                            gShadowCoord[ i ] = ${y("vShadowCoord")}[i];\n                        }\n                        ${D("currentExposure")}  = 1.0;\n                        ${M("currentTransparentExposure")}  = ${M()}(1.0);\n                        ${n.shadowMapCascade?`\n                            currentExposure  = ${g("getExposureCascaded","f",[(n=>i.parameterRefV4(n))("currentTransparentExposure")])};\n                            `:`\n                            currentExposure = ${g("getExposure","f",[p("gShadowCoord[0]"),d("shadowMap[0]"),u(`${S("shadowBias")}[0]`),$(`${S("shadowMapSize")}[0]`)])};\n                            ${n.transparentShadowEnabled?`currentTransparentExposure = ${g("getTransparentExposureFromIndex","v4",[m("0")])};`:o}\n                            `}\n                        if (currentExposure < 1.0) {\n                            shadowExposure *=1.0 - (${S("shadowDarkness")}[ 0 ] * (1.0-currentExposure));\n                        }\n                        transparentExposure *= ${M()}(1.0) - (${S("shadowDarkness")}[ 0 ] * (${M()}(1.0)-currentTransparentExposure));\n                        ${n.shadowMapCascade?`\n                            ${n.maxShadows>n.maxDirShadows?`\n                                for( ${T("i")} = ${n.maxDirShadows}; i < ${n.maxShadows}; i ++ ) {\n                                    ${t()}\n                                }\n                                `:o}\n                            `:`\n                            ${n.maxShadows>1?`\n                                for( ${T("i")} = 1; i < ${n.maxShadows}; i ++ ) {\n                                    ${t()}\n                                }\n                                `:o} \n                            `}\n                    `}n.shadowMapCubeEnabled&&(e=`\n                        ${e}\n                        for ( ${T("i")} = 0; i < ${n.maxShadowsCube}; i ++ ) {\n                            ${D("currentExposure")}  = ${g("getExposureFromIndexCube","f",[m("i"),c(y("vWorldPosition"))])};\n                            ${M("currentTransparentExposure")}  = ${M()}(1.0);\n                            ${n.transparentShadowEnabled?`currentTransparentExposure = ${g("getTransparentExposureFromIndexCube","v4",[m("i"),c(y("vWorldPosition"))])};`:o}\n                            if (currentExposure < 1.0) {\n                                shadowExposure *= 1.0 - (${S("shadowDarknessCube")}[ i ] * (1.0-currentExposure));\n                            }\n                            transparentExposure *=  ${M()}(1.0) - (${S("shadowDarknessCube")}[ i ] * ( ${M()}(1.0)-currentTransparentExposure));\n                        }\n                    `)}return e=`\n            ${e}\n            shadowExposure = min(shadowExposure,transparentExposure.a);\n            gl_FragColor.x *= transparentExposure.r * shadowExposure;\n            gl_FragColor.y *= transparentExposure.g * shadowExposure;\n            gl_FragColor.z *= transparentExposure.b * shadowExposure;\n            `},shadowmap_pars_vertex:function(n){if(!n.shadowMapEnabled||n.isDecal)return o;var e=n.maxShadows;return`\n            ${x({varyingName:"vShadowCoord",varyingType:"fv4",size:e})}\n            ${v({uniformName:"shadowMatrix",uniformType:"m4v",size:e})} \n            ${v({uniformName:"shadowCameraPosition",uniformType:"fv4",size:e})} \n            ${v({uniformName:"lowPartShadowCameraPosition",uniformType:"fv4",size:e})} \n            `},shadowmap_vertex:function(n){return!n.shadowMapEnabled||n.isDecal?o:`\n                for( ${T("i")} = 0; i < ${n.maxShadows}; i ++ ) {\n                    ${(n=>t.getVarying(n,t.ShaderStages.out))("vShadowCoord")}[ i ] = ${g("computeShadowCoord","v4",[c("vertexLocalPosition.xyz"),((n,e,t=!1)=>i.parameter(n,e,t))("m4",`${S("shadowMatrix")}[i]`),c(`${S("shadowCameraPosition")}[i].xyz`),c(`${S("lowPartShadowCameraPosition")}[i].xyz`)])};\n                }\n            `},shadowmap_fragment:function(n){return!n.shadowMapEnabled||n.isDecal?o:`\n                for( ${T("i")} = 0; i < ${n.maxShadows}; i ++ ) {\n                    gShadowCoord[ i ] = ${y("vShadowCoord")}[i];\n                }\n            `}}}),define("DS/ShaderBuilders/Commons/FogShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r){"use strict";const a=e=>n.addObjectUniform(e),o=e=>{var t={uniformName:e};return n.getObjectUniform(t)},i=n=>e.addVarying(n),s=(n=null)=>{var e={name:n};return r.float(e)};return{fog_pars_vertex:function(n){return n.fogViewMode?i({varyingName:"bvmDepth",varyingType:"f"}):""},fog_vertex:function(n){return n.fogViewMode?`${(n=>e.getVarying(n,e.ShaderStages.out))("bvmDepth")} = ${(n=>e.getBuiltin(n,e.ShaderStages.out))("position")}.w;`:""},fog_pars_fragment:function(n){return n.fogViewMode?`\n                ${a({uniformName:"backgroundViewModeControl",uniformType:"v4"})} \n                ${a({uniformName:"backgroundViewModeNearFar",uniformType:"v2"})} \n                ${i({varyingName:"bvmDepth",varyingType:"f"})}\n            `:""},fog_fragment:function(t){return t.fogViewMode?`                \n\t\t\t\tif(${o("backgroundViewModeControl")}.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\t${s("isOrtho")};\n                    if (${a="projectionMatrix",i={uniformName:a},n.getGlobalUniform(i)}[2].w < 0.0 ) {\n                        isOrtho = 0.0;\n                    } else {\n                        isOrtho = 1.0;\n                    } \n\t\t\t\t\t${s("bvm_fog_depth")} = (${(n=>e.getVarying(n,e.ShaderStages.in))("bvmDepth")} - ${o("backgroundViewModeNearFar")}.x) / (${o("backgroundViewModeNearFar")}.y - ${o("backgroundViewModeNearFar")}.x);\n\t\t\t\t\t${s("fog_mix")} = gl_FragCoord.z * gl_FragCoord.w * isOrtho + (1.0 - isOrtho) * bvm_fog_depth;\n\t\t\t\t\tfog_mix = min(max(fog_mix, 0.0), 1.0);\n\t\t\t\t\t${((n=null)=>{var e={name:n};return r.vec3(e)})("finalFogColor")}  = gl_FragColor.xyz * (1.0 - fog_mix) + ${o("backgroundViewModeControl")}.xyz * fog_mix;\n                    gl_FragColor.x = finalFogColor.x;\n                    gl_FragColor.y = finalFogColor.y;\n                    gl_FragColor.z = finalFogColor.z;\n\t\t\t\t}\n            `:"";var a,i},backgroundviewmode_lowlight_fragment:function(n){return n.lowlightViewMode?`              \n\t\t\t\tif(${o("backgroundViewModeControl")}.w > 0.0)\n\t\t\t\t{\n\t\t\t\t\tgl_FragColor.x *= 0.55;\n\t\t\t\t\tgl_FragColor.y *= 0.55;\n\t\t\t\t\tgl_FragColor.z *= 0.55;\n\t\t\t\t}\n            `:""}}}),define("DS/ShaderBuilders/SimpleMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=(n,e,t)=>s.callFunction(n,e,t),u=n=>t.addUniform(n),m=n=>{var e={uniformName:n};return t.getUniform(e)},$=(n=null)=>{var e={name:n};return o.vec2(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)};return new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,p=`\n            #define SIMPLEMAP\n            ${u({uniformName:"tEnvMap",uniformType:"t2"})}\n            ${u({uniformName:"ambient",uniformType:"v3"})}\n            ${u({uniformName:"backgroundColor",uniformType:"v3"})}\n            ${u({uniformName:"backgroundAlpha",uniformType:"f"})}\n            ${u({uniformName:"invSize",uniformType:"v2"})}\n            ${u({uniformName:"offset",uniformType:"v2"})}\n            ${u({uniformName:"envMapExposure",uniformType:"f"})}\n\n            ${t.useHDR&&!t.useHDRFloat?`\n                ${u({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${a.rgbe_sample_methods(t)}\n                `:""}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            void main() {\n                ${$("coord")}  = (gl_FragCoord.xy - ${m("offset")}) * ${m("invSize")};\n                ${c("color")} = ${c()}(0.0);\n\n                ${t.useHDR&&!t.useHDRFloat?`\n                    coord.x = 1.0 - coord.x;\n                    ${$("texelSize")}  = 1.0 / envMapHDRSize;\n                    color = ${l("texture2DFromRGBE","v4",[(n=>i.parameterT2(n))("tEnvMap"),(n=>i.parameterV2(n))("coord")])};\n                    `:`color = ${s.sample2DTexture("tEnvMap","coord")};`}\n\n                ${t.gammaInput&&t.useSRGB?`color.rgb = ${l("convertToLinear","v3",[(n=>i.parameterV3(n))("color.rgb")])};`:""}\n\n                ${$("edge")}  = step(${$()}(0.0), coord) - step(${$()}(1.0), coord);\n                ${((n=null)=>{var e={name:n};return o.float(e)})("mixCoeff")} = edge.x * edge.y;\n                ${c("backgroundValue")} = vec4(${m("backgroundColor")},${m("backgroundAlpha")});\n                ${c("foregroundValue")} = color * vec4(${m("ambient")} * ${m("envMapExposure")}, 1.0);\n                gl_FragColor = foregroundValue * mixCoeff +  backgroundValue * (1.0 - mixCoeff) ;\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            }\n        `;return{vertexShader:`\n            #define SIMPLEMAP\n\n            void main() {\n                ${a.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:p}})}),define("DS/ShaderBuilders/GradientBackgroundShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=n=>i.parameterV3(n),l=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),u=n=>t.addUniform(n),m=n=>{var e={uniformName:n};return t.getUniform(e)},$=(n=null)=>{var e={name:n};return o.float(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},d=n=>r.addVarying(n),f=n=>r.getVarying(n,r.ShaderStages.in),h=n=>r.getVarying(n,r.ShaderStages.out);return{Gradient2Builder:new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            #define GRADIENT_BACKGROUND2\n            \n            ${d({varyingName:"vColor",varyingType:"v3"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            void main() {\n                gl_FragColor = ${p()}(${f("vColor")}, 1.0);\n                ${c("convertedColor")} = ${l("convertToLinear","v3",[s("gl_FragColor.xyz")])};\n                gl_FragColor.x = convertedColor.x;\n                gl_FragColor.y = convertedColor.y;\n                gl_FragColor.z = convertedColor.z;\n\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            }\n        `;return{vertexShader:`\n            #define GRADIENT_BACKGROUND2\n            ${u({uniformName:"colors",uniformType:"fv3",size:2})}\n            ${u({uniformName:"YUp",uniformType:"i"})}\n            ${d({varyingName:"vColor",varyingType:"v3"})}\n\n            void main() {\n                if (${m("YUp")} == 0){\n                    ${h("vColor")} = mix(${m("colors")}[0], ${m("colors")}[1], smoothstep(-1.0, 1.0, position_.z));\n                } else {\n                    ${h("vColor")} = mix(${m("colors")}[0], ${m("colors")}[1], smoothstep(-1.0, 1.0, position_.y));\n                }\n                ${a.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:o}}),Gradient3Builder:new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            #define GRADIENT_BACKGROUND3\n            \n            ${d({varyingName:"vColor",varyingType:"v3"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            void main() {\n                gl_FragColor = ${p()}(${f("vColor")}, 1.0);\n                \n                ${c("convertedColor")} = ${l("convertToLinear","v3",[s("gl_FragColor.xyz")])};\n                gl_FragColor.x = convertedColor.x;\n                gl_FragColor.y = convertedColor.y;\n                gl_FragColor.z = convertedColor.z;\n\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            }\n        `;return{vertexShader:`\n            #define GRADIENT_BACKGROUND3\n            ${u({uniformName:"colors",uniformType:"fv3",size:3})}\n            ${u({uniformName:"YUp",uniformType:"i"})}\n       \n            ${d({varyingName:"vColor",varyingType:"v3"})}\n\n            void main() {\n                ${c("borderColor")};\n                ${$("a")};\n                if (${m("YUp")} == 0){\n                    borderColor = mix(${m("colors")}[2], ${m("colors")}[0], step(0.0, position_.z));\n                    a = sign(position_.z) * position_.z;\n                } else {\n                    borderColor = mix(${m("colors")}[2], ${m("colors")}[0], step(0.0, position_.y));\n                    a = sign(position_.y) * position_.y;\n                }\n                ${h("vColor")} = mix(${m("colors")}[1], borderColor, a);\n                ${a.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:o}}),Gradient4Builder:new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            #define GRADIENT_BACKGROUND4\n            ${u({uniformName:"colors",uniformType:"fv3",size:4})}\n            ${u({uniformName:"horizonHeight",uniformType:"f"})}\n            ${u({uniformName:"skylineFading",uniformType:"f"})}\n\n            ${d({varyingName:"vPositionZ",varyingType:"f"})}\n\n            ${r.postprocess_pars_fragment(t)}\n\n            void main() {\n                ${$("positionSign")}  = step(${m("horizonHeight")}, ${f("vPositionZ")});\n                ${c("centerColor")}  = positionSign * ${m("colors")}[1] + ((1.0 - positionSign) * ${m("colors")}[3]);\n                ${c("borderColor")}  = positionSign * ${m("colors")}[0] + ((1.0 - positionSign) * ${m("colors")}[2]);\n\n                ${$("minHeight")}  = positionSign * ${m("horizonHeight")} + ((1.0 - positionSign) * -1.0);\n                ${$("maxHeight")}  = positionSign + ((1.0 - positionSign) * ${m("horizonHeight")});\n                ${c("color")}  = mix(centerColor, borderColor, smoothstep(minHeight, maxHeight, ${f("vPositionZ")}));\n                if ((${m("skylineFading")} > 0.0) && (positionSign == 1.0)) {\n                    color = ${c()}(smoothstep(${m("horizonHeight")}, ${m("horizonHeight")} + ${m("skylineFading")}, ${f("vPositionZ")}));\n                }\n\n                gl_FragColor = ${p()}(color, 1.0);\n                \n                ${c("convertedColor")} = ${l("convertToLinear","v3",[s("gl_FragColor.xyz")])};\n                gl_FragColor.x = convertedColor.x;\n                gl_FragColor.y = convertedColor.y;\n                gl_FragColor.z = convertedColor.z;\n\n                ${r.postprocess_fragment(t)}\n                ${r.linear_to_gamma_fragment(t)}\n            }\n        `;return{vertexShader:`\n            #define GRADIENT_BACKGROUND4\n            ${u({uniformName:"YUp",uniformType:"i"})}\n\n            ${d({varyingName:"vPositionZ",varyingType:"f"})}\n\n            void main() {\n                if (${m("YUp")} == 0){\n                    ${h("vPositionZ")} = position_.z;\n                } else {\n                    ${h("vPositionZ")} = position_.y;\n                }\n                ${a.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:o}})}}),define("DS/ShaderBuilders/CubeMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.FunctionHandler,s=n=>t.addUniform(n),l=n=>{var e={uniformName:n};return t.getUniform(e)},u=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},m=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},$=n=>r.addVarying(n);return new e(function(e,a){let o=`\n            #define CUBEMAP\n            ${s({uniformName:"tEnvMap",uniformType:"tc"})}\n            ${s({uniformName:"ambient",uniformType:"v3"})}\n            ${s({uniformName:"ambienceMatrix",uniformType:"m4"})}\n\n            ${$({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            void main() {\n                ${u("relPos")}  = ${(n=>r.getVarying(n,r.ShaderStages.in))("vWorldPosition")} - ${c="cameraPosition",p={uniformName:c},t.getGlobalUniform(p)};\n                relPos = (${l("ambienceMatrix")} * ${m()}(relPos,0.0)).xyz;\n                gl_FragColor = ${m()}(${l("ambient")}, 1.0) * ${i.sampleCubeTexture("tEnvMap",`${u()}(relPos.x, -relPos.z, relPos.y)`)};\n            }\n        `;var c,p;return{vertexShader:`\n            #define CUBEMAP\n            ${$({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            void main() {\n                ${m("worldPosition")}  = modelMatrix * ${m()}( position_, 1.0 );\n                ${(n=>r.getVarying(n,r.ShaderStages.out))("vWorldPosition")} = worldPosition.xyz;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(a)}\n            }\n        `,fragmentShader:o}})}),define("DS/ShaderBuilders/MeshBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=n=>{var e={uniformName:n};return t.getUniform(e)},s=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)};let l=function(e,t){let l=n._ShaderChunk,u=n._DeferredShaderChunk;return`\n            ${`\n            #define BASIC\n\n            ${l.PDSFX_Color_pars_fragment(e)}\n\t\t\t${e.useUV?`${((n=null)=>{var e={name:n};return o.vec2(e)})("uvToUse")} ;`:""}\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${l.clip_pars_fragment(e)}\n\t\t\t${l.color_pars_fragment(e)}\n\t\t\t${l.map_pars_fragment(e)}\n            ${l.fog_pars_fragment(e)}\n\t\t\t${u.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${u.depth_pars_fragment(e)}\n                ${u.picking_pars_fragment(e)}\n                ${u.picking_instancing_pars_fragment(e)}\n                ${u.decal_normal_depth_pars_fragment(e)}\n                ${u.shadowmap_pars_fragment(e)}\n                ${u.highlight_pars_fragment(e,!1)}\n                ${u.texcoord_pars_fragment(e)}\n                ${u.gpupos_pars_fragment(e)}\n                `:""}\n\t\t\t${l.postprocess_pars_fragment(e)}\n        `}\n            void main() {\n                ${`\n                ${e.PDSFX?`\n                    ${l.PDSFX_start_fragment(e)}\n                    ${l.PDSFX_map_fragment(e)}\n                    ${l.PDSFX_mapping_fragment(e)}\n                    ${l.PDSFX_Color_backup_fragment(e)}\n\t\t\t\t    ${((n,e,t)=>a.FunctionHandler.callFunction(n,e,t))("ComputeCommonValues",null,[])}; \n                    ${l.PDSFX_discard_fragment(e)}\n                    ${l.PDSFX_Color_fragment(e)}\n                    ${l.PDSFX_viewNormal_fragment(e)}\n                    ${l.PDSFX_viewPosition_fragment(e)}\n                    `:""}\n                ${((n=null)=>{var e={name:n};return o.vec3(e)})("diffuseToUse")}  = ${e.PDSFX?"diffuse":`${i("diffuse")}`};\n                ${((n=null)=>{var e={name:n};return o.float(e)})("opacityToUse")}  = ${e.PDSFX?"opacity":`${i("opacity")}`};\n                ${e.selectionMaterial?`gl_FragColor = ${s()}( diffuseToUse, 1.0 );`:`gl_FragColor = ${s()}( diffuseToUse, opacityToUse );`}\n\n                ${e.useUV?`uvToUse = ${(n=>r.getVarying(n,r.ShaderStages.in))("vUv")}.xy;`:""}\n                ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n\n                ${l.clip_fragment(e)}\n                ${l.uvmapping_fragment(e)}\n                ${l.map_fragment(e)}\n\t\t\t\t${l.color_fragment(e)}\n\t\t\t\t${l.alphatest_fragment(e)}\n               \n\t\t\t\t${l.postprocess_fragment(e)}\n\t\t\t\t${l.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${l.PDSFX_end_fragment(e)}\n\t\t\t\t${l.fog_fragment(e)}\n\t\t\t\t${l.backgroundviewmode_lowlight_fragment(e)}\n                ${u.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${u.depth_fragment_face(e)}\n                    ${u.picking_fragment(e)}\n                    ${u.picking_instancing_fragment(e)}\n                    ${u.highlight_fragment_face(e)}\n                    ${u.normal_fragment(e)}\n                    ${u.normal_depth_fragment(e)}\n                    ${u.shadowmap_fragment(e)}\n                    ${u.texcoord_fragment(e)}\n                    ${u.gpupos_fragment(e)}\n                    `:""}\n        \n        `}\n            }\n        `};return new e(function(e,t){let r=t.isDeferredMaterial,a=l(t,r);return{vertexShader:function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk;return`\n            ${`\n            #define BASIC\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n\n            ${r.fog_pars_vertex(e)}\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:""}\n        `}\n            void main() {\n                ${`\n            ${r.PDSFX_start_vertex(e)}\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n            \n            ${r.morphtarget_vertex(e)}    \n            ${r.morphnormal_vertex(e)}\n            \n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)}       \n            ${r.skinnormal_vertex(e)}\n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:""}\n            ${r.PDSFX_end_vertex(e)}\n        `}\n            }\n        `}(t,r),fragmentShader:a}})}),define("DS/ShaderBuilders/MeshPhongShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i="",s=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),l=n=>t.addUniform(n),u=n=>{var e={uniformName:n};return t.getUniform(e)},m=n=>t.addLightUniform(n),$=n=>{var e={uniformName:n};return t.getLightUniform(e)},c=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},p=(n=null)=>{var e={name:n};return o.int(e)},d=(n=null)=>{var e={name:n};return o.float(e)},f=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},g=n=>r.addVarying(n),v=n=>r.getVarying(n,r.ShaderStages.in),S=n=>r.getVarying(n,r.ShaderStages.out),x=n.TextureBlendOperations;function y(n){return`\n        ${d("diffuseWeightFull")}  = diffuseWeight.x;\n        ${d("diffuseWeightHalf")}  = max( 0.5 * dotProduct + 0.5, 0.0 );\n        diffuseWeight = mix( ${f()}( diffuseWeightFull ), ${f()}( diffuseWeightHalf ), ${u("wrapRGB")} );\n    `}function _(n,e){return`\n            ${h("lDirection")}  = ${c("viewMatrix")} * ${h()}( ${$("directionalLightDirection")}[ ${n} ].xyz, 0.0 );\n            ${f("dirVector")}  = normalize( lDirection.xyz );\n            ${d("dotProduct")}  = dot( normal, dirVector );\n            ${f("diffuseWeight")}  = ${f()}(max( dotProduct, 0.0 ));\n            ${e.wrapAround?`\n                ${y()}\n                `:i}\n            totalDiffuse  += diffuseToUse * ${e.phongFirstDir?"3.0":"1.0"} *${$("directionalLightColor")}[ ${n} ].xyz * diffuseWeight;\n\n            ${f("dirHalfVector")} = normalize( dirVector + view );\n            ${d("dirDotNormalHalf")}  = max( dot( normal, dirHalfVector ), 0.0 );\n            ${d("specularWeight")}  = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );\n            totalSpecular += specularToUse * ${$("directionalLightColor")}[ ${n} ].xyz * specularWeight * diffuseWeight;\n        `}let T=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,[S,T]=function(e){let t=`\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${m({uniformName:"ambientLightColor",uniformType:"v4"})}\n        `,r=`            \n            ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n            ${e.normalMap?"normal = perturbNormal2Arb( -vPos, normal );":i}\n            ${e.bumpMap&&!e.normalMap?`normal = perturbNormalArb( -vPos, normal, ${s("dHdxy_fwd","v2",[prmV2(`${v("vUv")}.xy`)])} );`:i}\n            ${f("totalDiffuse")}  = ${f()}( 0.0 );\n            ${f("totalSpecular")}  = ${f()}( 0.0 );\n        `;return(e.maxSpotLights>0||e.bumpMap||e.normalMap||e.envMap||e.shadowMapCubeEnabled)&&(t=`\n                ${t}\n                ${g({varyingName:"vWorldPosition",varyingType:"v3"})}\n            `),e.wrapAround&&(t=`\n                ${t}\n                ${l({uniformName:"wrapRGB",uniformType:"v3"})}\n            `),e.maxDirLights>0&&(t=`\n                ${t}\n                ${m({uniformName:"directionalLightColor",uniformType:"fv4",size:e.maxDirLights})}\n                ${m({uniformName:"directionalLightDirection",uniformType:"fv4",size:e.maxDirLights})}\n            `,r=`\n                ${r}\n                {\n                    ${_("0",e)}\n                }\n                ${!e.phongFirstDir&&e.maxDirLights>1?`\n                    for( ${p("i")} = 1; i < ${e.maxDirLights} ; i ++ ) { \n                        ${_("i",e)}\n                    }\n                    `:i}\n            `),e.maxDirPhongLights>0&&(t=`\n                ${t}\n                ${m({uniformName:"directionalPhongLightColor",uniformType:"fv4",size:e.maxDirPhongLights})}\n                ${m({uniformName:"directionalPhongLightDirection",uniformType:"fv4",size:e.maxDirPhongLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${p("i")} = 0; i < ${e.maxDirPhongLights}; i ++ ) {\n                    ${h("lDirection")}  = ${c("viewMatrix")} * ${h()}( ${$("directionalPhongLightDirection")}[ i ].xyz, 0.0 );\n                    ${f("dirVector")}  = normalize( lDirection.xyz );\n                    ${d("dotProduct")} = dot( normal, dirVector );                 \n                    ${f("diffuseWeight")}  = ${f()}(max( dotProduct, 0.0 ));\n                    ${e.wrapAround?`\n                        ${y()}\n                        `:i}\n                    totalDiffuse  += diffuseToUse * ${$("directionalPhongLightColor")}[ i ].xyz * diffuseWeight;\n                    ${f("dirHalfVector")}  = normalize( dirVector + view );\n                    ${d("dirDotNormalHalf")}  = max( dot( normal, dirHalfVector ), 0.0 );\n                    ${d("specularWeight")}  = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );\n                    totalSpecular += specularToUse * ${$("directionalPhongLightColor")}[ i ].xyz * specularWeight * diffuseWeight;\n                }\n            `)),e.maxPointLights>0&&(t=`\n                ${t}\n                ${m({uniformName:"pointLightColor",uniformType:"fv4",size:e.maxPointLights})}\n                ${m({uniformName:"pointLightPosition",uniformType:"fv4",size:e.maxPointLights})}\n                ${m({uniformName:"pointLightPhysicalAttenuation",uniformType:"iv1",size:e.maxPointLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${p("i")} = 0; i < ${e.maxPointLights}; i ++ ) {\n                    ${h("lPosition")}  = ${c("viewMatrix")} * ${h()}( ${$("pointLightPosition")}[ i ].xyz, 1.0 );\n                    ${f("lVector")}  = lPosition.xyz + vPos.xyz;\n                    ${d("lDistance")} = 1.0;\n                    if (${$("pointLightPhysicalAttenuation")}[ i ]> 0){\n                        lDistance = 1.0 / (dot(lVector,lVector) * ${$("pointLightPosition")}[ i ].w);\n                    } else {\n                        if ( ${$("pointLightPosition")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${$("pointLightPosition")}[ i ].w ), 1.0 );\n                        }\n                    }\n                    lVector = normalize( lVector );\n                    ${d("dotProduct")} = dot( normal, lVector );                  \n                    ${f("diffuseWeight")} = ${f()}(max( dotProduct, 0.0 ));\n                    ${e.wrapAround?`\n                        ${y()}\n                        `:i}\n                    totalDiffuse  += diffuseToUse * ${$("pointLightColor")}[ i ].xyz * diffuseWeight * lDistance;\n\n                    ${f("pointHalfVector")}  = normalize( lVector + view );\n                    ${d("pointDotNormalHalf")}  = max( dot( normal, pointHalfVector ), 0.0 );\n                    ${d("specularWeight")}  = specularStrength * max( pow( pointDotNormalHalf, shininessValue ), 0.0 );\n\n                    totalDiffuse += specularToUse * ${$("pointLightColor")}[ i ].xyz * specularWeight * diffuseWeight * lDistance;\n                }\n            `)),e.maxSpotLights>0&&(t=`\n                ${t}\n                ${m({uniformName:"spotLightColor",uniformType:"fv4",size:e.maxSpotLights})}\n                ${m({uniformName:"spotLightPosition",uniformType:"fv4",size:e.maxSpotLights})}\n                ${m({uniformName:"spotLightDirection",uniformType:"fv4",size:e.maxSpotLights})}\n                ${m({uniformName:"spotLightPhysicalAttenuation",uniformType:"iv1",size:e.maxSpotLights})}\n            `,e.phongFirstDir||(r=`\n                ${r}\n                for ( ${p("i")} = 0; i < ${e.maxSpotLights}; i ++ ) {\n                    ${h("lPosition")}  = ${c("viewMatrix")} * ${h()}( ${$("spotLightPosition")}[ i ].xyz, 1.0 );\n                    ${f("lVector")}  = lPosition.xyz + vPos.xyz;\n                    ${d("lDistance")} = 1.0;\n                    if (${$("spotLightPhysicalAttenuation")}[ i ]> 0){\n                        lDistance =1.0 / (dot(lVector,lVector) * ${$("spotLightColor")}[ i ].w );\n                    }else {\n                        if ( ${$("spotLightColor")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${$("spotLightColor")}[ i ].w ), 1.0 );\n                        }\n                    }\n                    lVector = normalize( lVector );\n                    ${d("spotEffect")}  = dot( ${$("spotLightDirection")}[ i ].xyz, normalize( ${$("spotLightPosition")}[ i ].xyz - ${v("vWorldPosition")} ) );\n                    if ( spotEffect > ${$("spotLightPosition")}[ i ].w ) {\n                        spotEffect = 1.0 - smoothstep( ${$("spotLightDirection")}[ i ].w,${$("spotLightPosition")}[ i ].w,spotEffect );\n                        ${d("dotProduct")} = dot( normal, lVector );\n                        ${f("diffuseWeight")} = ${f()}(max( dotProduct, 0.0 ));\n                        ${e.wrapAround?`\n                            ${y()}\n                            `:i}\n                        totalDiffuse += diffuseToUse *  ${$("spotLightColor")}[ i ].xyz * diffuseWeight * lDistance * spotEffect;\n                        ${f("spotHalfVector")}  = normalize( lVector + view );\n                        ${d("spotDotNormalHalf")}  = max( dot( normal, spotHalfVector ), 0.0 );\n                        ${d("specularWeight")}  = specularStrength * max( pow( spotDotNormalHalf, shininessValue ), 0.0 );\n                        totalSpecular += specularToUse *  ${$("spotLightColor")}[ i ].xyz * specularWeight * diffuseWeight * lDistance * spotEffect;\n                    }\n                }\n            `)),[t,r=`\n            ${r}\n            ${f("finalPhongColor")} = gl_FragColor.xyz;\n            ${e.metal?`\n                finalPhongColor = gl_FragColor.xyz * ( emissiveToUse + totalDiffuse + ${$("ambientLightColor")}.xyz * ${u("ambient")} + totalSpecular );\n                `:`\n                ${(e.map||e.pdsfxUseMap)&&e.textureBlending!==x.KEEP_DEFAULT?`\n                    ${h("texture")}  = texelColor;\n                    ${f("colorValue")}  = ( totalDiffuse + ${$("ambientLightColor")}.xyz * ${u("ambient")} ) + totalSpecular;\n                    ${e.textureBlending===x.MODULATE?`finalPhongColor = texture.xyz * ( totalDiffuse + ${$("ambientLightColor")}.xyz * ${u("ambient")} ) + totalSpecular;`:i}\n                    ${e.textureBlending===x.DECAL?"finalPhongColor = (1.0-texture.xyz) * colorValue + texture.xyz;":i}\n                    ${e.textureBlending===x.BLEND?"finalPhongColor = (1.0-texture.a) * colorValue + texture.a * texture.xyz;":i}\n                    ${e.textureBlending===x.REPLACE&&1021===e.textureFormat?"gl_FragColor.a = texture.a;":i}\n                    `:`finalPhongColor = gl_FragColor.xyz * ( totalDiffuse + ${$("ambientLightColor")}.xyz * ${u("ambient")} ) + totalSpecular;`}\n                `}\n            gl_FragColor.x = finalPhongColor.x;\n            gl_FragColor.y = finalPhongColor.y;\n            gl_FragColor.z = finalPhongColor.z;\n        `]}(e);return`\n            ${`\n            #define PHONG\n\n            ${r.PDSFX_Color_pars_fragment(e)}     \n            ${l({uniformName:"ambient",uniformType:"v3"})}\n            ${r.PDSFX_Phong_pars_fragment(e)}\n            ${l({uniformName:"shininess",uniformType:"f"})}\n            ${l({uniformName:"shininessInSpecMap",uniformType:"b"})}\n\t\t\t${e.useUV?`${((n=null)=>{var e={name:n};return o.vec2(e)})("uvToUse")} ;`:i}          \n            ${r.clip_pars_fragment(e)}\n\t\t\t${r.color_pars_fragment(e)}\n\t\t\t${r.map_pars_fragment(e)}\n\t\t\t${r.envmap_pars_fragment(e)}\n\t\t\t${S}\n\t\t\t${t?i:r.shadowmap_pars_fragment(e)}\n\t\t\t${r.bumpmap_pars_fragment(e)}\n\t\t\t${r.normalmap_pars_fragment(e)}\n\t\t\t${r.specularmap_pars_fragment(e)}\n\t\t\t${r.fog_pars_fragment(e)}\n\t\t\t${r.ao_pars_fragment(e)}\n\t\t\t${a.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${a.depth_pars_fragment(e)}\n                ${a.picking_pars_fragment(e)}\n                ${a.picking_instancing_pars_fragment(e)}\n                ${a.decal_normal_depth_pars_fragment(e)}\n                ${a.shadowmap_pars_fragment(e)}\n                ${a.highlight_pars_fragment(e,!1)}\n                ${a.texcoord_pars_fragment(e)}\n                ${a.gpupos_pars_fragment(e)}\n                `:i}\n\t\t\t${r.postprocess_pars_fragment(e)}\n        `}\n            void main() {\n                ${`\n                ${e.PDSFX?`\n                    ${r.PDSFX_start_fragment(e)}\n                    ${r.PDSFX_map_fragment(e)}\n                    ${r.PDSFX_mapping_fragment(e)}\n                    ${r.PDSFX_Color_backup_fragment(e)}\n                    ${r.PDSFX_Phong_backup_fragment(e)}\n\t\t\t\t    ${s("ComputeCommonValues",null,[])}; \n                    ${r.PDSFX_discard_fragment(e)}\n                    ${r.PDSFX_Color_fragment(e)}\n                    ${r.PDSFX_Phong_fragment(e)}\n                    ${r.PDSFX_viewNormal_fragment(e)}\n                    ${r.PDSFX_viewPosition_fragment(e)}\n                    `:i}\n                ${f("diffuseToUse")}  = ${e.PDSFX?"diffuse":`${u("diffuse")}`};\n                ${f("emissiveToUse")}  = ${e.PDSFX?"emissive":`${u("emissive")}`};\n                ${f("specularToUse")}  = ${e.PDSFX?"specular":`${u("specular")}`};\n                ${d("opacityToUse")}  = ${e.PDSFX?"opacity":`${u("opacity")}`};\n                ${e.selectionMaterial?`gl_FragColor = ${h()}( 1.0 );`:`gl_FragColor = ${h()}( 1.0, 1.0, 1.0, opacityToUse );`}\n\n                ${e.useUV?`uvToUse = ${v("vUv")}.xy;`:i}\n\n                ${r.clip_fragment(e)}\n                ${r.uvmapping_fragment(e)}\n                ${r.map_fragment(e)}\n\t\t\t\t${r.color_fragment(e)}\n\t\t\t\t${r.alphatest_fragment(e)}\n                \n                ${d("shininessValue")}  = ${u("shininess")};\n\n\t\t\t\t${r.specularmap_fragment(e)}\n        \n\t\t\t\t${T}\n\n\t\t\t\t${r.envmap_fragment(e)}\n\t\t\t\t${t?i:r.shadowmap_fragment_old(e)}\n               \n\t\t\t\t${r.ao_fragment(e)}\n\t\t\t\t${r.postprocess_fragment(e)}\n\t\t\t\t${r.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${r.PDSFX_end_fragment(e)}\n\t\t\t\t${r.fog_fragment(e)}\n\t\t\t\t${r.backgroundviewmode_lowlight_fragment(e)}\n                ${a._debug_common_face_fragment(e)}\n                ${a.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${a.depth_fragment_face(e)}\n                    ${a.picking_fragment(e)}\n                    ${a.picking_instancing_fragment(e)}\n                    ${a.highlight_fragment_face(e)}\n                    ${a.normal_fragment(e)}\n                    ${a.normal_depth_fragment(e)}\n                    ${a.shadowmap_fragment(e)}\n                    ${a.texcoord_fragment(e)}\n                    ${a.gpupos_fragment(e)}\n                    `:i}\n        \n        `}\n            }\n        `};let D=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,[o,s]=function(n){let e=i,t=i;return(n.maxSpotLights>0||n.bumpMap||n.normalMap||n.envMap||n.shadowMapCubeEnabled)&&(e=g({varyingName:"vWorldPosition",varyingType:"v3"}),t=`${S("vWorldPosition")} = worldPosition.xyz;`),[e,t]}(e);return`\n            ${`\n            #define PHONG\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.envmap_pars_vertex(e)}\n            ${o}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n            ${t?i:r.shadowmap_pars_vertex(e)}\n            ${r.fog_pars_vertex(e)}\n\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:i}\n        `}\n            void main() {\n                ${`\n            ${r.PDSFX_start_vertex(e)}\n\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n  \n            ${r.morphtarget_vertex(e)}     \n            ${r.morphnormal_vertex(e)}\n            \n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)} \n            ${r.skinnormal_vertex(e)}\n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n       \n            ${r._worldpos_vertex(e)}\n            ${r.envmap_vertex(e)}\n            ${s}\n            ${t?i:r.shadowmap_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:i}\n            ${r.PDSFX_end_vertex(e)}\n        `}\n            }\n        `};return new e(function(n,e){let t=e.isDeferredMaterial,r=T(e,t);return{vertexShader:D(e,t),fragmentShader:r}})}),define("DS/ShaderBuilders/LatLongMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=n=>i.parameterF(n),u=n=>i.parameterV2(n),m=n=>i.parameterV3(n),$=n=>i.parameterT2(n),c=(n,e,t)=>s.callFunction(n,e,t),p=n=>t.addUniform(n),d=n=>{var e={uniformName:n};return t.getUniform(e)},f=(n=null)=>{var e={name:n};return o.float(e)},h=(n=null)=>{var e={name:n};return o.vec2(e)},g=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},S=n=>{var e={name:n,constant:!0};return o.float(e)};return new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            #define LATLONGMAP\n\n            ${S("PI")} = 3.14159;\n            ${S("INV_PI")} = 0.31830988618;\n\n            ${p({uniformName:"tEnvMap",uniformType:"t2"})}\n            ${p({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${p({uniformName:"blurCoef",uniformType:"f"})}\n            ${p({uniformName:"envMapExposure",uniformType:"f"})}\n            ${p({uniformName:"ambient",uniformType:"v3"})}\n            ${p({uniformName:"planeColor",uniformType:"v3"})}\n            ${p({uniformName:"invScreenSize",uniformType:"v2"})}\n            ${p({uniformName:"cameraSight",uniformType:"v3"})}\n            ${p({uniformName:"cameraUp",uniformType:"v3"})}\n            ${p({uniformName:"cameraRight",uniformType:"v3"})}\n            ${p({uniformName:"startOffset",uniformType:"v2"})}\n            ${p({uniformName:"endOffset",uniformType:"v2"})}\n            ${p({uniformName:"withPlane",uniformType:"f"})}\n\n            ${t.useHDR&&!t.useHDRFloat?`\n                ${p({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${p({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})}\n                ${a.rgbe_sample_methods(t)}\n\n                ${((n,e,t)=>s.declareFunction(n,e,t))("sampleMipMapRoughness","v4",[u("uv"),l("mip"),l("coef"),$("map0"),$("map1"),u("textureSize"),u("texelSize")])}{\n                    ${v("color1")} ;\n                    ${v("color2")} ;\n                    ${h("uv1")} ;\n                    ${h("uv2")} ;\n                    ${h("textureSize2")} = textureSize * ${d("envMapHDRToMipsRatio")} * ${h()}(1.0,2.0);\n                    ${h("texelSize2")}  = texelSize / ${d("envMapHDRToMipsRatio")} * ${h()}(1.0,2.0);\n                    if (mip < 1.0) {\n                        color1 = ${c("texture2DBilinearFromRGBE","v4",[$("map0"),u("uv"),u("textureSize"),u("texelSize")])};\n                    } else {\n                        ${f("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                        ${f("t10")}  = pow(2.0, -floor(log2(level1 + 1.0)));\n                        ${f("t11")}  = 2.0 - (level1 + 2.0) * t10;\n                        ${f("t12")}  = 0.5 * t10;\n\n                        uv1 = ${h()}(t11 + 1.5 * texelSize2.x + (2.0 * t12 - 3.0 * texelSize2.x) * uv.x, t12 + 1.5 * texelSize2.x + (t12 - 3.0 * texelSize2.x) * uv.y);\n                        color1 = ${c("texture2DBilinearFromRGBE","v4",[$("map1"),u("uv1"),u("textureSize2"),u("texelSize2")])};\n                    }\n\n                    ${f("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                    ${f("t20")}  = pow(2.0, -floor(log2(level2 + 1.0)));\n                    ${f("t21")}  = 2.0 - (level2 + 2.0) * t20;\n                    ${f("t22")}  = 0.5 * t20;\n\n                    uv2 = ${h()}(t21 + 1.5 * texelSize2.x + (2.0 * t22 - 3.0 * texelSize2.x) * uv.x, t22 + 1.5 * texelSize2.x + (t22 - 3.0 * texelSize2.x) * uv.y);\n                    color2 = ${c("texture2DBilinearFromRGBE","v4",[$("map1"),u("uv2"),u("textureSize2"),u("texelSize2")])};\n\n                    return mix(color1, color2, coef);\n                }\n                `:""}\n\n            ${r.postprocess_pars_fragment(t)}\n            \n            void main() {\n                ${h("screenOffset")}  = 2.0 * mix(${d("startOffset")}, ${d("endOffset")}, gl_FragCoord.xy * ${d("invScreenSize")}) - 1.0;\n                ${g("dir")}  = normalize(${d("cameraSight")} + screenOffset.x * ${d("cameraRight")} + screenOffset.y * ${d("cameraUp")});\n                dir = (${d("ambienceMatrix")} * ${v()}(dir,0.0)).xyz;\n                ${t.useHDR&&!t.useHDRFloat?"":"dir.y *= -1.0;"}\n                ${f("phi")}  = atan(dir.y, dir.x);\n                ${f("theta")}  = acos(dir.z);\n\n                ${h("texelCoord")}  = ${h()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n                ${f("plane")}  = step(texelCoord.y, 0.5) * ${d("withPlane")};\n\n                ${g("planeColor2")}  = ${c("convertToLinear","v3",[m(`${d("planeColor")}.xyz`)])};\n                gl_FragColor.w = 1.0 + plane * 0.4;\n\n                ${g("mapColor")};\n                ${t.useHDR&&!t.useHDRFloat?`\n                    vec2 texelSize = vec2(1.0 / ${d("envMapHDRSize")});\n                    mapColor = ((${c("texture2DBilinearFromRGBE","v4",[$("tEnvMap"),u("texelCoord"),u(`${d("envMapHDRSize")}`),u("texelSize")])}.xyz) * (1.0 -plane)) + (plane * planeColor2);\n\n                    `:`mapColor = ${s.sample2DTexture("tEnvMap","texelCoord")}.xyz * (1.0 - plane) + (plane * planeColor2);`}\n\n                gl_FragColor.x = mapColor.x;\n                gl_FragColor.y = mapColor.y;\n                gl_FragColor.z = mapColor.z;\n                ${!t.gammaOutput&&t.useSRGB?`\n                    ${g("convertedColor")} = ${c("convertToLinear","v3",[m("gl_FragColor.xyz")])};\n                    gl_FragColor.x = convertedColor.x;\n                    gl_FragColor.y = convertedColor.y;\n                    gl_FragColor.z = convertedColor.z;\n                    `:""}                \n                gl_FragColor *= ${v()}(${d("ambient")} * ${d("envMapExposure")}, 1.0);\n                ${r.postprocess_fragment(t)}\n                ${t.gammaOutput&&t.useHDR?r.linear_to_gamma_fragment(t):""}\n\n            }\n        `;return{vertexShader:`\n            #define LATLONGMAP\n\n            void main() {\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:o}})}),define("DS/ShaderBuilders/Commons/CoreShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=(n,e,t=!1)=>o.parameter(n,e,t),l=n=>o.parameterF(n),u=n=>o.parameterV2(n),m=n=>o.parameterV3(n),$=n=>o.parameterV4(n),c=(n,e,t)=>i.declareFunction(n,e,t),p=(n,e,t)=>i.callFunction(n,e,t),d=e=>n.addUniform(e),f=e=>{var t={uniformName:e};return n.getUniform(t)},h=e=>n.addGlobalUniform(e),g=e=>{var t={uniformName:e};return n.getGlobalUniform(t)},v=e=>n.addObjectUniform(e),S=e=>{var t={uniformName:e};return n.getObjectUniform(t)},x=(n=null,e="")=>{var t={name:n,addressSpace:e};return a.bool(t)},y=(n=null)=>{var e={name:n};return a.float(e)},_=(n=null)=>{var e={name:n};return a.vec2(e)},T=(n=null,e=0,t="")=>{var r={name:n,size:e,addressSpace:t};return a.vec3(r)},D=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},C=(n=null,e="")=>{var t={name:n,addressSpace:e};return a.mat3(t)},P=(n=null,e="")=>{var t={name:n,addressSpace:e};return a.mat4(t)},N=n=>{var e={name:n,constant:!0};return a.vec2(e)},M=n=>{var e={name:n,constant:!0};return a.vec3(e)},b=n=>{var e={name:n,constant:!0};return a.vec4(e)},w=n=>t.addVarying(n),U=n=>t.getVarying(n,t.ShaderStages.in),z=n=>t.getVarying(n,t.ShaderStages.out),V=n=>e.addAttribute(n),F=n=>e.addInstancingAttribute(n),R=n=>e.getAttribute(n);return{Default_uniforms_declaration:function(n){return`\n            ${2===n.WebGLVersion?"uniform FrameUBO {\n                    mat4 viewMatrix;\n                    mat4 projectionMatrix;\n                    vec3 cameraPosition;\n                };\n                ":`\n                ${h({uniformName:"viewMatrix",uniformType:"m4"})} \n                ${h({uniformName:"projectionMatrix",uniformType:"m4"})} \n                ${h({uniformName:"cameraPosition",uniformType:"v3"})} \n                `}\n            ${v({uniformName:"_modelMatrixForDoubleGPU",uniformType:"m4",locationName:"modelMatrix"})} \n\t\t\t${P("modelMatrix","private")} ;\n\t\t\t${T("vertexLocalPosition",0,"private")} ; \n            ${n.defaultInstancing?`\n                ${v({uniformName:"belowInstancingModelMatrix",uniformType:"m4"})} \n                ${P("multipliedDefaultInstancingMatrix","private")} ;               \n                ${w({varyingName:"multipliedDefaultInstancingMatrixX",varyingType:"v4"})}\n                ${w({varyingName:"multipliedDefaultInstancingMatrixY",varyingType:"v4"})}\n                ${w({varyingName:"multipliedDefaultInstancingMatrixZ",varyingType:"v4"})}\n                `:""}\n\t\t\t${T("lowPartModelTranslation",0,"private")} ;\n            ${n.largeScale?`\n                ${P("modelViewMatrix","private")};\n                ${x("_modelViewMatrixSet","private")} = false;\n                ${c("getModelViewMatrix","m4",[])} {\n                    if (!_modelViewMatrixSet) {\n                        modelViewMatrix = ${g("viewMatrix")} * modelMatrix;\n                        _modelViewMatrixSet = true;\n                    }\n                    return modelViewMatrix;\n                }\n                `:`\n                ${v({uniformName:"modelViewMatrix",uniformType:"m4",materialName:"_modelViewMatrix"})}\n                \n                ${c("getModelViewMatrix","m4",[])} {\n                    return ${S("modelViewMatrix")};\n                }\n                `}\n            `},normalMatrix_uniforms_declaration:function(n){return`\n            ${n.WebGPU?v({uniformName:"normalMatrix",uniformType:"m3",materialName:"_normalMatrix"}):""}\n                ${n.useNormalMatrix?`\n                    ${x("use_normal_matrix","private")}  = true;\n                    ${n.WebGPU?"":v({uniformName:"normalMatrix",uniformType:"m3",materialName:"_normalMatrix"})}\n                    `:`\n                    ${x("use_normal_matrix","private")} = false;\n                    ${C("normalMatrix","private")} ;\n                    `}\n            `},double_emulation_utilities:function(n){return`\n            // http://andrewthall.org/papers/df64_qf128.pdf\n            ${c("quickTwoSum","v2",[l("a"),l("b")])}{\n                ${y("s")} = a + b;\n                ${y("e")} = b - (s-a);\n                return ${_()}(s,e);\n            }\n            \n            ${c("twoSumComp","v4",[u("a"),u("b")])}{\n                ${_("s")}  = a + b;\n                ${_("v")}  = s - a;\n                ${_("e")}  = (a - (s-v)) + (b-v);\n                return ${D()}(s.x,e.x,s.y,e.y);\n            }\n            \n            ${c("df64_add","v2",[u("a"),u("b")])}{\n                ${D("st")}  = ${p("twoSumComp","v4",[u("a"),u("b")])};\n                st.y += st.z;\n                ${_("auxQTS")} = ${p("quickTwoSum","v2",[l("st.x"),l("st.y")])};\n                st.x = auxQTS.x;\n                st.y = auxQTS.y;\n                st.y += st.w;\n                return  ${p("quickTwoSum","v2",[l("st.x"),l("st.y")])};\n            }\n\n        \n            ${c("_computeModelPosition","v3",[m("pos"),m("cameraPos"),m("lowPartCameraPos"),s("m4","matrix"),m("lowPartTranslation")])}{\n                // Model double translation\n               ${_("Tmx")}  = ${_()}(matrix[3][0],lowPartTranslation.x);\n               ${_("Tmy")}  = ${_()}(matrix[3][1],lowPartTranslation.y);\n               ${_("Tmz")}  = ${_()}(matrix[3][2],lowPartTranslation.z);\n                // View camera translation\n                ${_("Tcx")}  = -${_()}(cameraPos.x,lowPartCameraPos.x);\n                ${_("Tcy")}  = -${_()}(cameraPos.y,lowPartCameraPos.y);\n                ${_("Tcz")}  = -${_()}(cameraPos.z,lowPartCameraPos.z);\n                // Translation\n                ${_("Tx")}  = ${p("df64_add","v2",[u("Tmx"),u("Tcx")])};\n                ${_("Ty")}  = ${p("df64_add","v2",[u("Tmy"),u("Tcy")])};\n                ${_("Tz")}  = ${p("df64_add","v2",[u("Tmz"),u("Tcz")])};\n                // \n                ${D("worldPos")}  = matrix * ${D()}(pos.xyz,0.0);\n                return worldPos.xyz + ${T()}(Tx.x, Ty.x, Tz.x);\n            }\n        \n            ${c("_computeModelViewPosition","v3",[m("pos"),m("cameraPos"),m("lowPartCameraPos"),s("m4","matrix"),m("lowPartTranslation"),s("m4","viewMatrix")])}{\n               return (viewMatrix * ${D()}(${p("_computeModelPosition","v3",[m("pos"),m("cameraPos"),m("lowPartCameraPos"),s("m4","matrix"),m("lowPartTranslation")])}, 0.0)).xyz;\n            }\n            `},double_emulation:function(n){const e=p("getModelViewMatrix","m4",[]);return`\n                ${h({uniformName:"lowPartCameraPosition",uniformType:"v3"})} \n        \n                ${c("computeModelViewPosition","v4",[$("pos")])}{        \n                    ${D("posToUse")} = pos;                    \n                    ${n.defaultInstancing?`posToUse = (multipliedDefaultInstancingMatrix * ${D()}(posToUse.xyz, 1.0));`:""}   \n                    ${n.largeScale?`\n                        return  ${D()}(${p("_computeModelViewPosition","v3",[m("posToUse.xyz"),m(`${g("cameraPosition")}`),m(`${g("lowPartCameraPosition")}`),s("m4","modelMatrix"),m("lowPartModelTranslation"),s("m4",`${g("viewMatrix")}`)])},1.0);\n                        `:`return ${e} * posToUse;`}\n                }\n        \n                \n                ${c("computeModelViewPosition","v4",[m("pos")])}{ \n                    ${D("posV4")} =  ${D()}(pos, 1.0);\n                    return ${p("computeModelViewPosition","v4",[$("posV4")])};\n                }\n        \n                ${c("computeModelViewDirection","v4",[m("direction")])}{          \n                    ${T("directionToUse")} = direction;                    \n                    ${n.defaultInstancing?`directionToUse = (multipliedDefaultInstancingMatrix * ${D()}(directionToUse.xyz, 0.0)).xyz;`:""}   \n                    return ${e} *  ${D()}(directionToUse, 0.0);\n                }\n\n                ${c("computeModelPosition","v4",[$("iVec4")])}{\n                    ${D("res")}  = iVec4;                     \n                    ${n.defaultInstancing?`res = (multipliedDefaultInstancingMatrix * ${D()}(res.xyz, 1.0));`:""}      \n                    return modelMatrix * res;\n\t\t\t\t}\n                ${c("computeModelPosition","v4",[m("iVec3")])}{       \n                    return ${p("computeModelPosition","v4",[$("vec4(iVec3, 1.0)")])};\n\t\t\t\t}\n\n                ${c("computeModelDirection","v4",[m("direction")])}{          \n                    ${T("directionToUse")} = direction;                    \n                    ${n.defaultInstancing?`directionToUse = (multipliedDefaultInstancingMatrix * ${D()}(directionToUse.xyz, 0.0)).xyz;`:""}   \n                    return modelMatrix * ${D()}(directionToUse, 0.0);\n                }\n        \n                ${c("computeModelViewPositionCustom","v4",[$("pos"),s("m4","matrix"),m("lowPartTranslation")])}{     \n                   return  ${D()}(${p("_computeModelViewPosition","v3",[m("pos.xyz"),m(`${g("cameraPosition")}`),m(`${g("lowPartCameraPosition")}`),s("m4","matrix"),m("lowPartTranslation"),s("m4",`${g("viewMatrix")}`)])},1.0);\n                }\n        \n                ${c("computeModelViewPositionCustom","v4",[m("pos"),s("m4","matrix"),m("lowPartTranslation")])}{     \n                   return  ${D()}(${p("_computeModelViewPosition","v3",[m("pos.xyz"),m(`${g("cameraPosition")}`),m(`${g("lowPartCameraPosition")}`),s("m4","matrix"),m("lowPartTranslation"),s("m4",`${g("viewMatrix")}`)])},1.0);\n                }\n\n                ${c("computeModelViewDirectionCustom","v4",[m("direction"),s("m4","matrix")])}{         \n                    return ${g("viewMatrix")} * (matrix *  ${D()}(direction, 0.0));\n                }\n        \n                ${n.shadowMapEnabled?`\n                    ${c("computeShadowCoord","v4",[m("pos"),s("m4","shadowMat"),m("shadowCameraPos"),m("lowPartShadowCameraPos")])}{                      \n                        ${T("posToUse")} = pos;                    \n                        ${n.defaultInstancing?`posToUse = (multipliedDefaultInstancingMatrix * ${D()}(posToUse, 1.0)).xyz;`:""}   \n                        ${D("worldPos")} =  ${D()}(${p("_computeModelPosition","v3",[m("posToUse"),m("shadowCameraPos"),m("lowPartShadowCameraPos"),s("m4","modelMatrix"),m("lowPartModelTranslation")])},1.0);\n                       return shadowMat * worldPos;\n                    }\n                    `:""}\n            `},bumpmap_pars_fragment:function(n){return n.bumpMap?`\n                ${d({uniformName:"bumpMap",uniformType:"t2"})} \n                ${d({uniformName:"bumpScale",uniformType:"f"})} \n\n                // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n                //\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n                // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n                ${c("dHdxy_fwd","v2",[u("uv")])}{\n                    ${_("dSTdx")}  = dFdx( uv );\n                    ${_("dSTdy")}  = dFdy( uv );\n\n                    ${y("Hll")}  = ${f("bumpScale")} * ${i.sample2DTexture("bumpMap","uv")}.x;\n                    ${y("dBx")}  = ${f("bumpScale")} * ${i.sample2DTexture("bumpMap","uv + dSTdx")}.x - Hll;\n                    ${y("dBy")}  = ${f("bumpScale")} * ${i.sample2DTexture("bumpMap","uv + dSTdy")}.x - Hll;\n\n                    return ${_()}( dBx, dBy );\n\n                }\n\n                ${c("perturbNormalArb","v3",[m("surf_pos"),m("surf_norm"),u("dHdxy")])}{\n\n                    ${T("vSigmaX")}  = dFdx( surf_pos );\n                    ${T("vSigmaY")}  = dFdy( surf_pos );\n                    ${T("vN")}  = surf_norm;\t\t// normalized\n\n                    ${T("R1")}  = cross( vSigmaY, vN );\n                    ${T("R2")}  = cross( vN, vSigmaX );\n\n                    ${y("fDet")}  = dot( vSigmaX, R1 );\n\n                    ${T("vGrad")}  = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n                    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n                }\n            `:""},normalmap_pars_fragment:function(n){return n.normalMap?`\n                ${d({uniformName:"normalMap",uniformType:"t2"})} \n                ${d({uniformName:"normalScale",uniformType:"v2"})} \n                \n                // Per-Pixel Tangent Space Normal Mapping\n                // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n                ${c("perturbNormal2Arb","v3",[m("eye_pos"),m("surf_norm")])}{\n\n                    ${T("q0")}  = dFdx( eye_pos.xyz );\n                    ${T("q1")}  = dFdy( eye_pos.xyz );\n                    ${_("st0")}  = dFdx( uvToUse.st );\n                    ${_("st1")}  = dFdy( uvToUse.st );\n\n                    //Fallback for degenerate UV mappings.\n                    //== 0.0 if no direction for tangent\n                    ${y("alphaT")}  = step(0.00001, abs(st0.y) + abs(st1.y)); \n                    //== 0.0 if no direction for binorm\n                    ${y("alphaB")}   = step(0.00001, abs(st0.x) + abs(st1.x)); \n                    //== 0.0 if no direction for both\n                    ${y("alphaBT")}   = 1.0 - max(alphaB, alphaT);                 \n\n                    //If both vectors are null, set them to canonical basis;\n                    //If only one is null, set it to be perpendicular to the other one.\n                    //Do not change anything otherwise.\n\n                    st0.y = alphaT * st0.y - (1.0 - alphaT)*(alphaB * st1.x);\n                    st1.y = alphaT * st1.y + (1.0 - alphaT)*(alphaB * st0.x) + alphaBT;\n\n                    st0.x = alphaB * st0.x - (1.0 - alphaB)*(alphaT * st1.y) + alphaBT;\n                    st1.x = alphaB * st1.x + (1.0 - alphaB)*(alphaT * st0.y);\n\n                    ${T("S")}  = normalize(  q0 * st1.t - q1 * st0.t );\n                    ${T("T")}  = normalize( -q0 * st1.s + q1 * st0.s );\n                    ${T("N")}  = normalize( surf_norm );\n\n                    ${T("mapN")}  = ${i.sample2DTexture("normalMap","uvToUse")}.xyz * 2.0 - 1.0;\n                    mapN.x = ${f("normalScale")}.x * mapN.x;\n                    mapN.y = ${f("normalScale")}.y * mapN.y;\n                    ${n.normalMapFlipY?"mapN.y = - mapN.y;":""}\n\n                    ${C("tsn")}  = ${C()}( S, T, N );\n                    return normalize( tsn * mapN );\n\n                }\n            `:""},specularmap_pars_fragment:function(n){return n.specularMap?d({uniformName:"specularMap",uniformType:"t2"}):""},specularmap_fragment:function(n){return n.specularMap?`\n            ${_("specularUV")} =uvToUse;\n            ${D("texelSpecular")}  = ${i.sample2DTexture("specularMap","specularUV")};\n            ${y("specularStrength")}  = texelSpecular.r;\n            ${n.phong?`\n                if (${f("shininessInSpecMap")}) {\n                    shininessValue = texelSpecular.a;\n                }\n                `:""}\n            `:`${y("specularStrength")}  = 1.0;`},large_scale_VS:function(n){return`\n            \n            modelMatrix = ${P()}(${S("_modelMatrixForDoubleGPU")});\n            lowPartModelTranslation = ${T()}(modelMatrix[0][3],modelMatrix[1][3],modelMatrix[2][3]);\n            modelMatrix[0][3] = 0.0;\n            modelMatrix[1][3] = 0.0;\n            modelMatrix[2][3] = 0.0;\n            ${n.defaultInstancing?`\n                multipliedDefaultInstancingMatrix = defaultInstancingMatrix * ${S("belowInstancingModelMatrix")};\n                ${z("multipliedDefaultInstancingMatrixX")} = ${D()}(multipliedDefaultInstancingMatrix[0].xyz, multipliedDefaultInstancingMatrix[3].x);\n                ${z("multipliedDefaultInstancingMatrixY")} = ${D()}(multipliedDefaultInstancingMatrix[1].xyz, multipliedDefaultInstancingMatrix[3].y);\n                ${z("multipliedDefaultInstancingMatrixZ")} = ${D()}(multipliedDefaultInstancingMatrix[2].xyz, multipliedDefaultInstancingMatrix[3].z);\n                `:""}\n            ${p("getModelViewMatrix","m4",[])};\n\n            `},large_scale_FS:function(n){return`\n\n            modelMatrix = ${P()}(${S("_modelMatrixForDoubleGPU")});\n            lowPartModelTranslation = ${T()}(modelMatrix[0][3],modelMatrix[1][3],modelMatrix[2][3]);\n            modelMatrix[0][3] = 0.0;\n            modelMatrix[1][3] = 0.0;\n            modelMatrix[2][3] = 0.0;\n            ${n.defaultInstancing?`\n                multipliedDefaultInstancingMatrix[0] = ${D()}(${U("multipliedDefaultInstancingMatrixX")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[1] = ${D()}(${U("multipliedDefaultInstancingMatrixY")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[2] = ${D()}(${U("multipliedDefaultInstancingMatrixZ")}.xyz, 0.0);\n                multipliedDefaultInstancingMatrix[3] = ${D()}(${U("multipliedDefaultInstancingMatrixX")}.w, ${U("multipliedDefaultInstancingMatrixY")}.w, ${U("multipliedDefaultInstancingMatrixZ")}.w, 1.0);\n                `:""}\n            `},rgba_packing_pars:function(n){return`\n\n            \n            ${c("packRGBA","v4",[l("value")])}{\n                ${b("bit_shift")}  = ${D()}( 255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0 );\n                ${b("bit_mask")}   = ${D()}( 0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0 );\n                ${D("res")}  = value * bit_shift;\n                res -= floor(res);\n                res -= res.xxyz * bit_mask;\n                return res;\n            }\n\n            ${c("unpackRGBA","f",[$("rgba")])}{\n\n\t\t\t\t${b("bit_shift")} = ${D()}( 1.0 / ( 255.0 * 255.0 * 255.0 ), 1.0 / ( 255.0 * 255.0 ), 1.0 / 255.0, 1.0 );\n\t\t\t\t${n.mobileDevice?`${y("unpack")}  = dot( floor(255.0 * rgba + 0.5) / 255.0, bit_shift );`:`${y("unpack")} = dot( rgba, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${c("packRGB","v3",[l("value")])}{\n                ${M("bit_shift")} = ${T()}(255.0 * 255.0, 255.0, 1.0 );\n                ${M("bit_mask")}  = ${T()}( 0.0, 1.0 / 255.0, 1.0 / 255.0 );\n                ${T("res")}  = value * bit_shift;\n                res -= floor(res);\n                res -= res.xxy * bit_mask;\n                return res;\n            }\n\n            ${c("unpackRGB","f",[m("rgb")])}{\n\n\t\t\t\t${M("bit_shift")} = ${T()}(1.0 / ( 255.0 * 255.0 ), 1.0 / 255.0, 1.0 );\n                ${n.mobileDevice?`${y("unpack")} = dot( floor(255.0 * rgb + 0.5) / 255.0, bit_shift );`:`${y("unpack")} = dot( rgb, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${c("packRG","v2",[l("value")])}{\n                ${N("bit_shift")} = ${_()}(255.0, 1.0 );\n                ${N("bit_mask")}  = ${_()}( 0.0, 1.0 / 255.0 );\n                ${_("res")}  = value * bit_shift;\n                res -= floor(res);\n                res -= res.xx * bit_mask;\n                return res;\n            }\n\n            ${c("unpackRG","f",[u("rg")])}{\n\n\t\t\t\t${N("bit_shift")} = ${_()}(1.0 / 255.0, 1.0 );\n                ${n.mobileDevice?`${y("unpack")} = dot( floor(255.0 * rg + 0.5) / 255.0, bit_shift );`:`${y("unpack")} = dot( rg, bit_shift );`}\n\t\t\t\treturn unpack;\n\t\t\t}\n\n            ${c("packForFloat16","v2",[l("toPackF16")])}{\n                ${y("converted")} = 2047.0 * toPackF16;\n                ${y("up")} = floor(converted);\n                ${y("down")} = floor((converted - up) * 2047.0);\n                return ${_()}(up, down);\n            }\n\n            ${c("unpackForFloat16","f",[u("packedF16")])}{\n                return (packedF16.x + packedF16.y / 2047.0) / 2047.0;\n            }\n            \n            `},math_utils_pars:function(n){return`\n\n                ${c("pow0","f",[l("iValue")])}{\n                    return 1.0;\n                }\n\n                ${c("pow1","f",[l("iValue")])}{\n                    return iValue;\n                }\n            \n                ${c("pow2","f",[l("iValue")])}{\n                    return iValue*iValue;\n                }\n\n                ${c("pow3","f",[l("iValue")])}{\n                    return  ${p("pow2","f",[l("iValue")])} * iValue;\n                }\n\n                ${c("pow4","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow2","f",[l("iValue")])};\n                    return ${p("pow2","f",[l("tmp")])};\n                }\n\n                ${c("pow5","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow4","f",[l("iValue")])};\n                    return tmp * iValue;\n                }\n\n                ${c("pow6","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow2","f",[l("iValue")])};\n                    ${y("tmp2")}  = ${p("pow3","f",[l("tmp")])};\n                    return tmp2;\n                }\n\n                ${c("pow7","f",[l("iValue")])}{\n                    ${y("tmp")}  = iValue;\n                    ${y("tmp2")}  = ${p("pow6","f",[l("tmp")])};\n                    return tmp * tmp2;\n                }\n\n                ${c("pow8","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow2","f",[l("iValue")])};\n                    ${y("tmp2")}  = ${p("pow4","f",[l("tmp")])};\n                    return tmp2;\n                }\n\n                ${c("pow9","f",[l("iValue")])}{\n                    ${y("tmp")}  = iValue;\n                    ${y("tmp2")}  = ${p("pow8","f",[l("tmp")])};\n                    return  tmp * tmp2;\n                }\n\n                ${c("pow10","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow2","f",[l("iValue")])};\n                    ${y("tmp2")}  = ${p("pow5","f",[l("tmp")])};\n                    return tmp2;\n                }\n\n                ${c("pow11","f",[l("iValue")])}{\n                    ${y("tmp")}  = iValue;\n                    ${y("tmp2")}  = ${p("pow10","f",[l("tmp")])};\n                    return tmp * tmp2;\n                }\n\n                ${c("pow12","f",[l("iValue")])}{\n                    ${y("tmp")}  = ${p("pow2","f",[l("iValue")])};\n                    ${y("tmp2")}  = ${p("pow6","f",[l("tmp")])};\n                    return tmp2;\n                }\n\n                ${c("vNormalize","v2",[u("val")])}{\n                    ${y("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${_()}(0.0);\n                    }\n                    return val/len;\n                }\n\n                ${c("vNormalize","v3",[m("val")])}{\n                    ${y("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${T()}(0.0);\n                    }\n                    return val/len;\n                }\n\n                ${c("vNormalize","v4",[$("val")])}{\n                    ${y("len")}  = length(val);\n                    if ( len < 1e-6) {\n                        return ${D()}(0.0);\n                    }\n                    return val/len;\n                }\n            `},attribute_pars_vertex:function(e){return`\n                \n                ${e.WebGPU?"":`${T("position")};`}\n                ${T("position_")};\n                ${V({attributeName:"aPosition",attributeType:e.compressedVertices?"v2":"v3",locationName:"position"})}\n\n                ${e.compressedVertices?`\n                    ${n.addObjectUniform({uniformName:"offsetVector",uniformType:"v3"})}\n                    ${n.addObjectUniform({uniformName:"quantizedVector",uniformType:"v3"})}\n                    `:""}\n        \n                ${T("normal")};\n                ${V({attributeName:"aNormal",attributeType:e.compressedNormals?"f":"v3",locationName:"normal"})}\n\n                \n                ${T("tangent")};\n                ${T("binormal")};\n                ${e.needTangentBinormalVertex||e.needTangentBinormal&&!e.gpuTangentBinormal||e.pdsfxUseTangentBinormal?`\n                    ${V({attributeName:"aTangent",attributeType:"v3",locationName:"tangent"})}\n                    ${V({attributeName:"aBinormal",attributeType:"v3",locationName:"binormal"})}\n    \n                    `:""}\n                \n                ${D("uv")};\n                ${D("uv2")};\n                ${D("uv3")};\n                ${e.useUV?`                  \n                    ${V({attributeName:"aUv",attributeType:"v4",locationName:"uv"})}\n                    ${V({attributeName:"aUv2",attributeType:"v4",locationName:"uv2"})}\n                    //${V({attributeName:"aUv3",attributeType:"v4",locationName:"uv3"})}\n                    `:""}\n\n                ${e.dashedLine?`\n                    ${_("lineDistance")} ;\n                    ${e.cpuPattern?`\n                        ${V({attributeName:"aLinePixelDistance",attributeType:"v2",locationName:"linePixelDistance"})}\n                        `:`\n                        ${V({attributeName:"aLineDistance",attributeType:"v2",locationName:"lineDistance"})}\n                        `}\n                    \n                    ${e.worldSizePattern2?`\n                        ${_("patternStartEnd")} ;\n                        ${V({attributeName:"aPatternStartEnd",attributeType:"v2",locationName:"patternStartEnd"})}\n                        `:""}\n                    `:""}\n\n                ${e.wideLine?`\n                    ${y("sideExtrusion")};\n                    ${V({attributeName:"aSideExtrusion",attributeType:"f",locationName:"sideExtrusion"})}\n\n                    ${T("previousPos")} ;\n                    ${V({attributeName:"aPreviousPos",attributeType:"v3",locationName:"previousPos"})}\n\n                    ${T("followingPos")} ;\n                    ${V({attributeName:"aFollowingPos",attributeType:"v3",locationName:"followingPos"})}\n                    `:""}\n                ${D("color")};\n                ${e.vertexColors||e.pdsfxUseVertexColors?`\n                    ${V({attributeName:"aColor",attributeType:e.compressedColors?"v2":"v4",locationName:"color"})}\n                    `:""}\n                ${e.isMultiInstanced?`\n                    ${y("instanceId")};\n                    ${F({attributeName:"aInstanceId",attributeType:"f",locationName:"instanceId"})}\n                    `:""}\n                ${e.defaultInstancing?`\n                    ${P("defaultInstancingMatrix")};\n                    ${F({attributeName:"aDefaultInstancingMatrix",attributeType:"m4",locationName:"defaultInstancingMatrix"})}\n                    `:""}\n                ${e.morphTargets?`\n                        ${T("morphTarget0")};\n                        ${V({attributeName:"aMorphTarget0",attributeType:"v3",locationName:"morphTarget0"})}\n\n                        ${T("morphTarget1")};\n                        ${V({attributeName:"aMorphTarget1",attributeType:"v3",locationName:"morphTarget1"})}\n\n                        ${T("morphTarget2")};\n                        ${V({attributeName:"aMorphTarget2",attributeType:"v3",locationName:"morphTarget2"})}\n\n                        ${T("morphTarget3")};\n                        ${V({attributeName:"aMorphTarget3",attributeType:"v3",locationName:"morphTarget3"})}\n    \n                    ${e.morphNormals?`\n                            ${T("morphNormal0")};\n                            ${V({attributeName:"aMorphNormal0",attributeType:"v3",locationName:"morphNormal0"})}\n\n                            ${T("morphNormal1")};\n                            ${V({attributeName:"aMorphNormal1",attributeType:"v3",locationName:"morphNormal1"})}\n\n                            ${T("morphNormal2")};\n                            ${V({attributeName:"aMorphNormal2",attributeType:"v3",locationName:"morphNormal2"})}\n\n                            ${T("morphNormal3")};\n                            ${V({attributeName:"aMorphNormal3",attributeType:"v3",locationName:"morphNormal3"})}\n                        `:`\n                            ${T("morphTarget4")};\n                            ${V({attributeName:"aMorphTarget4",attributeType:"v3",locationName:"morphTarget4"})}\n\n                            ${T("morphTarget5")};\n                            ${V({attributeName:"aMorphTarget5",attributeType:"v3",locationName:"morphTarget5"})}\n\n                            ${T("morphTarget6")};\n                            ${V({attributeName:"aMorphTarget6",attributeType:"v3",locationName:"morphTarget6"})}\n\n                            ${T("morphTarget7")};\n                            ${V({attributeName:"aMorphTarget7",attributeType:"v3",locationName:"morphTarget7"})}\n                        `}\n                    `:""}\n                ${e.skinning?`\n                        ${D("skinIndex")};\n                        ${V({attributeName:"aSkinIndex",attributeType:"v4",locationName:"skinIndex"})}\n\n                        ${D("skinWeight")};\n                        ${V({attributeName:"aSkinWeight",attributeType:"v4",locationName:"skinWeight"})}\n                    `:""}\n            `},attribute_vertex:function(n){var e="\n            ";return e=n.compressedVertices?`\n                    ${e}\n                    position_ = ${p("decodePosition","v3",[u(R("aPosition")),m(`${S("quantizedVector")}`),m(`${S("offsetVector")}`)])};\n                `:`\n                    ${e}\n                    position_ = ${R("aPosition")};\n                `,n.WebGPU||(e=`\n                    ${e}\n                    position = position_;\n                `),e=n.compressedNormals?`\n                    ${e}\n                    normal = ${p("decodeOct24Normal","v3",[l(R("aNormal"))])};\n                `:`\n                    ${e}\n                    normal = ${R("aNormal")};\n                `,n.useUV&&(e=n.compressedUVs?`\n                        ${e}\n                        uv = ${D()}(${p("decodeUV","v3",[u(`${R("aUv")}.xy`)])}, 0.0);\n                        ${n.WebGPU?"":`\n                            uv2 = ${D()}(${p("decodeUV","v3",[u(`${R("aUv2")}.xy`)])}, 0.0);\n                            //uv3 = ${D()}(${p("decodeUV","v3",[u(`${R("aUv3")}.xy`)])}, 0.0);\n                            `}\n                    `:`\n                        ${e}\n                        uv = ${R("aUv")};\n                        ${n.WebGPU?"":`\n                            uv2 = ${R("aUv2")};\n                            //uv3 = ${R("aUv3")};\n                            `}\n                    `),(n.vertexColors||n.pdsfxUseVertexColors)&&(e=n.compressedColors?`\n                        ${e}  \n                        color = ${p("decodeColor","v4",[u(R("aColor"))])};               \n                    `:`\n                        ${e}                 \n                        color = ${R("aColor")};\n                    `),(n.needTangentBinormalVertex||n.needTangentBinormal&&!n.gpuTangentBinormal||n.pdsfxUseTangentBinormal)&&(e=`\n                    ${e}    \n                    tangent = ${R("aTangent")};\n                    binormal = ${R("aBinormal")};\n                `),n.dashedLine&&(e=`\n                    ${e}\n                    ${n.cpuPattern?`\n                        lineDistance = ${R("aLinePixelDistance")};\n                        `:`\n                        lineDistance = ${R("aLineDistance")};\n                        `}\n                `,n.worldSizePattern2&&(e=`\n                        ${e}\n                        patternStartEnd = ${R("aPatternStartEnd")};\n                    `)),n.wideLine&&(e=`\n                    ${e}\n                    sideExtrusion = ${R("aSideExtrusion")};\n                    previousPos = ${R("aPreviousPos")};\n                    followingPos = ${R("aFollowingPos")};\n                `),n.isMultiInstanced&&(e=`\n                    ${e}\n                    instanceId = ${R("aInstanceId")};\n                `),n.defaultInstancing&&(e=`\n                    ${e}\n                    defaultInstancingMatrix = ${R("aDefaultInstancingMatrix")};\n                `),n.morphTargets&&(e=`\n                    ${e}\n                    morphTarget0 = ${R("aMorphTarget0")};\n                    morphTarget1 = ${R("aMorphTarget1")};\n                    morphTarget2 = ${R("aMorphTarget2")};\n                    morphTarget3 = ${R("aMorphTarget3")};\n                `,e=n.morphNormals?`\n                        ${e}\n                        morphNormal0 = ${R("aMorphNormal0")};\n                        morphNormal1 = ${R("aMorphNormal1")};\n                        morphNormal2 = ${R("aMorphNormal2")};\n                        morphNormal3 = ${R("aMorphNormal3")};\n                    `:`\n                        ${e}\n                        morphTarget4 = ${R("aMorphTarget4")};\n                        morphTarget5 = ${R("aMorphTarget5")};\n                        morphTarget6 = ${R("aMorphTarget6")};\n                        morphTarget7 = ${R("aMorphTarget7")};\n                    `),n.skinning&&(e=`\n                    ${e}\n                    skinIndex = ${R("aSkinIndex")};\n                    skinWeight = ${R("aSkinWeight")};\n                `),e}}}),define("DS/ShaderBuilders/ParticleBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=(n,e,t)=>s.callFunction(n,e,t),u=n=>t.addUniform(n),m=n=>{var e={uniformName:n};return t.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},c=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},p=n=>r.addVarying(n);let d=function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk;return`\n            ${`\n            #define PARTICLEBASIC\n                        \n            ${r.PDSFX_Color_pars_fragment(e)}\n            ${u({uniformName:"size",uniformType:"f"})}\n            ${r.clip_pars_fragment(e)}\n\t\t\t${r.color_pars_fragment(e)}\n\t\t\t${e.useUV?p({varyingName:"vUv",varyingType:"v4"}):""}\n            ${e.map?u({uniformName:"map",uniformType:"t2"}):""}\n            ${r.fog_pars_fragment(e)}\n\t\t\t${a.oit_pars_fragment(e)}\n\t\t\t${r.postprocess_pars_fragment(e)}\n\t\t\t${t?`\n                ${a.depth_pars_fragment(e)}\n                ${a.picking_pars_fragment(e)}\n                ${a.picking_instancing_pars_fragment(e)}\n                ${a.highlight_pars_fragment(e,!0)}\n                ${a.gpupos_pars_fragment(e)}\n                `:""}\n        `}\n            void main() {\n                ${`\n                ${e.PDSFX?`\n                    ${r.PDSFX_start_fragment(e)}\n                    INTERNAL_backup_size = ${m("size")};\n                    ${r.PDSFX_map_fragment(e)}\n                    ${r.PDSFX_Color_backup_fragment(e)}\n\t\t\t\t    ${l("ComputeCommonValues",null,[])}; \n                    ${r.PDSFX_discard_fragment(e)}\n                    ${r.PDSFX_Color_fragment(e)}\n                    `:""}\n                ${$("diffuseToUse")}  = ${e.PDSFX?"diffuse":`${m("diffuse")}`};\n                ${((n=null)=>{var e={name:n};return o.float(e)})("opacityToUse")}  = ${e.PDSFX?"opacity":`${m("opacity")}`};\n                ${e.selectionMaterial?`gl_FragColor = ${c()}( diffuseToUse, 1.0 );`:`gl_FragColor = ${c()}( diffuseToUse, opacityToUse );`}\n\n                ${r.clip_fragment(e)}\n                ${e.map?`\n                    ${c("texelColor")} = ${s.sample2DTexture("map",`${((n=null,e=0)=>{var t={name:n,size:e};return o.vec2(t)})()}( gl_PointCoord.x, 1.0 - gl_PointCoord.y )`)};\n                    ${e.gammaInput&&!e.mapHDR?`\n                        ${$("convertedColor")} = ${l("convertToLinear","v3",[(n=>i.parameterV3(n))("texelColor.rgb")])};\n                        texelColor.r = convertedColor.r;\n                        texelColor.g = convertedColor.g;\n                        texelColor.b = convertedColor.b;\n                        `:""}\n                    gl_FragColor *= texelColor;\n                    `:""}\n\t\t\t\t${r.color_fragment(e)}\n\t\t\t\t${r.alphatest_fragment(e)}\n\n                ${r.postprocess_fragment(e)}\n                ${r.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${r.PDSFX_end_fragment(e)}\n\t\t\t\t${r.fog_fragment(e)}\n\t\t\t\t${r.backgroundviewmode_lowlight_fragment(e)}\n                ${a._debug_common_lineic_fragment(e)}\n                ${a.oit_fragment_point(e)}\n\t\t\t\t${t?`\n                    ${a.depth_fragment(e)}\n                    ${a.picking_fragment(e)}\n                    ${a.picking_instancing_fragment(e)}\n                    ${a.highlight_fragment_point(e)}\n                    ${a.lineic_normal_fragment(e)}\n                    ${a.lineic_normal_depth_fragment(e)}\n                    ${a.gpupos_fragment(e)}\n                    `:""}\n        \n        `}\n            }\n        `},f=function(e,t){let a=n._ShaderChunk,o=n._DeferredShaderChunk;return`\n            ${`\n            #define PARTICLEBASIC\n\n            ${u({uniformName:"size",uniformType:"f"})}\n            ${u({uniformName:"scale",uniformType:"f"})}\n\n            ${a.clip_pars_vertex(e)}\n            ${a.color_pars_vertex(e)}\n            ${a.fog_pars_vertex(e)}\n\n            ${e.useUV?p({varyingName:"vUv",varyingType:"v4"}):""}\n\n            ${o.oit_pars_vertex(e)}\n            ${t?`\n                ${o.depth_pars_vertex(e)}\n                ${o.picking_pars_vertex(e)}\n                ${o.picking_instancing_pars_vertex(e)}\n                ${o.highlight_pars_vertex(e)}\n                ${o.gpupos_pars_vertex(e)}\n                `:""}\n        `}\n            void main() {\n                ${`\n            ${a.PDSFX_start_particle_vertex(e)}\n            ${a.PDSFX_start_vertex(e)}\n            ${e.useUV?`${(n=>r.getVarying(n,r.ShaderStages.out))("vUv")} = uv;`:""}\n            ${a.color_vertex(e)}\n            ${a.position_vertex(e)}\n            ${a.default_vertex(e)}\n            ${a.PDSFX_point_size_vertex(e)}\n            ${a.clip_vertex(e)}\n            ${a.fog_vertex(e)}\n            \n            ${o.oit_vertex_point(e)}\n            ${t?`\n                ${o.depth_vertex(e)}\n                ${o.picking_vertex(e)}\n                ${o.picking_instancing_vertex(e)}\n                ${o.highlight_vertex(e)}\n                ${o.gpupos_vertex(e)}\n                `:""}\n            ${a.PDSFX_end_vertex(e)}\n        `}\n            }\n        `};return new e(function(n,e){let t=e.isDeferredMaterial,r=d(e,t);return{vertexShader:f(e,t),fragmentShader:r}})}),define("DS/ShaderBuilders/Commons/ClipShaders",["DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r){"use strict";const a=t.ParameterUtils,o=t.FunctionHandler,i=n=>a.parameterI(n),s=n=>a.parameterV2(n),l=n=>a.parameterV3(n),u=n=>a.parameterT2(n),m=(n,e,t)=>o.declareFunction(n,e,t),$=(n,e,t)=>o.callFunction(n,e,t),c=e=>n.addClippingUniform(e),p=e=>{var t={uniformName:e};return n.getClippingUniform(t)},d=n=>e.addVarying(n),f=n=>e.getVarying(n,e.ShaderStages.in),h=n=>e.getVarying(n,e.ShaderStages.out),g=(n=null)=>{var e={name:n};return r.bool(e)},v=(n=null)=>{var e={name:n};return r.int(e)},S=(n=null)=>{var e={name:n};return r.float(e)},x=(n=null)=>{var e={name:n};return r.vec2(e)},y=(n=null)=>{var e={name:n};return r.vec3(e)};return{clip_pars_vertex:function(n){let e="";return n.clipPlanesEnabled&&(e=`\n                    ${e}\n                    ${c({uniformName:"nbClipPlanes",uniformType:"i",precision:"lowp"})}\n                    ${c({uniformName:"clipPlaneEquations",uniformType:"fv4",size:6})}\n                    ${d({varyingName:"clipDist",varyingType:"fv1",size:6})}\n\n                    ${m("getClipPlaneEquation","v4",[i("index")])}{\n                        if (index == 0) return ${p("clipPlaneEquations")}[0];\n                        if (index == 1) return ${p("clipPlaneEquations")}[1];\n                        if (index == 2) return ${p("clipPlaneEquations")}[2];\n                        if (index == 3) return ${p("clipPlaneEquations")}[3];\n                        if (index == 4) return ${p("clipPlaneEquations")}[4];\n                        if (index == 5) return ${p("clipPlaneEquations")}[5];\n                        return ${p("clipPlaneEquations")}[0];\n                    }\n                `),n.maxPolyLineSize>0&&(e=`\n                        ${e}\n                        ${d({varyingName:"extrusionPlaneUV",varyingType:"fv2",size:n.maxNbPolyLine})}\n                        ${c({uniformName:"extrusionPlaneU",uniformType:"fv3",size:n.maxNbPolyLine})}\n                        ${c({uniformName:"extrusionPlaneV",uniformType:"fv3",size:n.maxNbPolyLine})}\n                    `),n.useClippingCylinder&&(e=`\n                        ${e}\n                        ${d({varyingName:"cylinderAxisUV",varyingType:"v2"})}\n                        ${c({uniformName:"cylinderCenter",uniformType:"v3"})}\n                        ${c({uniformName:"cylinderAxisU",uniformType:"v3"})}\n                        ${c({uniformName:"cylinderAxisV",uniformType:"v3"})}\n                    `),n.maxScissorSize>0&&(e=`\n                    ${e}\n                    ${d({varyingName:"scissorClipPos",varyingType:"v4"})}\n                `),e},clip_vertex:function(n){let t="";return n.clipPlanesEnabled&&(t=`\n                    ${t}\n                    if(${p("nbClipPlanes")} > 0) {\n                        ${h("clipDist")}[ 0 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 0 ].xyz ) + ${p("clipPlaneEquations")}[ 0 ].w;\n                        ${h("clipDist")}[ 1 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 1 ].xyz ) + ${p("clipPlaneEquations")}[ 1 ].w;\n                        ${h("clipDist")}[ 2 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 2 ].xyz ) + ${p("clipPlaneEquations")}[ 2 ].w;\n                        ${h("clipDist")}[ 3 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 3 ].xyz ) + ${p("clipPlaneEquations")}[ 3 ].w;\n                        ${h("clipDist")}[ 4 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 4 ].xyz ) + ${p("clipPlaneEquations")}[ 4 ].w;\n                        ${h("clipDist")}[ 5 ] = dot( mvPosition.xyz, ${p("clipPlaneEquations")}[ 5 ].xyz ) + ${p("clipPlaneEquations")}[ 5 ].w;\n                    }\n                `),(n.maxPolyLineSize>0||n.maxScissorSize>0)&&(t=`\n                    ${t}\n                    ${y("positionWorld")} = ${$("getModelTransformation","v4",[l("vertexLocalPosition.xyz")])}.xyz;\n                `,n.maxPolyLineSize>0&&(t=`\n                        ${t}\n                        for(${v("i")} = 0; i < ${n.maxNbPolyLine}; i++) {\n                            ${h("extrusionPlaneUV")}[i] = ${x()}(dot(mvPosition.xyz, ${p("extrusionPlaneU")}[i]), dot(mvPosition.xyz, ${p("extrusionPlaneV")}[i]));\n                        }\n                    `),n.maxScissorSize>0&&(t=`\n                        ${t}\n                        ${h("scissorClipPos")} = ${(n=>e.getBuiltin(n,e.ShaderStages.out))("position")};\n                    `)),n.useClippingCylinder&&(t=`\n                    ${t}\n                    ${y("posWorldCylinder")} = ${$("getModelTransformation","v4",[l("vertexLocalPosition.xyz")])}.xyz - ${p("cylinderCenter")};\n                    ${h("cylinderAxisUV")} = ${x()}(dot(posWorldCylinder, ${p("cylinderAxisU")}), dot(posWorldCylinder, ${p("cylinderAxisV")}));\n                `),t},clip_pars_fragment:function(n){let e="";return n.clipPlanesEnabled&&(e=`\n                    ${e}\n                    ${c({uniformName:"nbClipPlanes",uniformType:"i",precision:"lowp"})}\n                    ${d({varyingName:"clipDist",varyingType:"fv1",size:6})}\n                    ${c({uniformName:"clipPlaneActive",uniformType:"iv1",size:6})}\n                    ${c({uniformName:"clipFrontOpacity",uniformType:"f",precision:"lowp"})}\n                    ${c({uniformName:"clipBackOpacity",uniformType:"f",precision:"lowp"})}\n                `),(n.maxPolyLineSize>0||n.maxScissorSize>0)&&(e=`\n                    ${e}\n                    ${m("getPolygonPoint","v2",[u("sampler"),i("size"),i("index")])}{\n                        ${S("fI")} = ${S()}(index);\n                        ${S("fS")} = ${S()}(size);\n                        ${x("coord")} = ${x()}((fI + 0.5) / fS, 0.5);\n                        return ${o.sample2DTexture("sampler","coord")}.rg;\n                    }\n\n                    ${m("isPointInsidePolygon","b",[u("sampler"),i("size"),s("point"),i("offset"),i("totalSize")])}{\n                        ${x("previousPoint")} = ${$("getPolygonPoint","v2",[u("sampler"),i("totalSize"),i("size-1+offset")])};;\n                        ${x("currentPoint")};\n                        ${g("result")} = false;\n                        for(${v("i")} =0; i < ${n.maxPolygonSize};i++) {\n                            if(i < size) {\n                                currentPoint = ${$("getPolygonPoint","v2",[u("sampler"),i("totalSize"),i("i+offset")])};\n                                if ( ((currentPoint.y>point.y) != (previousPoint.y>point.y)) &&\n                                   (point.x < (previousPoint.x-currentPoint.x) * (point.y-currentPoint.y) / (previousPoint.y-currentPoint.y) + currentPoint.x) ) {\n                                    result = !result;\n                                }\n                                previousPoint = currentPoint;\n                            }\n                        }\n                        return result;\n                    }\n                `,n.maxPolyLineSize>0&&(e=`\n                    ${e}\n                    ${c({uniformName:"polygonPoints",uniformType:"t2"})}\n                    ${c({uniformName:"polygonSize",uniformType:"iv1",size:n.maxNbPolyLine})}\n                    ${d({varyingName:"extrusionPlaneUV",varyingType:"fv2",size:n.maxNbPolyLine})}\n                    ${n.clipPlanesEnabled?"":c({uniformName:"clipBackOpacity",uniformType:"f",precision:"lowp"})}\n                `),n.maxScissorSize>0&&(e=`\n                    ${e}\n                    ${d({varyingName:"scissorClipPos",varyingType:"v4"})}\n                    ${c({uniformName:"scissorPoints",uniformType:"t2"})}\n                    ${c({uniformName:"scissorSize",uniformType:"iv1",size:n.maxNbScissor})}\n                `)),n.useClippingCylinder&&(e=`\n                    ${e}\n                    ${d({varyingName:"cylinderAxisUV",varyingType:"v2"})}\n                    ${c({uniformName:"cylinderClipZone",uniformType:"i"})}\n                `),e},clip_fragment:function(n){let e="";return n.clipPlanesEnabled&&(e=`\n                    ${e}\n                    ${S("clipOpacity")} = -1.0;\n                    if(${p("nbClipPlanes")} > 0) {\n\n                        if (0 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 0 ] < 0.0 && ${p("clipPlaneActive")}[ 0 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 0 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 0 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n\n                        if (1 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 1 ] < 0.0 && ${p("clipPlaneActive")}[ 1 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 1 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 1 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n                        \n                        if (2 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 2 ] < 0.0 && ${p("clipPlaneActive")}[ 2 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 2 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 2 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n\n                        if (3 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 3 ] < 0.0 && ${p("clipPlaneActive")}[ 3 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 3 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 3 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n\n                        if (4 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 4 ] < 0.0 && ${p("clipPlaneActive")}[ 4 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 4 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 4 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n\n                        if (5 < ${p("nbClipPlanes")} && ${f("clipDist")}[ 5 ] < 0.0 && ${p("clipPlaneActive")}[ 5 ] > 0) { clipOpacity = ${p("clipBackOpacity")}; }\n                        else if (clipOpacity == -1.0 && 5 < ${p("nbClipPlanes")} && ${p("clipPlaneActive")}[ 5 ] > 0) { clipOpacity = ${p("clipFrontOpacity")}; }\n\n                        if(clipOpacity == 0.0) discard;\n                    }\n                `),n.maxPolyLineSize>0&&(e=`\n                    ${e}\n                    ${v("offset_polygon")} = 0;\n                    ${v("totalSize_polyon")} = 0;\n                    for(${v("ipolygon")} = 0; ipolygon < ${n.maxNbPolyLine}; ipolygon++) {\n                        totalSize_polyon += ${p("polygonSize")}[ipolygon];\n                    }\n                    ${g("isInside")} = true;\n                    for(${v("ipolygon")} = 0; ipolygon < ${n.maxNbPolyLine}; ipolygon++) {\n                        ${v("size")} = ${p("polygonSize")}[ipolygon];\n                        if(size > 0) {\n                            if(!${$("isPointInsidePolygon","b",[u("polygonPoints"),i(`${p("polygonSize")}[ipolygon]`),s(`${f("extrusionPlaneUV")}[ipolygon]`),i("offset_polygon"),i("totalSize_polyon")])}) {\n                                isInside = false;\n\t\t\t\t\t\t\t\tbreak;\n                            }\n                            offset_polygon+=size;\n                        }\n                    }\n\t\t\t\t\tif(isInside) {\n                        if(${p("clipBackOpacity")} >= 0.5) {\n                            discard;\n                        }\n                    } else {\n                        if(${p("clipBackOpacity")} < 0.5) {\n                            discard;\n                        }\n                    }\n                `),n.maxScissorSize>0&&(e=`\n                    ${e}\n                    ${v("offset_scissor")} = 0;\n                    ${v("totalSize_scissor")} = 0;\n                    for(${v("iscissor")} = 0; iscissor < ${n.maxNbScissor}; iscissor++) {\n                        totalSize_scissor += ${p("scissorSize")}[iscissor];\n                    }\n                    for(${v("iscissor")} = 0; iscissor < ${n.maxNbScissor}; iscissor++) {\n                        ${v("size")} = ${p("scissorSize")}[iscissor];\n                        ${((n=null)=>{var e={name:n};return r.vec4(e)})("clipSpacePosition")} = ${f("scissorClipPos")};\n                        ${x("position2d")} = clipSpacePosition.xy / clipSpacePosition.w;\n                        if(size > 0) {\n                            if(!${$("isPointInsidePolygon","b",[u("scissorPoints"),i(`${p("scissorSize")}[iscissor]`),s("position2d"),i("offset_scissor"),i("totalSize_scissor")])}) {\n                                discard;\n                            }\n                            offset_scissor+=size;\n                        }\n                    }\n                `),n.useClippingCylinder&&(e=`\n                    ${e}\n                    if(${p("cylinderClipZone")} != 0) {\n                        ${g("isInside")} = dot(${f("cylinderAxisUV")}, ${f("cylinderAxisUV")}) <= 1.0;\n                        ${g("removeInside")} = ${p("cylinderClipZone")} < 0;\n                        if(isInside == removeInside) discard;\n                    }\n                `),e}}}),define("DS/ShaderBuilders/MeshLambertShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=n=>t.addUniform(n),s=n=>{var e={uniformName:n};return t.getUniform(e)},l=n=>t.addLightUniform(n),u=n=>{var e={uniformName:n};return t.getLightUniform(e)},m=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},$=(n=null)=>{var e={name:n};return o.int(e)},c=(n=null)=>{var e={name:n};return o.float(e)},p=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},f=n=>r.addVarying(n),h=n=>r.getVarying(n,r.ShaderStages.in),g=n=>r.getVarying(n,r.ShaderStages.out);let v=function(e,t){let r=n._ShaderChunk,i=n._DeferredShaderChunk;return`\n            ${`\n            #define LAMBERT\n\n            ${r.PDSFX_Color_pars_fragment(e)}\n            ${f({varyingName:"vLightFront",varyingType:"v3"})}\n            ${f({varyingName:"vLightBack",varyingType:"v3"})}\n\t\t\t${e.useUV?`${((n=null)=>{var e={name:n};return o.vec2(e)})("uvToUse")} ;`:""}          \n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n            ${r.clip_pars_fragment(e)}\n\t\t\t${r.color_pars_fragment(e)}\n\t\t\t${r.map_pars_fragment(e)}\n\t\t\t${r.envmap_pars_fragment(e)}\n\t\t\t${t?"":r.shadowmap_pars_fragment(e)}\n\t\t\t${r.specularmap_pars_fragment(e)}\n            ${r.fog_pars_fragment(e)}\n\t\t\t${r.ao_pars_fragment(e)}\n\t\t\t${i.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${i.depth_pars_fragment(e)}\n                ${i.picking_pars_fragment(e)}\n                ${i.picking_instancing_pars_fragment(e)}\n                ${i.decal_normal_depth_pars_fragment(e)}\n                ${i.shadowmap_pars_fragment(e)}\n                ${i.highlight_pars_fragment(e,!1)}\n                ${i.texcoord_pars_fragment(e)}\n                ${i.gpupos_pars_fragment(e)}\n                `:""}\n\t\t\t${r.postprocess_pars_fragment(e)}\n        `}\n            void main() {\n                ${`\n                ${e.PDSFX?`\n                    ${r.PDSFX_start_fragment(e)}\n                    ${r.PDSFX_map_fragment(e)}\n                    ${r.PDSFX_mapping_fragment(e)}\n                    ${r.PDSFX_Color_backup_fragment(e)}\n\t\t\t\t    ${((n,e,t)=>a.FunctionHandler.callFunction(n,e,t))("ComputeCommonValues","f",[])}; \n                    ${r.PDSFX_discard_fragment(e)}\n                    ${r.PDSFX_Color_fragment(e)}\n                    ${r.PDSFX_viewNormal_fragment(e)}\n                    ${r.PDSFX_viewPosition_fragment(e)}\n                    `:""}\n                ${c("opacityToUse")}  = ${e.PDSFX?"opacity":`${s("opacity")}`};\n                ${e.selectionMaterial?`gl_FragColor = ${d()}( 1.0 );`:`gl_FragColor = ${d()}( 1.0, 1.0, 1.0, opacityToUse );`}\n\n                ${e.useUV?`uvToUse = ${h("vUv")}.xy;`:""}\n                ${n._DefaultShaderChunk.normal_viewposition_fragment(e)}\n\n                ${r.clip_fragment(e)}\n                ${r.uvmapping_fragment(e)}\n                ${r.map_fragment(e)}\n\t\t\t\t${r.color_fragment(e)}\n\t\t\t\t${r.alphatest_fragment(e)}\n\t\t\t\t${r.specularmap_fragment(e)}\n\n                if (gl_FrontFacing) {\n                    gl_FragColor.x *= ${h("vLightFront")}.x;\n                    gl_FragColor.y *= ${h("vLightFront")}.y;\n                    gl_FragColor.z *= ${h("vLightFront")}.z;\n                } else {\n                    gl_FragColor.x *= ${h("vLightBack")}.x;\n                    gl_FragColor.y *= ${h("vLightBack")}.y;\n                    gl_FragColor.z *= ${h("vLightBack")}.z;\n                }\n\n\t\t\t\t${r.envmap_fragment(e)}\n\t\t\t\t${t?"":r.shadowmap_fragment_old(e)}\n               \n\t\t\t\t${r.ao_fragment(e)}\n\t\t\t\t${r.postprocess_fragment(e)}\n\t\t\t\t${r.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${r.PDSFX_end_fragment(e)}\n\t\t\t\t${r.fog_fragment(e)}\n\t\t\t\t${r.backgroundviewmode_lowlight_fragment(e)}\n                ${i._debug_common_face_fragment(e)}\n\n                ${i.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${i.depth_fragment_face(e)}\n                    ${i.picking_fragment(e)}\n                    ${i.picking_instancing_fragment(e)}\n                    ${i.highlight_fragment_face(e)}\n                    ${i.normal_fragment(e)}\n                    ${i.normal_depth_fragment(e)}\n                    ${i.shadowmap_fragment(e)}\n                    ${i.texcoord_fragment(e)}\n                    ${i.gpupos_fragment(e)}\n                    `:""}\n        \n        `}\n            }\n        `};return new e(function(e,t){let r=t.isDeferredMaterial,a=v(t,r);return{vertexShader:function(e,t){let r=n._ShaderChunk,a=n._DeferredShaderChunk,o=`\n            ${i({uniformName:"ambient",uniformType:"v3"})}\n            ${i({uniformName:"diffuse",uniformType:"v3"})}\n            ${i({uniformName:"emissive",uniformType:"v3"})}\n\n            ${l({uniformName:"ambientLightColor",uniformType:"v4"})}\n\n            ${e.wrapAround?i({uniformName:"wrapRGB",uniformType:"v3"}):""}\n\n            ${!t&&e.maxDirLights?`\n                ${l({uniformName:"directionalLightColor",uniformType:"fv4",size:e.maxDirLights})}\n                ${l({uniformName:"directionalLightDirection",uniformType:"fv4",size:e.maxDirLights})}\n                `:""}\n            ${!t&&e.maxPointLights?`\n                ${l({uniformName:"pointLightColor",uniformType:"fv4",size:e.maxPointLights})}\n                ${l({uniformName:"pointLightPosition",uniformType:"fv4",size:e.maxPointLights})}\n                `:""}\n            ${!t&&e.maxSpotLights?`\n                ${l({uniformName:"spotLightColor",uniformType:"fv4",size:e.maxSpotLights})}\n                ${l({uniformName:"spotLightPosition",uniformType:"fv4",size:e.maxSpotLights})}\n                ${l({uniformName:"spotLightDirection",uniformType:"fv4",size:e.maxSpotLights})}\n                `:""}\n        `,h=`\n            ${g("vLightFront")} = ${p()}( 0.0 );\n            ${g("vLightBack")} = ${p()}( 0.0 );\n\n            transformedNormal = normalize( transformedNormal );\n\n            ${!t&&e.maxDirLights?`\n                for( ${$("i")} = 0; i < ${e.maxDirLights}; i ++ ) {\n                    ${d("lDirection")}  = ${m("viewMatrix")} * ${d()}( ${u("directionalLightDirection")}[ i ].xyz, 0.0 );\n                    ${p("dirVector")}  = normalize( lDirection.xyz );\n\n                    ${c("dotProduct")}  = dot( transformedNormal, dirVector );\n                    ${p("directionalLightWeighting")}  = ${p()}( max( dotProduct, 0.0 ) );\n                    ${p("directionalLightWeightingBack")}  = ${p()}( max( -dotProduct, 0.0 ) );\n\n                    ${e.wrapAround?`\n                        ${p("directionalLightWeightingHalf")}  = ${p()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                        ${p("directionalLightWeightingHalfBack")}  = ${p()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                        directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, ${s("wrapRGB")} );\n                        directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, ${s("wrapRGB")} );\n                        `:""}\n\n                    ${g("vLightFront")} += ${u("directionalLightColor")}[ i ].xyz * directionalLightWeighting;\n                    ${g("vLightBack")} += ${u("directionalLightColor")}[ i ].xyz * directionalLightWeightingBack;\n                }\n                `:""}\n            ${!t&&e.maxPointLights?`\n                for( ${$("i")} = 0; i < ${maxPointLights}; i ++ ) {\n                    ${d("lPosition")}  = ${m("viewMatrix")} * ${d()}( ${u("pointLightPosition")}[ i ].xyz, 1.0 )\n                    ${p("lVector")}  = lPosition.xyz - mvPosition.xyz;\n\n                    ${c("lDistance")}  = 1.0;\n\n                    if ( ${u("pointLightPosition")}[ i ].w > 0.0 ) {\n                        lDistance = 1.0 - min( ( length( lVector ) / ${u("pointLightPosition")}[ i ].w ), 1.0 );\n                    }\n\n                    lVector = normalize( lVector );\n                    ${c("dotProduct")}  = dot( transformedNormal, lVector );\n                    ${p("pointLightWeighting")}  = ${p()}( max( dotProduct, 0.0 ) );\n                    ${p("pointLightWeightingBack")}  = ${p()}( max( -dotProduct, 0.0 ) );\n                    ${e.wrapAround?`\n                        ${p("pointLightWeightingHalf")}  = ${p()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                        ${p("pointLightWeightingHalfBack")}  = ${p()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, ${s("wrapRGB")} );\n                        pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, ${s("wrapRGB")} );\n                        `:""}\n                    ${g("vLightFront")} += ${u("pointLightColor")}[ i ].xyz * pointLightWeighting * lDistance;\n                    ${g("vLightBack")} += ${u("pointLightColor")}[ i ].xyz * pointLightWeightingBack * lDistance;\n                }\n                `:""}\n            ${!t&&e.maxSpotLights?`\n                for( ${$("i")} = 0; i < ${e.maxSpotLights}; i ++ ) {\n                    ${d("lPosition")}  = ${m("viewMatrix")} * ${d()}(  ${u("spotLightPosition")}[ i ].xyz, 1.0 );\n                    ${p("lVector")}  = lPosition.xyz - mvPosition.xyz;\n\n                    ${c("spotEffect")}  = dot( ${u("spotLightDirection")}[ i ].xyz, normalize( ${u("spotLightPosition")}[ i ].xyz - worldPosition.xyz ) );\n\n                    if ( spotEffect > ${u("spotLightPosition")}[ i ].w ) {\n                        spotEffect = 1.0 - smoothstep( ${u("spotLightDirection")}[ i ].w,${u("spotLightPosition")}[ i ].w,spotEffect );\n                        ${c("lDistance")}  = 1.0;\n                        if ( ${u("spotLightColor")}[ i ].w > 0.0 ) {\n                            lDistance = 1.0 - min( ( length( lVector ) / ${u("spotLightColor")}[ i ].w ), 1.0 );\n                        }\n                        lVector = normalize( lVector );\n                        ${c("dotProduct")}  = dot( transformedNormal, lVector );\n                        ${p("spotLightWeighting")}  = ${p()}( max( dotProduct, 0.0 ) );\n                        ${p("spotLightWeightingBack")}  = ${p()}( max( -dotProduct, 0.0 ) );\n                        ${e.wrapAround?`\n                            ${p("spotLightWeightingHalf")}  = ${p()}( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                            ${p("spotLightWeightingHalfBack")}  = ${p()}( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n                            spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, ${s("wrapRGB")} );\n                            spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, ${s("wrapRGB")} );\n                            `:""}\n                        ${g("vLightFront")} += ${u("spotLightColor")}[ i ].xyz * spotLightWeighting * lDistance * spotEffect;\n                        ${g("vLightBack")} +=  ${u("spotLightColor")}[ i ].xyz * spotLightWeightingBack * lDistance * spotEffect;\n                    }\n                }\n                `:""}\n\n            ${g("vLightFront")} = ${g("vLightFront")}  * ${s("diffuse")} + ${s("ambient")} * ${u("ambientLightColor")}.xyz + ${s("emissive")};\n            ${g("vLightBack")}  = ${g("vLightBack")} * ${s("diffuse")} + ${s("ambient")} * ${u("ambientLightColor")}.xyz + ${s("emissive")};\n        `;return`\n            ${`\n            #define LAMBERT\n            ${f({varyingName:"vLightFront",varyingType:"v3"})}\n            ${f({varyingName:"vLightBack",varyingType:"v3"})}\n\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n\n            ${r.clip_pars_vertex(e)}\n            ${r.map_pars_vertex(e)}\n            ${r.envmap_pars_vertex(e)}\n            ${o}\n            ${r.color_pars_vertex(e)}\n            ${r.morphtarget_pars_vertex(e)}\n            ${r.skinning_pars_vertex(e)}\n            ${t?"":r.shadowmap_pars_vertex(e)}\n            ${r.fog_pars_vertex(e)}\n\n            ${a.oit_pars_vertex(e)}\n            ${t?`\n                ${a.depth_pars_vertex(e)}\n                ${a.picking_pars_vertex(e)}\n                ${a.picking_instancing_pars_vertex(e)}\n                ${a.highlight_pars_vertex(e)}\n                ${a.texcoord_pars_vertex(e)}\n                ${a.gpupos_pars_vertex(e)}\n                `:""}\n        `}\n            void main() {\n                ${`\n            ${r.PDSFX_start_vertex(e)}\n\n            ${r.map_vertex(e)}\n            ${r.color_vertex(e)}\n\n            ${r.morphtarget_vertex(e)}  \n            ${r.morphnormal_vertex(e)}\n\n            ${r.skinbase_vertex(e)}\n            ${r.skinning_vertex(e)}  \n            ${r.skinnormal_vertex(e)}  \n            ${r.position_vertex(e)}\n\n            ${r.default_vertex_with_normal(e)}\n            ${r.defaultnormal_vertex(e)}\n\n            ${r.clip_vertex(e)}\n            ${r.fog_vertex(e)}\n\n            ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n       \n            ${r._worldpos_vertex(e)}\n            ${r.envmap_vertex(e)}\n            ${h}\n            ${t?"":r.shadowmap_vertex(e)}\n            \n            ${a.oit_vertex(e)}\n            ${t?`\n                ${a.depth_vertex(e)}\n                ${a.picking_vertex(e)}\n                ${a.picking_instancing_vertex(e)}\n                ${a.highlight_vertex(e)}\n                ${a.texcoord_vertex(e)}\n                ${a.gpupos_vertex(e)}\n                `:""}\n            ${r.PDSFX_end_vertex(e)}\n        `}\n            }\n        `}(t,r),fragmentShader:a}})}),define("DS/ShaderBuilders/FiniteTransitionEnvMapShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=n=>i.parameterF(n),u=n=>i.parameterV2(n),m=n=>i.parameterV3(n),$=n=>i.parameterT2(n),c=(n,e,t)=>s.declareFunction(n,e,t),p=(n,e,t)=>s.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},g=(n=null)=>{var e={name:n};return o.float(e)},v=(n=null)=>{var e={name:n};return o.vec2(e)},S=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},y=(n=null)=>{var e={name:n};return o.mat4(e)},_=n=>{var e={name:n,constant:!0};return o.float(e)},T=n=>r.addVarying(n),D=n=>r.getVarying(n,r.ShaderStages.in),C=n=>r.getVarying(n,r.ShaderStages.out);return new e(function(e,t){let r=n._ShaderChunk,a=n._DefaultShaderChunk,o=`\n            #define FINITE_TRANSITION\n            ${t.useLatLongMap?`\n                ${d({uniformName:"tEnvMap",uniformType:"t2"})}\n                ${d({uniformName:"tEnvMap2",uniformType:"t2"})}\n                `:`\n                ${d({uniformName:"tEnvMap",uniformType:"tc"})}\n                ${d({uniformName:"tEnvMap2",uniformType:"tc"})}\n                `}\n\n            ${d({uniformName:"transitionCoef",uniformType:"f"})}\n            ${d({uniformName:"envMapExposure",uniformType:"f"})}\n            ${d({uniformName:"ambient",uniformType:"v3"})}\n            ${d({uniformName:"groundRadius",uniformType:"f"})}\n            ${d({uniformName:"groundRadius2",uniformType:"f"})}\n            ${d({uniformName:"groundScale",uniformType:"f"})}\n            ${d({uniformName:"groundScale2",uniformType:"f"})}\n            ${d({uniformName:"ambienceMatrix",uniformType:"m4"})}\n            ${d({uniformName:"ambienceMatrix2",uniformType:"m4"})}\n\n            ${T({varyingName:"vViewPosition",varyingType:"v3"})}\n            ${T({varyingName:"vViewGroundPosition",varyingType:"v3"})}\n            ${T({varyingName:"vViewGroundPosition2",varyingType:"v3"})}\n\n            ${_("PI")} = 3.14159;\n            ${_("INV_PI")} = 0.31830988618;\n\n            ${t.useHDR&&!t.useHDRFloat?`\n                ${d({uniformName:"envMapHDRSize",uniformType:"v2"})}\n                ${d({uniformName:"envMapHDRSize2",uniformType:"v2"})}\n                ${a.rgbe_sample_methods(t)}\n                `:""}\n\n            ${c("MapNormalToTextureCoordinate","v2",[m("iNormal")])} {\n                ${g("phi")}  = atan(iNormal.y, iNormal.x);\n                ${g("theta")}  = acos(iNormal.z);\n                return ${v()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n            }\n\n            ${c("IntersectSphereFar","f",[m("iSphereCenter"),l("iSphereRadius"),m("iRayDir")])} {\n                ${g("B")}   = 2.0*dot(iRayDir, -iSphereCenter);\n                ${g("C")}   = dot(iSphereCenter, iSphereCenter) - iSphereRadius*iSphereRadius;\n                ${g("disc")}   = B*B - 4.0*C;\n                if (disc < 0.0) return -1.0;\n                return  (-B + sqrt(disc)) / 2.0;\n            }\n\n            ${r.postprocess_pars_fragment(t)}\n\n            ${c("getN","v3",[m("isphereCenter"),l("isphereRadius"),m("inRay")])}{\n                ${S("rayDir")}       = inRay;\n                ${g("t")} =  ${p("IntersectSphereFar","f",[m("isphereCenter"),l("isphereRadius"),m("rayDir")])};\n                if (t>0.0) {\n                    ${S("hitPos")}  =  t*rayDir;\n                    ${S("sn")}  = (hitPos - isphereCenter);\n                    rayDir = normalize(sn);\n                }\n                return rayDir;\n            }\n            \n            void main() {\n                ${S("viewRay")}  = normalize(${D("vViewPosition")});\n                ${S("viewSphereCenter")}   = ${D("vViewGroundPosition")};\n                ${S("viewSphereCenter2")}   = ${D("vViewGroundPosition2")};\n\n                ${g("sphereRadius")}   = ${f("groundRadius")} * ${f("groundScale")};\n                ${g("sphereRadius2")}   = ${f("groundRadius2")} * ${f("groundScale2")};\n\n                ${S("viewN")}  = ${p("getN","v3",[m("viewSphereCenter"),l("sphereRadius"),m("viewRay")])};\n                ${S("viewN2")}  = ${p("getN","v3",[m("viewSphereCenter2"),l("sphereRadius2"),m("viewRay")])};\n\n\t\t\t\t${S("n")}  = (${x()}(viewN,0.0)*${h("viewMatrix")}).xyz;\n                ${S("n2")}  = (${x()}(viewN2,0.0)*${h("viewMatrix")}).xyz;\n\n                n = (${f("ambienceMatrix")} * ${x()}(n, 0.0)).xyz;\n                n2 = (${f("ambienceMatrix2")} * ${x()}(n2, 0.0)).xyz;\n\n                ${S("mapColor")};\n                ${t.useLatLongMap?`\n                    ${t.useHDR?"":"n.y *= -1.0;n2.y *= -1.0;"}\n                    ${v("coords")}  = ${p("MapNormalToTextureCoordinate","v2",[m("n")])};\n                    ${v("coords2")}  = ${p("MapNormalToTextureCoordinate","v2",[m("n2")])};\n                    ${t.useHDR&&!t.useHDRFloat?`\n                        ${v("texelSize")}  = 1.0 / ${f("envMapHDRSize")};\n                        ${v("texelSize2")}  = 1.0 / ${f("envMapHDRSize2")};\n                        ${S("c1")} = ${p("texture2DBilinearFromRGBE","v4",[$("tEnvMap"),u("coords"),u(`${f("envMapHDRSize")}`),u("texelSize")])}.xyz;\n                        ${S("c2")} = ${p("texture2DBilinearFromRGBE","v4",[$("tEnvMap2"),u("coords2"),u(`${f("envMapHDRSize2")}`),u("texelSize2")])}.xyz;\n                        mapColor = c2*${f("transitionCoef")}+c1*(1.0-${f("transitionCoef")});\n                        `:`\n                        ${S("c1")} = ${s.sample2DTexture("tEnvMap","coords")}.xyz;\n                        ${S("c2")} = ${s.sample2DTexture("tEnvMap2","coords2")}.xyz;\n                        mapColor = c2*${f("transitionCoef")}+c1*(1.0-${f("transitionCoef")});\n                        `}\n                    `:`\n                    ${S("c1")} = ${s.sampleCubeTexture("tEnvMap",`${S()}(n.x, -n.z,n.y)`)}.xyz;\n                    ${S("c2")} = ${s.sampleCubeTexture("tEnvMap2",`${S()}(n2.x, -n2.z,n2.y)`)}.xyz;\n                    mapColor = c2*${f("transitionCoef")}+c1*(1.0-${f("transitionCoef")});\n                    `}\n                gl_FragColor.x = mapColor.x;\n                gl_FragColor.y = mapColor.y;\n                gl_FragColor.z = mapColor.z;\n                gl_FragColor.w = 1.0;\n                ${!t.gammaOutput&&t.useSRGB?`\n                    ${S("convertedColor")} = ${p("convertToLinear","v3",[m("gl_FragColor.xyz")])};\n                    gl_FragColor.x = convertedColor.x;\n                    gl_FragColor.y = convertedColor.y;\n                    gl_FragColor.z = convertedColor.z;\n                    `:""}\n                gl_FragColor *= ${x()}(${f("ambient")} * ${f("envMapExposure")}, 1.0);\n                ${r.postprocess_fragment(t)}\n                ${t.gammaOutput&&t.useHDR?r.linear_to_gamma_fragment(t):""}\n            }\n        `;return{vertexShader:`\n            #define FINITE_TRANSITION\n\n\t\t\t${d({uniformName:"groundPosition",uniformType:"v3"})}\n            ${d({uniformName:"groundPositionLowPart",uniformType:"v3"})}\n            ${d({uniformName:"groundPosition2",uniformType:"v3"})}\n            ${d({uniformName:"groundPosition2LowPart",uniformType:"v3"})}\n\n            ${T({varyingName:"vViewPosition",varyingType:"v3"})}\n            ${T({varyingName:"vViewGroundPosition",varyingType:"v3"})}\n            ${T({varyingName:"vViewGroundPosition2",varyingType:"v3"})}\n\n\t\t\t${c("getViewFromWorldPosition","v3",[m("worldPos"),m("worldPosLowPart")])}{\n                ${y("mat")} = ${y()}(1.0);\n                mat[3][0]=worldPos.x;\n                mat[3][1]=worldPos.y;\n                mat[3][2]=worldPos.z;\n                ${S("origin")} = ${S()}(0.0);\n\t\t\t\treturn ${p("computeModelViewPositionCustom","v4",[m("origin"),((n,e,t=!1)=>i.parameter(n,e,t))("m4","mat"),m("worldPosLowPart")])}.xyz;\n            }\n\n            void main() {\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n\t\t\t\t${C("vViewPosition")} = ${p("computeModelViewPosition","v4",[m("position_")])}.xyz;\n\t\t\t\t${C("vViewGroundPosition")} = ${p("getViewFromWorldPosition","v3",[m("groundPosition"),m("groundPositionLowPart")])};\n\t\t\t\t${C("vViewGroundPosition2")} = ${p("getViewFromWorldPosition","v3",[m("groundPosition2"),m("groundPosition2LowPart")])};\n            }\n        `,fragmentShader:o}})}),define("DS/ShaderBuilders/PDSFXShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";class o{constructor(){}reference(){return a.reference()}dereference(){return a.dereference()}createStructure({name:n=null,size:e=0,constant:t=!1,structName:r}){return a.createStructure({name:n,size:e,constant:t,structName:r})}declareStructure({structName:n,attributes:e=[]}){return a.declareStructure({structName:n,attributes:e})}}{const n=["bool","bvec2","bvec3","bvec4","int","ivec2","ivec3","ivec4","float","vec2","vec3","vec4","mat2","mat3","mat4"];function i(n){o.prototype[n]=function(e=null,t=0){let r={name:e,size:t,constant:!1};return a[n](r)},o.prototype[n+"C"]=function(e=null,t=0){let r={name:e,size:t,constant:!0};return a[n](r)}}for(let e=0;e<n.length;e++){i(n[e])}}class s{constructor(){}declareFunction(n,e,t){return n="CustomPDSFX"+n,r.FunctionHandler.declareFunction(n,e,t)}callFunction(n,e,t){return n="CustomPDSFX"+n,r.FunctionHandler.callFunction(n,e,t)}dF(n,e,t){return n="CustomPDSFX"+n,r.FunctionHandler.declareFunction(n,e,t)}cF(n,e,t){return n="CustomPDSFX"+n,r.FunctionHandler.callFunction(n,e,t)}sample2DTexture(n,e){return r.FunctionHandler.sample2DTexture(n,e)}sampleCubeTexture(n,e){return r.FunctionHandler.sampleCubeTexture(n,e)}}{const n=["B","F","I","V2","V3","V4","M2","M3","M4","TC","T2"];function i(n){r.ParameterUtils["parameter"+n]&&(s.prototype["parameter"+n]=function(e){return r.ParameterUtils["parameter"+n](e)},s.prototype["prm"+n]=function(e){return r.ParameterUtils["parameter"+n](e)}),r.ParameterUtils["parameterInOut"+n]&&(s.prototype["parameterInOut"+n]=function(e){return r.ParameterUtils["parameterInOut"+n](e)},s.prototype["prmIO"+n]=function(e){return r.ParameterUtils["parameterInOut"+n](e)}),r.ParameterUtils["parameterRef"+n]&&(s.prototype["parameterRef"+n]=function(e){return r.ParameterUtils["parameterRef"+n](e)},s.prototype["prmRef"+n]=function(e){return r.ParameterUtils["parameterRef"+n](e)})}for(let e=0;e<n.length;e++){i(n[e])}}const l=new s,u=new o;class m{constructor(){this.userDefines=null,this.pdsfxDefines=null,this.__internalOptions__=null}_initContext(n,e,t){this.userDefines={},Object.assign(this.userDefines,n),this.pdsfxDefines=e,this.__internalOptions__=t}_throw(){if(!this.__internalOptions__)throw"Invalid Operation"}getTextureUniform(n){return this._throw(),e.getPDSFXTextureUniform({uniformName:n})}getUniform(n){return this._throw(),e.getPDSFXUniform({uniformName:n})}vGetWorldViewMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetWorldViewMatrix","m4",[])}vGetWorldViewInvTranspMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetWorldViewInvTranspMatrix","m4",[])}vGetViewMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetViewMatrix","m4",[])}vGetProjectionMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetProjectionMatrix","m4",[])}vGetViewProjectionMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetViewProjectionMatrix","m4",[])}vGetViewInvMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetViewInvMatrix","m4",[])}vGetProjectionInvMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetProjectionInvMatrix","m4",[])}vGetViewProjectionInvMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetViewProjectionInvMatrix","m4",[])}viewInvTranspMatrix(){return this._throw(),r.FunctionHandler.callFunction("viewInvTranspMatrix","m4",[])}vGetTextureMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGetTextureMatrix","m4",[])}vGetWorldEyePos(){return this._throw(),r.FunctionHandler.callFunction("vGetWorldEyePos","v3",[])}vGetLowlightColor(){return this._throw(),r.FunctionHandler.callFunction("vGetLowlightColor","v3",[])}vGetDefaultPointSize(){return this._throw(),r.FunctionHandler.callFunction("vGetDefaultPointSize","f",[])}vGetNearFarLogFactor(){return this._throw(),r.FunctionHandler.callFunction("vGetNearFarLogFactor","v3",[])}vGetViewportSize(){return this._throw(),r.FunctionHandler.callFunction("vGetViewportSize","i2",[])}vGet3x3WorldMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGet3x3WorldMatrix","m3",[])}vGet3x3WorldInvTranspMatrix(){return this._throw(),r.FunctionHandler.callFunction("vGet3x3WorldInvTranspMatrix","m3",[])}get variableHandler(){return this._throw(),u}get functionHandler(){return this._throw(),l}dispose(){this.userDefines=null,this.pdsfxDefines=null,this.__internalOptions__=null}}return{Vertex:class extends m{constructor(){super()}getVarying(n){return this._throw(),t.getPDSFXVarying(n,t.ShaderStages.out)}vGetAttribPosition(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribPosition","v3",[])}vGetAttribPreviousPosition(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribPreviousPosition","v3",[])}vGetAttribFollowingPosition(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribFollowingPosition","v3",[])}vGetAttribNormal(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribNormal","v3",[])}vGetAttribColor(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribColor","v3",[])}_vGetAttribColorAlpha(){return this._throw(),r.FunctionHandler.callFunction("_vGetAttribColorAlpha","f",[])}vGetAttribTexCoord0(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribTexCoord0","v4",[])}vGetAttribTexCoord1(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribTexCoord1","v4",[])}vGetAttribTexCoord2(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribTexCoord2","v4",[])}vGetAttribTangent(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribTangent","v3",[])}vGetAttribBinormal(){return this._throw(),r.FunctionHandler.callFunction("vGetAttribBinormal","v3",[])}vGetHalfWidth(){return this._throw(),r.FunctionHandler.callFunction("vGetHalfWidth","f",[])}},Fragment:class extends m{constructor(){super()}getVarying(n){return this._throw(),t.getPDSFXVarying(n,t.ShaderStages.in)}vGetFragCoord(){return this._throw(),r.FunctionHandler.callFunction("vGetFragCoord","v4",[])}vSetFragDepth(n){return this._throw(),r.FunctionHandler.callFunction("vSetFragDepth",null,[r.ParameterUtils.parameterF(n)])}vIsFrontFacing(){return this._throw(),r.FunctionHandler.callFunction("vIsFrontFacing","b",[])}vGetPointCoord(){return this._throw(),r.FunctionHandler.callFunction("vGetPointCoord","v2",[])}vGetViewPosition(){return this._throw(),r.FunctionHandler.callFunction("vGetViewPosition","v3",[])}vGetViewNormal(){return this._throw(),r.FunctionHandler.callFunction("vGetViewNormal","v3",[])}vGetViewTangent(){return this._throw(),r.FunctionHandler.callFunction("vGetViewTangent","v3",[])}vGetViewBinormal(){return this._throw(),r.FunctionHandler.callFunction("vGetViewBinormal","v3",[])}vGetTexCoord0(){return this._throw(),r.FunctionHandler.callFunction("vGetTexCoord0","v4",[])}vGetTexCoord1(){return this._throw(),r.FunctionHandler.callFunction("vGetTexCoord1","v4",[])}vGetTexCoord2(){return this._throw(),r.FunctionHandler.callFunction("vGetTexCoord2","v4",[])}vGetClipSpacePosition(){return this._throw(),r.FunctionHandler.callFunction("vGetClipSpacePosition","v4",[])}vGetHalfWidth(){return this._throw(),r.FunctionHandler.callFunction("vGetHalfWidth","f",[])}vGetOpacity(){return this._throw(),r.FunctionHandler.callFunction("vGetOpacity","f",[])}vGetTranslucency(){return this._throw(),r.FunctionHandler.callFunction("vGetTranslucency","f",[])}vGetThickness(){return this._throw(),r.FunctionHandler.callFunction("vGetThickness","f",[])}vGetTransparency(){return this._throw(),r.FunctionHandler.callFunction("vGetTransparency","f",[])}vGetRoughness(){return this._throw(),r.FunctionHandler.callFunction("vGetRoughness","f",[])}vGetClearcoat(){return this._throw(),r.FunctionHandler.callFunction("vGetClearcoat","f",[])}vGetClearcoatRoughness(){return this._throw(),r.FunctionHandler.callFunction("vGetClearcoatRoughness","f",[])}vGetFlakeCoverage(){return this._throw(),r.FunctionHandler.callFunction("vGetFlakeCoverage","f",[])}vGetFlakeRoughness(){return this._throw(),r.FunctionHandler.callFunction("vGetFlakeRoughness","f",[])}vGetFlakeSize(){return this._throw(),r.FunctionHandler.callFunction("vGetFlakeSize","f",[])}vGetFlipFlop(){return this._throw(),r.FunctionHandler.callFunction("vGetFlipFlop","f",[])}vGetSheen(){return this._throw(),r.FunctionHandler.callFunction("vGetSheen","f",[])}vGetSheenRoughness(){return this._throw(),r.FunctionHandler.callFunction("vGetSheenRoughness","f",[])}vGetMetallic(){return this._throw(),r.FunctionHandler.callFunction("vGetMetallic","f",[])}vGetSpecular(){return this._throw(),r.FunctionHandler.callFunction("vGetSpecular","f",[])}vGetAnisotropy(){return this._throw(),r.FunctionHandler.callFunction("vGetAnisotropy","f",[])}vGetAnisotropyRotation(){return this._throw(),r.FunctionHandler.callFunction("vGetAnisotropyRotation","f",[])}vGetIridescence(){return this._throw(),r.FunctionHandler.callFunction("vGetIridescence","f",[])}vGetIridescenceThickness(){return this._throw(),r.FunctionHandler.callFunction("vGetIridescenceThickness","f",[])}vGetEmissive(){return this._throw(),r.FunctionHandler.callFunction("vGetEmissive","v3",[])}vGetSpecularReflectance(){return this._throw(),r.FunctionHandler.callFunction("vGetSpecularReflectance","v3",[])}vGetAlbedo(){return this._throw(),r.FunctionHandler.callFunction("vGetAlbedo","v3",[])}vGetClearcoatColor(){return this._throw(),r.FunctionHandler.callFunction("vGetClearcoatColor","v3",[])}vGetTranslucencyColor(){return this._throw(),r.FunctionHandler.callFunction("vGetTranslucencyColor","v3",[])}vGetFlakeColor(){return this._throw(),r.FunctionHandler.callFunction("vGetFlakeColor","v3",[])}vGetFlipFlopColor(){return this._throw(),r.FunctionHandler.callFunction("vGetFlipFlopColor","v3",[])}vGetSheenColor(){return this._throw(),r.FunctionHandler.callFunction("vGetSheenColor","v3",[])}}}}),define("DS/ShaderBuilders/PostPro/PostProContext",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder"],function(n,e){"use strict";return class{constructor(n,t,r,a=0){if(!(n instanceof e))throw"Invalid Operation Exception: shaderBuilder must be of type ShaderBuilder";this._shaderBuilder=n,this._uniformHandler=t,this._defines={},Object.assign(this._defines,r),this._extraInput=a}getShaderBuilder(){return this._shaderBuilder}getUniformHandler(){return new this._uniformHandler(this._extraInput)}getDefines(){var n={};return Object.assign(n,this._defines),n}}}),define("DS/ShaderBuilders/PostPro/PostProUniformHandler",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder"],function(n,e){"use strict";return class{constructor(n=0,e=!1){this.inputs=[];for(let t=0;t<n+1;t++)this.inputs.push({name:"tInput"+(0!==t||0!==n||e?t:""),value:null,linked:!1})}loadUniforms(n,e,t,r,a,o,i){for(let n=0;n<this.inputs.length;n++){var s=this.inputs[n];if(r[s.name]){const n=s.value?s.value:e._dummyTexture;e.loadTexture(t,r[s.name],n)}}}getInput(n=0){return n>=0&&n<this.inputs.length?this.inputs[n]:null}setInput(n,e=0){let t=this.getInput(e);t&&!t.linked&&(t.value=n)}setLinkedInput(n,e){let t=this.getInput(e);t&&(t.value=n,t.linked=!0)}clone(){throw"Not Implemented Exception"}}}),define("DS/ShaderBuilders/PostPro/MSAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=n=>a.addUniform(n),m=n=>{var e={uniformName:n};return a.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},d=n=>o.addVarying(n),f=n=>o.getVarying(n,o.ShaderStages.in),h=n=>o.getVarying(n,o.ShaderStages.out),g=(n,e)=>l.sample2DTexture(n,e);class v extends e{constructor(){super(),this.prevMap=null,this.numIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.prevMap,this.prevMap),t.uniform1f(r.numIteration,this.numIteration)}clone(){var n=new v;return n.prevMap=this.prevMap,n.numIteration=this.numIteration,n}}class S extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new S}}return{Blending:new r(new t(function(e,t){t.customDefines;let r=`\n            ${d({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${h("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const a=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n                \n            ${u({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n            ${u({uniformName:"prevMap",uniformType:"t2"})}\n            ${u({uniformName:"numIteration",uniformType:"f"})}\n     \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${$("iteration")} = ${m("numIteration")};\n                ${c("blendUV")} = ${f("vUv")};\n\n                ${p("prevColor")}  = ${g("prevMap","blendUV")};\n                ${p("currColor")}  = ${g("tScene","blendUV")};\n\n                ${a} = ${p()}((prevColor * iteration + currColor) / (iteration + 1.0));\n            }\n        `}},"MSAA_Blend"),v,{}),Transfer:new r(new t(function(e,t){t.customDefines;let r=`\n            ${d({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${h("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const a=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n                \n            ${u({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${u({uniformName:"tBlend",uniformType:"t2",locationName:"tInput1"})}\n     \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${c("blendUV")} = ${f("vUv")};\n\n                ${a} = ${g("tBlend","blendUV")};\n            }\n        `}},"MSAA_Transfer"),S,{})}}),define("DS/ShaderBuilders/PostPro/OITShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=(i.ParameterUtils,i.FunctionHandler),m=n=>a.addUniform(n),$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},c=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>u.sample2DTexture(n,e);class x extends e{constructor(){super(2)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new x}}function y(e){return`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${v("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}class _ extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new _}}return{SolveAndBlendIfPostProShader:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${t.POSTPRO?m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${m({uniformName:"tAccum",uniformType:"t2",locationName:"tInput1"})}\n            ${m({uniformName:"tReveal",uniformType:"t2",locationName:"tInput2"})}\n\n            ${c("threshold")} = 1e-6;\n\n            void main() {\n                ${p("screenUV")} = ${g("vUv")};\n                ${t.POSTPRO?`\n                    ${f("opaque")} = ${S("tScene","screenUV")};\n                    `:`\n                    ${f("opaque")} = ${f()}(0.0);\n                    `}\n                ${$("reveal")}  = ${S("tReveal","screenUV")}.r;\n                if (reveal > 1.0 - threshold) {\n                    ${r} = opaque;\n                    return;\n                }\n                ${f("accum")}  = ${S("tAccum","screenUV")};\n                ${$("divider")} = max(accum.a,threshold);\n                if (${s="abs(accum)",i=`max(${s}.r,max(${s}.g,max(${s}.b,${s}.a)))`,`abs(${i}) == 1e6`}){\n                    accum.r = divider;\n                    accum.g = divider;\n                    accum.b = divider;\n                }\n                ${d("avgCol")}  = accum.rgb / divider;\n                ${t.POSTPRO?`\n                    ${r} = vec4(avgCol * (1.0 - reveal) + reveal * opaque.rgb, 1.0 - reveal + opaque.a * reveal);\n                    `:`\n                    ${r} = vec4(avgCol, 1.0 - reveal);\n                    `}\n            }\n        `;var i,s;return{vertexShader:y(e),fragmentShader:a}},"OIT_Solve_Blend"),x,{POSTPRO:1}),BlendShader:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tTransparent",uniformType:"t2",locationName:"tInput"})}\n\n            ${c("threshold")} = 1e-6;\n\n            void main() {\n                ${p("screenUV")} = ${g("vUv")};\n                ${t} = ${S("tTransparent","screenUV")};\n            }\n        `;return{vertexShader:y(e),fragmentShader:r}},"OIT_Blend"),_,{})}}),define("DS/ShaderBuilders/PostPro/MirrorShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=(i.ParameterUtils,i.FunctionHandler),m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>u.sample2DTexture(n,e);class x extends e{constructor(){super(1),this.reflectivity=.3}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.reflectivity,this.reflectivity)}clone(){var n=new x;return n.reflectivity=this.reflectivity,n}}return{Blend:new r(new t(function(e,t){var r=t.customDefines;let a=`\n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const i=$("tReflectedScene"),s=o.getShaderOutput("out0");return{vertexShader:a,fragmentShader:`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${r.POSTPRO?m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${m({uniformName:"tReflectedScene",uniformType:"t2",locationName:"tInput1"})}\n\n            ${m({uniformName:"reflectivity",uniformType:"f"})}\n\n            void main() {\n                ${p("screenUV")} = ${g("vUv")};\n\n                ${f("reflectedScene")} = ${S(i,"screenUV")};\n                ${c("blend")} = 1.0 - ${$("reflectivity")};\n                ${c("srcAlpha")} = (1.0 - blend) * reflectedScene.w;\n\n                ${r.POSTPRO?`               \n\t\t\t\t\t${f("mirrorPlane")} = ${S("tScene","screenUV")};\n\t\t\t\t\t${d("mirrorPlaneColor")}  = mirrorPlane.xyz;\n                    ${d("mirrorMix")}  = (1.0 - blend) * reflectedScene.xyz + blend * mirrorPlaneColor;\n\n                    ${s} = ${f()}(mirrorMix * reflectedScene.w + mirrorPlaneColor * (1.0 - reflectedScene.w), srcAlpha + (1.0-srcAlpha)*mirrorPlane.w);\n                    `:`\n                    ${s} = ${f()}(reflectedScene.rgb, srcAlpha);\n                    `}\n            }\n        `}},"MirrorBlend"),x,{POSTPRO:1})}}),define("DS/ShaderBuilders/PostPro/ImageOperationShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterV2(n),d=n=>u.parameterV3(n),f=(n,e,t)=>m.declareFunction(n,e,t),h=(n,e,t)=>m.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>m.sample2DTexture(n,e),P=()=>i.FunctionHandler.getMainVertexStart(),N=()=>i.FunctionHandler.getMainVertexEnd(),M=()=>i.FunctionHandler.getMainFragmentStart(),b=()=>i.FunctionHandler.getMainFragmentEnd();class w extends e{constructor(n=0){super(n)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new w}}class U extends w{constructor(){super(),this.threshold=1,this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.threshold,this.threshold),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){var n=new U;return n.threshold=this.threshold,n.invSize=this.invSize,n}}class z extends w{constructor(){super(1),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){var n=new z;return n.invSize=this.invSize,n}}class V extends w{constructor(){super(0),this.tInputSize=new n.Vector2(512,512),this.currentSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.currentSize,this.currentSize.x,this.currentSize.y),t.uniform2f(r.tInputSize,this.tInputSize.x,this.tInputSize.y)}clone(){return new V}}function F(e){return`\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${P()}\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${N()}\n        `}return{FlipX:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2"})}\n\n            ${M()}\n                ${S("screenUV")} = ${T("vUv")};\n                screenUV.x = 1.0 - screenUV.x;\n\n                ${y("color")} = ${C("tInput","screenUV")};\n                ${t} = color;\n            ${b()}\n        `;return{vertexShader:F(e),fragmentShader:r}},"FlipX"),w,{}),Threshold:new r(new t(function(n,e){const t=e.customDefines.FIREFLY>0,r="tInput",a=o.getShaderOutput("out0");let i=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            ${$({uniformName:"threshold",uniformType:"f"})}\n            ${$({uniformName:"invSize",uniformType:"v2"})}\n\n            ${t?`\n                ${f("WeighedAverageColor","v4",[p("uv"),p("offset")])} {\n                    ${S("coord")} = uv + offset * ${c("invSize")};\n                    ${y("color")} = ${C(r,"coord")};\n                    color.a = 1.0;\n                    ${v("luminance")} = dot(color.rgb, ${x()}(0.3, 0.6, 0.1));\n                    return color / (1.0 + luminance);\n                }\n\n                ${f("isNan","b",[d("val")])} {\n                    return !( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) || !( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) || !( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 );\n                }\n            `:l}\n\n            void main() {\n                ${S("screenUV")} = ${T("vUv")};\n\n                ${t?`\n                ${y("color")} = ${y()}(0.0);\n\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${S()}(0.0, 0.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${S()}(1.0, 0.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${S()}(1.0, 1.0)`)])};\n                color += ${h("WeighedAverageColor","v4",[p("screenUV"),p(`${S()}(0.0, 1.0)`)])};\n\n                color.x /= color.w;\n                color.y /= color.w;\n                color.z /= color.w;\n                if (${h("isNan","b",[d("color.xyz")])}) {\n                    color = ${y()}(0.0);\n                }\n                ${v("luminance")} = dot(color.rgb, ${x()}(0.3, 0.6, 0.1));\n                if (luminance < ${c("threshold")}) {\n                    color = ${y()}(0.0);\n                }\n                ${a} = ${y()}(color.xyz, 1.0);\n            `:`\n                    ${y("color")} = ${C(r,"screenUV")};\n                    ${v("lum")} = dot(color.rgb, ${x()}(0.2126, 0.7152, 0.0722));\n                    ${v("lum2")} = clamp(lum - ${c("threshold")}, 0.0, 1.0);\n                    color.r *= lum2;\n                    color.g *= lum2;\n                    color.b *= lum2;\n                    ${a} = color;\n                `}\n            }\n        `;return{vertexShader:F(e),fragmentShader:i}},"Threshold"),U,{FIREFLY:0}),Up:new r(new t(function(n,e){var t=e.customDefines;const r="tInput",a=o.getShaderOutput("out0"),i=t.ADD_TEXTURE>0;function s(n){return C(r,`screenUV + ${n} * ${c("invSize")}`)}let u=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${i?$({uniformName:"tAdd",uniformType:"t2",locationName:"tInput1"}):l}\n\n            ${$({uniformName:"invSize",uniformType:"v2"})}\n\n            void main() {\n                ${S("screenUV")} = ${T("vUv")};\n\n                ${y("color")} = ${s(`${S()}(0.0, 0.0)`)} * 0.25;\n\n                color += ${s(`${S()}(-1.0, -1.0)`)} * 0.0625;\n                color += ${s(`${S()}(1.0, -1.0)`)} * 0.0625;\n                color += ${s(`${S()}(1.0, 1.0)`)} * 0.0625;\n                color += ${s(`${S()}(-1.0, 1.0)`)} * 0.0625;\n           \n                color += ${s(`${S()}(0.0, -1.0)`)} * 0.125;\n                color += ${s(`${S()}(0.0, 1.0)`)} * 0.125;\n                color += ${s(`${S()}(1.0, 0.0)`)} * 0.125;\n                color += ${s(`${S()}(-1.0, 0.0)`)} * 0.125;\n\n                ${i?`\n                    color += ${C("tAdd","screenUV")};\n                    `:l}\n                \n\n                ${a} = color;\n            }\n        `;return{vertexShader:F(e),fragmentShader:u}},"Up"),z,{ADD_TEXTURE:0}),Down:new r(new t(function(n,e){var t=e.customDefines;const r="tInput",a=o.getShaderOutput("out0"),i=t.ADD_TEXTURE>0;function s(n){return C(r,`screenUV + ${n} * ${c("invSize")}`)}let u=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${i?$({uniformName:"tAdd",uniformType:"t2",locationName:"tInput1"}):l}\n\n            ${$({uniformName:"invSize",uniformType:"v2"})}\n\n            void main() {\n                ${S("screenUV")} = ${T("vUv")};\n\n                ${y("color")} = ${s(`${S()}(0.0, 0.0)`)} * 0.125;\n                color += ${s(`${S()}(-1.0, -1.0)`)} * 0.125;\n                color += ${s(`${S()}(1.0, -1.0)`)} * 0.125;\n                color += ${s(`${S()}(1.0, 1.0)`)} * 0.125;\n                color += ${s(`${S()}(-1.0, 1.0)`)} * 0.125;\n           \n                color += ${s(`${S()}(-2.0, 0.0)`)} * 0.0625;\n                color += ${s(`${S()}(2.0, 0.0)`)} * 0.0625;\n                color += ${s(`${S()}(0.0, -2.0)`)} * 0.0625;\n                color += ${s(`${S()}(0.0, 2.0)`)} * 0.0625;\n                \n                color += ${s(`${S()}(-2.0, -2.0)`)} * 0.03125;\n                color += ${s(`${S()}(2.0, -2.0)`)} * 0.03125;\n                color += ${s(`${S()}(2.0, 2.0)`)} * 0.03125;\n                color += ${s(`${S()}(-2.0, 2.0)`)} * 0.03125;\n\n                ${i?`\n                    color += ${C("tAdd","screenUV")};\n                    `:l}\n                \n\n                ${a} = color;\n            }\n        `;return{vertexShader:F(e),fragmentShader:u}},"Down"),z,{ADD_TEXTURE:0}),Nothing:new r(new t(function(n,e){const t=o.getShaderOutput("out0");let r=`\n\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2"})}\n\n            ${M()}\n                ${S("screenUV")} = ${T("vUv")};\n                ${y("color")} = ${C("tInput","screenUV")};\n                ${t} = color;\n            ${b()}\n        `;return{vertexShader:F(e),fragmentShader:r}},"Nothing"),w,{}),PixelSum:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            ${$({uniformName:"tInputSize",uniformType:"v2"})}\n            ${$({uniformName:"currentSize",uniformType:"v2"})}\n\n            ${m.getMainFragmentStart()}\n                ${S("screenUV")} = ${T("vUv")};\n                ${S("currentPixel")} = floor(screenUV * ${c("currentSize")});\n\n                ${S("sums")} = ${S()}(0.0);\n                ${S("loopSize")}  = ${S()}(${v()}(${t.LOOP_SIZE_X}),${v()}(${t.LOOP_SIZE_Y}));\n\n                ${S("uvDiffuse")}  = (0.5+currentPixel*loopSize)/${c("tInputSize")};\n\n                ${S("currUv")} ;\n\n                if(currentPixel.x<(${c("currentSize")}.x-1.0)){\n\t\t\t\t\tfor(${g("i")}=0;i<${t.LOOP_SIZE_X};i++){\n\t\t\t\t\t\tcurrUv = uvDiffuse + ${S()}(${v()}(i)/${c("tInputSize")}.x,0.0);\n\t\t\t\t\t\tif(currentPixel.y<(${c("currentSize")}.y-1.0)){\n\t\t\t\t\t\t\tfor(${g("j")}=0;j<${t.LOOP_SIZE_Y};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${c("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(${g("j")}=0;j<${t.LOOP_SIZE_Y_FINAL};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${c("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(${g("i")}=0;i<${t.LOOP_SIZE_X_FINAL};i++){\n\t\t\t\t\t\tcurrUv = uvDiffuse + ${S()}(${v()}(i)/${c("tInputSize")}.x,0.0);\n\t\t\t\t\t\tif(currentPixel.y<(${c("currentSize")}.y-1.0)){\n\t\t\t\t\t\t\tfor(${g("j")}=0;j<${t.LOOP_SIZE_Y};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${c("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(${g("j")}=0;j<${t.LOOP_SIZE_Y_FINAL};j++){\n\t\t\t\t\t\t\t\tcurrUv.y += 1.0/${c("tInputSize")}.y;\n\t\t\t\t\t\t\t\tsums+=${C("tInput","currUv")}.rg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n                ${r} = ${y()}(sums, 0.0, 1.0);\n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:F(e),fragmentShader:a}},"PixelSum"),V,{LOOP_SIZE_X:0,LOOP_SIZE_Y:0,LOOP_SIZE_X_FINAL:0,LOOP_SIZE_Y_FINAL:0})}}),define("DS/ShaderBuilders/PostPro/SSAOShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterI(n),d=n=>u.parameterF(n),f=n=>u.parameterV2(n),h=n=>u.parameterV3(n),g=(n,e,t)=>m.declareFunction(n,e,t),v=(n,e,t)=>m.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},P=(n=null)=>{var e={name:n};return s.bvec2(e)},N=(n=null)=>{var e={name:n};return s.bvec4(e)},M=n=>o.addVarying(n),b=n=>o.getVarying(n,o.ShaderStages.in),w=n=>o.getVarying(n,o.ShaderStages.out),U=(n,e)=>m.sample2DTexture(n,e),z={ADAPTATIVE_RADIUS:!0};class V extends e{constructor(){super(),this.realProjectionMatrix=new n.Matrix4,this.realProjectionMatrixInverse=new n.Matrix4,this.nbSamples=16,this.tRandomTexture=null,this.radius=.5,this.minRadius=.01,this.maxRadius=.2,this.thresholdAngle=.045,this.invSize=new n.Vector2(1/800,1/600),this.attenuation=1}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniformMatrix4fv(r.realProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrix.elements)),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniform1i(r.nbSamples,this.nbSamples),e.loadTexture(t,r.tRandomTexture,this.tRandomTexture),t.uniform1f(r.radius,this.radius),t.uniform1f(r.minRadius,this.minRadius),t.uniform1f(r.maxRadius,this.maxRadius),t.uniform1f(r.thresholdAngle,this.thresholdAngle),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniform1f(r.attenuation,this.attenuation)}clone(){var n=new V;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n}}class F extends V{constructor(){super(),this.samplingPoints=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform4fv(r.samplingPoints,this.samplingPoints)}clone(){var n=new F;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n.samplingPoints=this.samplingPoints,n}}class R extends V{constructor(){super(),this.firstSample=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1i(r.firstSample,this.firstSample)}clone(){var n=new R;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.nbSamples=this.nbSamples,n.tRandomTexture=this.tRandomTexture,n.radius=this.radius,n.minRadius=this.minRadius,n.maxRadius=this.maxRadius,n.thresholdAngle=this.thresholdAngle,n.invSize=this.invSize,n.attenuation=this.attenuation,n.firstSample=this.firstSample,n}}function A(e){return`          \n            ${M({varyingName:"vUv",varyingType:"v2"})}\n            \n            void main() {\n\n                ${w("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}function I(n){return`\n        \n        ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput"})}\n        ${$({uniformName:"realProjectionMatrix",uniformType:"m4"})}\n        ${$({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${$({uniformName:"invSize",uniformType:"v2"})}\n        ${$({uniformName:"radius",uniformType:"f"})}\n        ${$({uniformName:"minRadius",uniformType:"f"})}\n        ${$({uniformName:"maxRadius",uniformType:"f"})}\n        ${$({uniformName:"nbSamples",uniformType:"i"})}\n        ${$({uniformName:"thresholdAngle",uniformType:"f"})}\n        ${$({uniformName:"attenuation",uniformType:"f"})}\n\n        ${M({varyingName:"vUv",varyingType:"v2"})}\n\n        ${x("MAX_SAMPLES")} = 32;\n\n        ${x("kernelSize")}  = 32;\n        ${_("PI")} = 3.14159265358979323846264;\n        ${_("one_over_tan_225")}  = 2.414213562373095;\n\n        ${g("getScreenPos","v2",[h("pos")])}{\n\n          ${C("offset")}  = ${c("realProjectionMatrix")} * ${C()}(pos, 1.0);\n          offset.x /= offset.w;\n          offset.y /= offset.w;\n          offset.x = offset.x * 0.5 + 0.5;\n          offset.y = offset.y * 0.5 + 0.5;\n\n          return offset.xy;\n        }\n\n        ${g("computePointVS","v3",[f("iUV"),h("iPos")])} {\n\n            ${C("normalDepth")}  = ${U("tNormalDepth","iUV")};\n            ${y("z")};\n            ${n.renderToFloatTexture?"\n                z = normalDepth.w;\n                ":`\n                z = ${v("unpackForFloat16","f",[f("normalDepth.zw")])};\n                `}\n\n            ${N("inScreen4")}  = ${N()}(iUV.x >= 0.0, iUV.x <= 1.0, iUV.y >= 0.0, iUV.y <= 1.0);\n            ${P("inScreen")}  = ${P()}(all(inScreen4), z > 0.0);\n\n            if (!all(inScreen)) return ${D()}(iPos.x, iPos.y, iPos.z - 1.0);\n\n            ${T("xy")}  = iUV * 2.0 - 1.0;\n\n            ${C("vertexPositionProjected")}  = ${C()}(xy, 2.0 * z - 1.0, 1.0);\n            ${C("vertexPositionVS")}  = ${c("realProjectionMatrixInverse")}  * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${g("ComputeAO","f",[h("iSamplePos"),h("iPos"),h("iNormal"),d("iAtt")])}{\n\n            ${D("dir")}  = iSamplePos - iPos;\n\n            ${y("l2")}     = dot(dir, dir);\n            ${y("angle")}  = dot(iNormal, dir) / sqrt(l2);\n            ${y("occ")}  = 0.0;\n\n            if (l2 > 0.0  && angle > ${c("thresholdAngle")}) {\n\n                occ = 1.0 / (1.0 + l2 * iAtt);\n\n                angle = 1.0 - angle;\n                angle *= angle;\n                angle *= angle;\n                occ *= (1.0 - angle);\n            }\n\n            return occ;\n\n        }\n        `}function L(n){const e=o.getShaderOutput("out0");var t=n.customDefines;return`\n        \n            ${T("screenPos")} = ${b("vUv")};\n\n            ${e} = ${C()}(1.0);\n\n            ${C("normalDepth")}  = ${U("tNormalDepth","screenPos")};\n            ${y("z")};\n            ${D("normal")};\n            ${n.renderToFloatTexture?"\n                z = normalDepth.w;\n                normal = normalDepth.xyz * 2.0 - 1.0;\n                ":`\n                z = ${v("unpackForFloat16","f",[f("normalDepth.zw")])};\n                normal = ${v("decodeOct22Normal","v2",[f("normalDepth.xy")])};\n                `}\n\n            if ( z < 0.1 ) return;\n\n            ${T("xy")}  = screenPos * 2.0 - 1.0;\n\n            ${C("vertexPositionProjected")}  = ${C()}(xy, 2.0 * z - 1.0, 1.0);\n            ${C("vertexPositionVS")}  = ${c("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            ${D("origin")}  = vertexPositionVS.xyz;\n\n            // projRadius is in homogeneous coords\n            // we presuppose that fov/2 is 22.5 degrees...\n\n            ${y("projRadius")}  = 0.5 * ${c("realProjectionMatrix")}[0][0] * ${c("radius")};\n            // perspective case\n            if (${c("realProjectionMatrix")}[3][3] < 0.5) { \n                projRadius /= -origin.z;\n            }\n\n            ${y("scaleRadius")}  = 1.0;\n\n            ${t.ADAPTATIVE_RADIUS?`scaleRadius = min(${c("maxRadius")}, max(projRadius, ${c("minRadius")})) / projRadius;`:l}\n\n            ${y("newRadius")}  = scaleRadius * ${c("radius")};\n\n            ${y("att")}  = ${c("attenuation")} / (newRadius * newRadius);\n\n            float occ = 0.0;\n        `}return{Iterative:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");var r=`\n            \n        ${$({uniformName:"tRandomTexture",uniformType:"t2"})}\n        ${$({uniformName:"firstSample",uniformType:"i"})}\n\n        ${g("random","f",[h("scale"),d("seed")])} {\n            return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n\n        ${g("Random1D","f",[d("seed")])} {\n            ${D("scale")} = ${D()}(12.9898, 78.233, 151.7182);\n            return ${v("random","f",[h("scale"),d("seed")])};\n        }\n\n        ${g("HaltonSequenceShift","f",[p("n"),p("base"),d("shift")])} {\n\n            ${y("val")}  = 0.0;\n            ${y("invBase")}  = 1.0 / ${y()}(base);\n            ${y("invBi")}  = invBase;\n            ${S("nn")} = n;\n\n            // glsl limitation\n            for (${S("i")} = 0; i < 32; i++) { \n                if (nn == 0) break;\n                ${y("d_i")}  = mod(${y()}(nn), ${y()}(base));\n                val += ${y()}(d_i) * invBi;\n                nn /= base;\n                invBi *= invBase;\n            }\n\n            return fract(val + shift);\n        }\n\n        ${g("LowDiscrepancy3DShift","v3",[p("index"),f("shift")])} {\n\n            ${S("yy")} = index / 64;\n            ${y("xx")}  = mod(${y()}(index), 64.0);\n            ${T("offset")}  = vec2(xx, ${y()}(yy));\n            ${D("res")}  = ${U("tRandomTexture","0.015625 * (offset + 0.5)")}.xyz;\n\n            return fract(res + shift.xyx);\n        }\n\n        // random normalized vector\n\n        ${g("uniformlySampleSphere","v3",[f("E")])} {\n\n            ${y("z")} = 1.0 - 2.0 * E.x;\n            ${y("r")}  = sqrt(1.0 - z * z);\n            float angle = 6.283185307179586 * E.y;\n\n            return ${D()}(r * cos(angle), r * sin(angle), z);\n        }\n\n        ${g("precomputeRandom1D","v4",[f("shift"),p("index")])} {\n            ${S("offset")} = ${c("firstSample")};\n            ${D("E")} = ${v("LowDiscrepancy3DShift","v3",[p("offset + index + 1"),f("shift")])};\n            ${D("sampleSphere")} = ${v("uniformlySampleSphere","v3",[f("E.xy")])};\n            return ${C()}(sampleSphere, E.z);\n        }\n\n        ${I(e)}\n\n        ${g("ComputeSampleSSAO","f",[f("uv"),h("iSamplingPt"),h("iPos"),h("iNormal"),d("iRadius"),d("iAtt"),d("iRandomZ")])} {\n\n            ${y("occ")}  = 0.0;\n\n            ${y("delta")}  = iRadius * sign(dot(iSamplingPt, iNormal)) * iRandomZ;\n            ${D("newPt")}   = delta * iSamplingPt + iPos;\n\n            ${T("coord")}  = ${v("getScreenPos","v2",[h("newPt")])};\n\n            ${T("tmp")}  = coord - uv;\n            coord = uv + sign(tmp.xy) * max(${c("invSize")}.xy, abs(tmp.xy));\n\n            ${D("samplePos")} = ${v("computePointVS","v3",[f("coord"),h("newPt")])};\n\n            if (samplePos.z > newPt.z) {\n\n                occ = ${v("ComputeAO","f",[h("samplePos"),h("iPos"),h("iNormal"),d("iAtt")])};\n            }\n\n            return occ;\n        }\n        \n\n        void main() {\n\n            ${L(e)};\n            ${y("randomX")} = ${v("Random1D","f",[d("gl_FragCoord.x + gl_FragCoord.y")])};\n            ${y("randomY")} = ${v("Random1D","f",[d("gl_FragCoord.x * gl_FragCoord.y")])};\n            ${T("shift")}  = ${T()}(randomX, randomY);\n            for (${S("i")} = 0; i < MAX_SAMPLES; i++) {\n                if (i == ${c("nbSamples")}) {\n                    break;\n                }           \n                ${C("randVec")}  = ${v("precomputeRandom1D","v4",[f("shift"),p("i")])};    \n                occ += ${v("ComputeSampleSSAO","f",[f("screenPos"),h("randVec.xyz"),h("origin"),h("normal"),d("newRadius"),d("att"),d("randVec.w")])};\n            }\n            occ /= max(${y()}(${c("nbSamples")}), 1.0);\n\n            ${t} = ${C()}(${D()}(1.0 - occ), 1.0);\n\n        }\n        `;return{vertexShader:A(e),fragmentShader:r}},"SSAO_Iterative"),R,z),Direct:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");var r=`\n        \n        ${$({uniformName:"tRandomTexture",uniformType:"t2"})}\n        ${$({uniformName:"samplingPoints",uniformType:"fv4",size:32})}\n\n        ${g("modI","f",[d("a"),d("b")])} {\n\n            ${y("m")} = a - floor((a + 0.5) / b) * b;\n            return floor(m + 0.5);\n        }\n\n        ${g("precomputeRandom1D","v3",[f("coords")])} {\n\n            ${y("modIx")} = ${v("modI","f",[d("coords.x"),d("5.0")])};\n            ${y("modIy")} = ${v("modI","f",[d("coords.y"),d("5.0")])};\n            ${T("s")} = 0.2 * (${T()}(modIx, modIy) + 0.5);\n            return ${U("tRandomTexture","s")}.xyz;\n        }\n\n        ${I(e)}\n\n        ${g("ComputeSampleSSAO","f",[f("uv"),h("iSamplingPt"),h("iPos"),h("iNormal"),d("iRadius"),d("iAtt"),h("iRandomVec")])} {\n\n            ${y("occ")}  = 0.0;\n\n            ${D("rayDir")}  = reflect(iSamplingPt, iRandomVec);\n\n            ${y("delta")}  = iRadius * sign(dot(rayDir, iNormal));\n            ${D("newPt")}   = delta * rayDir + iPos;\n\n            ${T("coord")}  = ${v("getScreenPos","v2",[h("newPt")])};\n\n            ${T("tmp")}  = coord - uv;\n            coord = uv + sign(tmp.xy) * max(${c("invSize")}.xy, abs(tmp.xy));\n\n            ${D("samplePos")} = ${v("computePointVS","v3",[f("coord"),h("newPt")])};\n\n            if (samplePos.z > newPt.z) {\n\n                occ = ${v("ComputeAO","f",[h("samplePos"),h("iPos"),h("iNormal"),d("iAtt")])};\n            }\n\n            return occ;\n        }\n\n        void main() {\n\n            ${L(e)}\n            ${D("randVec")}  = ${v("precomputeRandom1D","v3",[f("gl_FragCoord.xy")])};\n            for (${S("i")} = 0; i < MAX_SAMPLES; i++) {\n                if (i == ${c("nbSamples")}) {\n                    break;\n                }\n                ${D("samplingPoint")} = ${c("samplingPoints")}[i].xyz;\n                occ += ${v("ComputeSampleSSAO","f",[f("screenPos"),h("samplingPoint"),h("origin"),h("normal"),d("newRadius"),d("att"),h("randVec")])};\n            }\n            occ /= max(${y()}(${c("nbSamples")}), 1.0);\n\n            ${t} = ${C()}(${D()}(1.0 - occ), 1.0);\n\n        }\n        `;return{vertexShader:A(e),fragmentShader:r}},"SSAO_Direct"),F,z)}}),define("DS/ShaderBuilders/PostPro/GroundShadowShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterV2(n),p=n=>l.parameterV3(n),d=n=>l.parameterV4(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},x=n=>o.addVarying(n),y=n=>o.getVarying(n,o.ShaderStages.in),_=n=>o.getVarying(n,o.ShaderStages.out),T=(n,e)=>u.sample2DTexture(n,e);class D extends e{constructor(){super(),this.shadowMatrix=new n.Matrix4,this.intensity=.5}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.intensity,this.intensity),t.uniformMatrix4fv(r.shadowMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.shadowMatrix.elements))}clone(){var n=new D;return n.shadowMatrix=this.shadowMatrix,n.intensity=this.intensity,n}}return{GroundShadow:new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0");return{vertexShader:`\n                 \n            ${x({varyingName:"vUv",varyingType:"v2"})}\n                \n\n            void main() {\n\n                ${_("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n        `,fragmentShader:`\n            ${m({uniformName:"intensity",uniformType:"f"})}\n            ${m({uniformName:"shadowMatrix",uniformType:"m4"})}\n            ${m({uniformName:"tShadowMap",uniformType:"t2",locationName:"tInput"})}\n            \n            ${x({varyingName:"vUv",varyingType:"v2"})}\n\n            ${f("unpackDepth","f",[c("uv")])}{\n                ${S("rgba_depth")}  = ${T("tShadowMap","uv")};\n                ${r.IS_ESM?`\n                    ${g("depth")} = 1.0;\n                    ${t.uintESM?`\n                        depth = ${h("unpackRGB","f",[p("rgba_depth.xyz * pow(10.0,rgba_depth.w*255.0)")])};\n                        `:"\n                        depth = rgba_depth.x;\n                        "}\n                    return log(depth) / 80.0;\n                    `:`\n                    return ${h("unpackRGBA","f",[d("rgba_depth")])};\n                    `}\n            }\n\n            void main() {\n                ${a} = ${S()}(1.0);\n\n                ${v("screenPos")} = ${y("vUv")};\n                ${S("shadowCoord")} = ${$("shadowMatrix")} * ${S()}(screenPos.x, screenPos.y, 0.0, 1.0);\n                shadowCoord.x /= shadowCoord.w;\n                shadowCoord.y /= shadowCoord.w;\n                shadowCoord.z /= shadowCoord.w;\n\n                if (${h("unpackDepth","f",[c("shadowCoord.xy")])} < 1.0) {\n                    ${a}.x = ${$("intensity")};\n                }\n            }\n        `}},"Ground_Shadow"),D,{IS_ESM:0})}}),define("DS/ShaderBuilders/PostPro/TAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterV2(n),d=n=>u.parameterV3(n),f=n=>u.parameterV4(n),h=(n,e,t)=>m.declareFunction(n,e,t),g=(n,e,t)=>m.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},D=n=>o.addVarying(n),C=n=>o.getVarying(n,o.ShaderStages.in),P=n=>o.getVarying(n,o.ShaderStages.out),N=(n,e)=>m.sample2DTexture(n,e);class M extends e{constructor(){super(1),this.screenSize=new n.Vector2(512,512),this.prevMap=null,this.numIteration=0,this.previousViewProjectionMatrix=new n.Matrix4,this.currentViewProjectionMatrix=new n.Matrix4,this.currentProjectionMatrixInverse=new n.Matrix4,this.currentViewMatrixInverse=new n.Matrix4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.screenSize,this.screenSize.x,this.screenSize.y),e.loadTexture(t,r.prevMap,this.prevMap),t.uniform1f(r.numIteration,this.numIteration),t.uniformMatrix4fv(r.previousViewProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.previousViewProjectionMatrix.elements)),t.uniformMatrix4fv(r.currentViewProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.currentViewProjectionMatrix.elements)),t.uniformMatrix4fv(r.currentProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.currentProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.currentViewMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.currentViewMatrixInverse.elements))}clone(){var n=new M;return n.screenSize=this.screenSize,n.prevMap=this.prevMap,n.numIteration=this.numIteration,n.previousViewProjectionMatrix=this.previousViewProjectionMatrix,n.currentViewProjectionMatrix=this.currentViewProjectionMatrix,n.currentProjectionMatrixInverse=this.currentProjectionMatrixInverse,n.currentViewMatrixInverse=this.currentViewMatrixInverse,n}}function b(e){return`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            void main() {\n\n                ${P("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}class w extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new w}}return{TAA:new r(new t(function(n,e){var t=e.customDefines;const r="tScene",a="tNormalDepth",i=o.getShaderOutput("out0");function s(n,t,r){return e.renderToFloatTexture?`\n                    ${n} = ${N(a,`uv + ${x()}(${t},${r})`)}.w; \n                    if (${n} < 0.1) ${n} = 1.0;\n                `:`\n                    ${n} = ${g("unpackForFloat16","f",[p(`${N(a,`uv + ${x()}(${t},${r})`)}.zw`)])}; \n                    if (${n} < 0.1) ${n} = 1.0;\n                `}function u(n,e,t){return`\n                ${s(n,e,t)}\n                ${function(n,e,t){return`if (${n} < dmin.z) dmin = ${_()}(${e}, ${t}, ${n});`}(n,e,t)}\n            `}let m=`\n                \n            ${$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}    \n            \n            ${$({uniformName:"screenSize",uniformType:"v2"})}    \n            ${$({uniformName:"prevMap",uniformType:"t2"})}    \n            ${$({uniformName:"numIteration",uniformType:"f"})}  \n            ${$({uniformName:"previousViewProjectionMatrix",uniformType:"m4"})}  \n            ${$({uniformName:"currentViewProjectionMatrix",uniformType:"m4"})}  \n            ${$({uniformName:"currentProjectionMatrixInverse",uniformType:"m4"})}  \n            ${$({uniformName:"currentViewMatrixInverse",uniformType:"m4"})}      \n     \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n    \n            ${y("positiveY")} = ${x()}(0.0, 1.0);\n            ${y("positiveX")} = ${x()}(1.0, 0.0);\n            ${y("negativeY")} = ${x()}(0.0, -1.0);\n            ${y("negativeX")} = ${x()}(-1.0, 0.0);\n\n            ${h("luminance_RGB","f",[d("iColor")])} {\n                ${_("luminance_weight")} = ${_()}(0.176204, 0.812985, 0.0108109);\n                return dot(iColor, luminance_weight);\n            }\n\n            ${h("getPositionWS","v3",[d("ndc")])} {\n                ${T("vertexPositionProjected")}  = ${T()}(ndc, 1.0);\n                ${T("vertexPositionVS")}  = ${c("currentProjectionMatrixInverse")} * vertexPositionProjected;\n                vertexPositionVS.xyz /= vertexPositionVS.w;\n                vertexPositionVS.w = 1.0;\n                return (${c("currentViewMatrixInverse")} * vertexPositionVS).xyz;\n            }\n\n            ${h("closestFragment","v3",[p("uv"),p("texelSize")])} {\n\n                ${v("d")};\n                ${x("size")}  = 2.0 * texelSize;\n                ${_("dmin")}  = ${_()}(0.0, 0.0, 0.0);\n\n                ${s("dmin.z","0.0"," 0.0")}\n                ${u("d","-size.x","size.y")}\n                ${u("d","size.x","size.y")}\n                ${u("d","-size.x","-size.y")}\n                ${u("d","size.x","-size.y")}\n                ${t.CLOSEST_9TAP?`\n                    ${u("d","0.0","size.y")}\n                    ${u("d","-size.x","0.0")}\n                    ${u("d","size.x","0.0")}\n                    ${u("d","0.0","-size.y")}\n                    `:l}\n                return ${_()}(uv + dmin.xy, dmin.z);\n            }\n\n\n            ${h("clip_aabb_opti","v4",[f("minimum"),f("maximum"),f("color")])} {\n\n                ${S("eps")} = 0.00000001;\n                ${T("center")}  = 0.5 * (maximum + minimum);\n                ${T("extents")}  = 0.5 * (maximum - minimum) + eps;\n                ${T("offset")}  = color - center;\n                ${T("ts")}  = abs(offset / extents);\n                ${v("t")} = max(max(ts.r, ts.g), max(ts.b, ts.a));\n                return center + offset / max(1.0, t);\n            }\n\n            ${h("taa","v4",[p("ssVel"),p("texelSize"),p("uv")])} {\n\n                ${T("tl")}  = ${N(r,"uv + texelSize * (negativeX + positiveY)")};\n                ${T("t")}   = ${N(r,"uv + texelSize * (positiveY)")};\n                ${T("tr")}  = ${N(r,"uv + texelSize * (positiveX + positiveY)")};\n                ${T("ml")}  = ${N(r,"uv + texelSize * (negativeX)")};\n                ${T("m")}   = ${N(r,"uv")};\n                ${T("mr")}  = ${N(r,"uv + texelSize * (positiveX )")};\n                ${T("bl")}  = ${N(r,"uv + texelSize * (negativeX + negativeY)")};\n                ${T("b")}   = ${N(r,"uv + texelSize * (negativeY)")};\n                ${T("br")}  = ${N(r,"uv + texelSize * (positiveX + negativeY)")};\n                // sharpen\n                // https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/TAA.cginc#L143\n                // reduces blurring, but increases flickering with dense geometry\n                ${T("corners")}  = 2.0 * (tr + bl + br + tl) - 2.0 * m;\n                m += (m - (corners * 0.166667)) * 2.718282 * 0.3;\n                m = max(${T()}(0.0), m);\n                // Brian Karis neighbourhood rounding: http://advances.realtimerendering.com/s2014/epic/TemporalAA.pptx\n                // average of rounded pattern with cross pattern\n                ${T("cmin5")}  = min(mr, min(m, min(ml, min(t, b))));\n                ${T("cmin")}  = min(cmin5, min(tl, min(tr, min(bl, br))));\n                ${T("cmax5")}  = max(mr, max(m, max(ml, max(t, b))));\n                ${T("cmax")}  = max(cmax5, max(tl, max(tr, max(bl, br))));\n                cmin = 0.5 * (cmin + cmin5);\n                cmax = 0.5 * (cmax + cmax5);\n                ${T("previousColor")}  = ${N("prevMap","uv - ssVel")};\n                previousColor = ${g("clip_aabb_opti","v4",[f("cmin"),f("cmax"),f("previousColor")])};\n                ${v("lum0")}  = ${g("luminance_RGB","f",[d("m.rgb")])};\n                ${v("lum1")}  = ${g("luminance_RGB","f",[d("previousColor.rgb")])};\n                ${v("diff")}  = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\n                ${v("unbiased_weight")}  = 1.0 - diff;\n                ${v("feedback")}  = mix(${t.FEEDBACK_MIN}, ${t.FEEDBACK_MAX}, unbiased_weight * unbiased_weight);\n                return mix(m, previousColor, feedback);\n            }\n\n            ${h("computeSSVelocity","v2",[d("wsPos")])}{\n\n                ${T("ssCurrentPos")}  = currentViewProjectionMatrix * ${T()}(wsPos, 1.0);\n                ${T("ssPrevPos")}  =   previousViewProjectionMatrix * ${T()}(wsPos, 1.0);\n                ${x("ndcCurrent")}  = ssCurrentPos.xy / ssCurrentPos.w;\n                ${x("ndcPrev")}  = ssPrevPos.xy / ssPrevPos.w;\n\n                if(ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 || ndcPrev.x >= 1.0 || ndcPrev.y <= -1.0) {\n\n                    return ${x()}(0.0);\n                }\n\n                return 0.5 * (ndcCurrent - ndcPrev);\n            }\n\n\n            void main() {\n                ${x("TAAUV")} = ${C("vUv")};\n                ${v("curIteration")} = ${c("numIteration")};\n                if (curIteration > 0.0) {\n\n\t\t\t\t   ${T("prevColor")}  = ${N("prevMap","TAAUV")};\n\t\t\t\t   ${T("currColor")}  = ${N(r,"TAAUV")};\n\t\t\t\t   ${i} = ${T()}((prevColor * curIteration + currColor) / (curIteration + 1.0));\n                   return;\n                }\n\n                ${x("texelSize")}  = ${x()}(1.0) / ${c("screenSize")};\n                ${_("closest")}  = ${g("closestFragment","v3",[p("TAAUV"),p("texelSize")])};\n\n                if (closest.z == 0.0) {\n                    ${i} =  ${N(r,"TAAUV")};\n                   return;\n                }\n\n                ${_("ws")} = ${g("getPositionWS","v3",[d("2.0 * closest - 1.0")])};\n                ${x("ssVel")}  = ${g("computeSSVelocity","v2",[d("ws")])};\n                ${i} = ${g("taa","v4",[p("ssVel"),p("texelSize"),p("TAAUV")])};\n            }\n        `;return{vertexShader:b(e),fragmentShader:m}},"TAA"),M,{FEEDBACK_MIN:.88,FEEDBACK_MAX:.97,CLOSEST_9TAP:1}),Transfer:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n                \n            ${$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tBlend",uniformType:"t2",locationName:"tInput1"})}\n     \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${x("blendUV")} = ${C("vUv")};\n\n                ${t} = ${N("tBlend","blendUV")};\n            }\n        `;return{vertexShader:b(e),fragmentShader:r}},"TAA_Transfer"),w,{})}}),define("DS/ShaderBuilders/PostPro/StereoShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=n=>a.addUniform(n),m=n=>{var e={uniformName:n};return a.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},d=n=>o.addVarying(n),f=n=>o.getVarying(n,o.ShaderStages.in),h=n=>o.getVarying(n,o.ShaderStages.out),g=(n,e)=>l.sample2DTexture(n,e);class v extends e{constructor(){super(),this.tLeftEye=null,this.tRightEye=null}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.tLeftEye,this.tLeftEye),e.loadTexture(t,r.tRightEye,this.tRightEye)}clone(){return new v}}function S(e){return`           \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n\n            ${l.getMainVertexStart()}\n                ${h("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${l.getMainVertexEnd()}\n        `}class x extends v{constructor(){super(),this.scale=new n.Vector2(1,1),this.scaleIn=new n.Vector2(1,1),this.leftLensCenter=new n.Vector2(0,0),this.hmdWarpParam=new n.Vector4(1,0,0,0),this.chromAbParam=new n.Vector4(1,0,0,0)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new x}}return{LeftRight:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n            ${u({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${u({uniformName:"tRightEye",uniformType:"t2"})}\n  \n\n            ${l.getMainFragmentStart()}\n                ${c("screenUV")} = ${f("vUv")};\n\n                if(screenUV.x < 0.5) {\n                    ${c("uvLeft")} = ${c()}(screenUV.x*2.0, screenUV.y);\n                    ${t} = ${g("tLeftEye","uvLeft")};\n                } else {\n                    ${c("uvRight")} = ${c()}((screenUV.x-0.5)*2.0, screenUV.y);\n                    ${t} = ${g("tRightEye","uvRight")};\n                }   \n            ${l.getMainFragmentEnd()}\n        `;return{vertexShader:S(e),fragmentShader:r}},"LeftRightStereo"),v,{}),Anaglyph:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n            ${u({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${u({uniformName:"tRightEye",uniformType:"t2"})}\n  \n\n            ${l.getMainFragmentStart()}\n                ${c("screenUV")} = ${f("vUv")};\n\n                \n                ${p("cr")}  = texture2D(tLeftEye, screenUV);\n                ${p("cl")}  = texture2D(tRightEye, screenUV);\n                ${t} = vec4(cl.r, cr.g, cr.b, 1.0);\n            ${l.getMainFragmentEnd()}\n        `;return{vertexShader:S(e),fragmentShader:r}},"AnaglyphStereo"),v,{}),OculusDK1:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${d({varyingName:"vUv",varyingType:"v2"})}\n            ${u({uniformName:"tLeftEye",uniformType:"t2"})}\n            ${u({uniformName:"tRightEye",uniformType:"t2"})}\n            ${u({uniformName:"scale",uniformType:"v2"})}\n            ${u({uniformName:"scaleIn",uniformType:"v2"})}\n            ${u({uniformName:"leftLensCenter",uniformType:"v2"})}\n            ${u({uniformName:"hmdWarpParam",uniformType:"v4"})}\n            ${u({uniformName:"chromAbParam",uniformType:"v4"})}\n  \n\n            ${l.getMainFragmentStart()}\n                ${c("screenUV")} = ${f("vUv")};\n\n                \n                if(screenUV.x >= 0.5) {\n                    ${c("lensCenter")}  = ${m("leftLensCenter")};\n                    // range from [0,1] to [-1,1]\n                    ${c("uv")}  = (${c()}((screenUV.x-0.5)*2.0, screenUV.y)*2.0)-1.0;\n                    ${c("theta")}  = (uv-lensCenter)*${m("scaleIn")};\n                    ${$("rSq")}  = theta.x*theta.x + theta.y*theta.y;\n                    ${c("rvector")}  = theta*(${m("hmdWarpParam")}.x + ${m("hmdWarpParam")}.y*rSq + ${m("hmdWarpParam")}.z*rSq*rSq + ${m("hmdWarpParam")}.w*rSq*rSq*rSq);\n                    ${c("rBlue")}  = rvector * (${m("chromAbParam")}.z + ${m("chromAbParam")}.w * rSq);\n                    ${c("tcBlue")}  = lensCenter + ${m("scale")} * rBlue;\n                    // range from [-1,1] to [0,1]\n                    tcBlue = (tcBlue+1.0)/2.0;\n                    if (any(bvec2(clamp(tcBlue, ${c()}(0.0,0.0), ${c()}(1.0,1.0))-tcBlue))) {\n                        ${t} = ${p()}(0.0, 0.0, 0.0, 1.0);\n                        return;\n                    }\n                    ${c("tcGreen")}  = lensCenter + ${m("scale")} * rvector;\n                    // range from [-1,1] to [0,1]\n                    tcGreen = (tcGreen+1.0)/2.0;\n                    ${c("rRed")}  = rvector * (${m("chromAbParam")}.x + ${m("chromAbParam")}.y * rSq);\n                    ${c("tcRed")}  = lensCenter + ${m("scale")} * rRed;\n                    // range from [-1,1] to [0,1]\n                    tcRed = (tcRed+1.0)/2.0; \n                    ${t} = ${p()}(${g("tLeftEye","tcRed")}.r, ${g("tLeftEye","tcGreen")}.g, ${g("tLeftEye","tcBlue")}.b, 1.0);\n                } else {\n                    ${c("lensCenter")}  = -${m("leftLensCenter")};\n                    // range from [0,1] to [-1,1]\n                    ${c("uv")}  = (${c()}(screenUV.x*2.0, screenUV.y)*2.0)-1.0; \n                    ${c("theta")}  = (uv-lensCenter)*${m("scaleIn")};\n                    float rSq = theta.x*theta.x + theta.y*theta.y;\n                    ${c("rvector")}  = theta*(${m("hmdWarpParam")}.x + ${m("hmdWarpParam")}.y*rSq + ${m("hmdWarpParam")}.z*rSq*rSq + ${m("hmdWarpParam")}.w*rSq*rSq*rSq);\n                    ${c("rBlue")}  = rvector * (${m("chromAbParam")}.z + ${m("chromAbParam")}.w * rSq);\n                    ${c("tcBlue")}  = (lensCenter + ${m("scale")} * rBlue);\n                    tcBlue = (tcBlue+1.0)/2.0; // range from [-1,1] to [0,1]\n                    if (any(bvec2(clamp(tcBlue, ${c()}(0.0,0.0), ${c()}(1.0,1.0))-tcBlue))) {\n                        ${t} = ${p()}(0.0, 0.0, 0.0, 1.0);\n                        return;\n                    }\n                    ${c("tcGreen")}  = lensCenter + ${m("scale")} * rvector;\n                    tcGreen = (tcGreen+1.0)/2.0; // range from [-1,1] to [0,1]\n                    ${c("rRed")}  = rvector * (${m("chromAbParam")}.x + ${m("chromAbParam")}.y * rSq);\n                    ${c("tcRed")}  = lensCenter + ${m("scale")} * rRed;\n                    tcRed = (tcRed+1.0)/2.0; // range from [-1,1] to [0,1]\n                    ${t} = ${p()}(${g("tRightEye","tcRed")}.r, ${g("tRightEye","tcGreen")}.g, ${g("tRightEye","tcBlue")}.b, 1.0);\n\n                }\n            ${l.getMainFragmentEnd()}\n        `;return{vertexShader:S(e),fragmentShader:r}},"OculusDK1Stereo"),x,{})}}),define("DS/ShaderBuilders/PostPro/PreConvolutionShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterV3(n),h=n=>u.parameterV4(n),g=(n,e,t)=>m.declareFunction(n,e,t),v=(n,e,t)=>m.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},C=n=>o.addVarying(n),P=n=>o.getVarying(n,o.ShaderStages.in),N=n=>o.getVarying(n,o.ShaderStages.out),M=(n,e)=>m.sample2DTexture(n,e);class b extends e{constructor(n=0){super(n),this.roughness=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.roughness,this.roughness)}clone(){var n=new b;return n.roughness=this.roughness,n}}class w extends b{constructor(){super(1),this.firstSample=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1i(r.firstSample,this.firstSample)}clone(){var n=new w;return n.empty=this.empty,n.firstSample=this.firstSample,n}}const U={NB_SAMPLES:256,NB_SAMPLES_IT:256,DP_SCALE:1.2,LOD_CST:7.707519,MODE:0,MAX_LOD:9};function z(n,e){const t=n.customDefines,r=0===t.MODE,a=1===t.MODE,o=2===t.MODE,i=3===t.MODE,s=4===t.MODE;return`\n        \n        ${C({varyingName:"vUv",varyingType:"v2"})}\n        ${e?`\n            ${$({uniformName:"tEnvMap",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tPrevEnvMap",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"firstSample",uniformType:"i"})}\n            `:`\n            ${$({uniformName:"tEnvMap",uniformType:"t2",locationName:"tInput"})}\n            `}\n        ${$({uniformName:"roughness",uniformType:"f"})}\n\n        ${y("CLAMP_VALUE")} = 1000.0;\n        ${y("PI")}  = 3.14159265358979323846264;\n        ${y("INV_GOLDEN_RATIO")}  = 0.6180339887;\n        ${y("dpScale")} = ${t.DP_SCALE};\n        ${y("fMAX_LOD")} = ${x()}(${t.MAX_LOD});\n        \n        ${g("ComputeIndex","f",[p("id"),p("N")])}{\n            ${x("val")}  = id * N * 24.0;\n            ${x("n")} = val / N;\n            ${x("m")} = mod(val, N);\n            return n + m;\n        }\n\n        ${g("LowDiscrepancy2D","v2",[p("i"),p("N")])}\n        {\n            ${x("id")}  = ${v("ComputeIndex","f",[p("i"),p("N")])};\n            return ${_()}(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));\n        }\n\n        ${g("vLogComplex","v2",[p("value")])}{\n            ${x("real")}  = log(abs(value));\n            ${x("im")}  = atan(0.0,value);\n            return ${_()}(real,im);\n        }\n\n        ${g("invComplex","v2",[d("value")])}{\n            return ${_()}(value.x,-value.y)/(value.x * value.x + value.y * value.y);\n        }\n        \n        ${g("AshikminDistribution","f",[p("NoH"),p("sheenValue")])}{          \n            // cos^2\n            ${x("cosine2")}  = max(NoH * NoH,1e-6);\n            // sin^2\n            ${x("sine2")}  = max(1.0-cosine2,1e-6);\n            //\n            ${x("D")}  = 1.0;\n            ${x("normalisationTerm")}  = 1.0;\n            ${x("a2")}  = sheenValue * sheenValue;\n            normalisationTerm *= 1.0/(4.0*a2+1.0);\n            // sin^4\n            ${x("sine4")}  = max(sine2 * sine2,1e-6);\n            // cotan^2\n            ${x("cotan2")}  = cosine2/sine2;\n            ${x("value")}  = -cotan2 / a2;\n            // result\n            D = 1.0+4.0 * exp(value)/ sine4;\n            return D * normalisationTerm;\n        }\n\n        ${g("GetLightVector","v3",[f("N"),f("H")])}{\n            ${i?"return H;":"return 2.0 * dot(N, H) * H - N;"}\n        }\n\n        ${g("GetWeight","f",[p("NoL")])}{\n            if (NoL > 0.0) {            \n                ${r||i?"return NoL;":"return 1.0;"}\n            }\n            return 0.0;\n        }\n\n        ${g("ImportanceSample","v3",[d("Xi"),p("roughness")])}{\n\n            ${T("H")} ;\n            ${x("Phi")}  = 2.0 * PI * Xi.x;\n            ${r?`            \n                ${x("a")}  = roughness * roughness;\n                ${x("a2")}  = a*a;\n                ${x("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n                ${x("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n                `:l}\n            // OLD WAY\n            //#if MODE == 1 // Velvet \n                //${x("a")}  = roughness * roughness;    \n                //${x("interiorTerm")}  = 4.0*a*exp(1.0/a)/(4.0*a*Xi.y + Xi.y - 1.0);\n                //${_("exteriorTerm")}  = a*vLogComplex(interiorTerm);\n                //${_("value")}  = invComplex(exteriorTerm);\n                //${x("val")}  = min(length(value),1.0);\n                //${x("SinTheta")}  = sqrt(val);\n                //${x("CosTheta")}  = sqrt(1.0 - val);\n            //#endif\n            ${o?`         \n                ${x("a")}  = roughness * roughness;   \n                ${x("a2")}  = a*a;\n                // theta = asin(sqrt(8*a2*log(1-iY)/(8*a2*log(1-iY)-1)))\n                ${x("loga")}  = 8.0*a2*log(1.0-Xi.y);\n                ${x("value")}  = loga / (loga - 1.0);\n                ${x("SinTheta")}  = sqrt(value);\n                ${x("CosTheta")}  = sqrt(1.0 - value);\n                `:l}\n            ${i||a?`\n                ${x("value")}  = Xi.y;\n                ${x("SinTheta")}  = sqrt(value);\n                ${x("CosTheta")}  = sqrt(1.0 - value);\n                `:l}\n            ${s?`\n                ${x("a")}  = roughness;\t\t\n                a = max(a, 1e-3);\n                ${x("SinTheta")}  = pow(Xi.y, a / (2.0 * a + 1.0));\n                ${x("CosTheta")}  = sqrt(1.0 - SinTheta*SinTheta);\n                `:l}\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n            return H;\n        }\n\n        ${g("TangentToWorld","v3",[f("Vec"),f("TangentZ")])}{\n\n            ${T("UpVector")}  = ${T()}(1,0,0);\n            if (abs(TangentZ.z) < 0.999) {\n                UpVector = ${T()}(0,0,1);\n            }\n            ${T("TangentX")}  = normalize(cross(UpVector, TangentZ));\n            ${T("TangentY")}  = cross(TangentZ, TangentX);\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        ${g("computeLODFromDirection","f",[f("dir"),p("pdf")])}{\n\n            ${x("d")}  = 2.0 * dpScale;\n            d *= (1.0 + abs(dir.z));\n            d *= d;\n\n            ${x("lod")}  = 0.5 * log2(pdf * d);\n            \n            return max(${t.LOD_CST} - lod, 0.0);\n        }\n\n        ${g("sampleLatLongFromLocation","v3",[f("dir")])}{\n\n            ${x("theta")}  = acos(dir.z);\n            ${x("phi")}  = atan(dir.y, dir.x);\n\n            ${x("u")}  = 0.5 + 0.5 * phi / PI;\n            ${x("v")}  = theta / PI;\n\n            ${D("texelRGBE")}  = ${M("tEnvMap",`${_()}(u, v)`)};\n            return texelRGBE.rgb * pow(2.0, 255.0 * texelRGBE.w - 128.0);\n        }\n\n\n        ${g("ImportanceSamplePDF","v4",[d("Xi"),p("roughness")])}{\n\n            ${T("H")};\n            ${x("Phi")}  = 2.0 * PI * Xi.x;\n            ${x("D")}  = 0.0;\n            ${x("normalisationTerm")}  = 1.0/PI;\n            \n            ${r?`  \n                ${x("a")}  = roughness * roughness;\n                ${x("a2")}  = a*a;\n                ${x("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n                ${x("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n\n                ${x("d")}  = (a2 - 1.0) * CosTheta*CosTheta + 1.0;\n                D = a2 / (PI * d * d);\n                `:l}\n            // OLD WAY\n            //#if MODE == 1 // Velvet\n                //${x("a")}  = roughness * roughness;\n                //${x("interiorTerm")}  = 4.0*a*exp(1.0/a)/(4.0*a*Xi.y + Xi.y - 1.0);\n                //${_("exteriorTerm")}  = a*vLogComplex(interiorTerm);\n                //${_("value")}  = invComplex(exteriorTerm);\t\t\n                //${x("val")}  = min(length(value),1.0);\n                //${x("SinTheta")}  = sqrt(val);\n                //${x("CosTheta")}  = sqrt(1.0-val);\n\n                // cos^2\n                //${x("cosine2")}  = max(CosTheta*CosTheta,1e-6);\n                // sin^2\n                //${x("sine2")}  = max(SinTheta*SinTheta,1e-6);\n                //normalisationTerm *= 1.0/(1.0 + 4.0*a);\n                // sin^4\n                //${x("sine4")}  = max(sine2 * sine2,1e-6);\n                // cotan^2\n                //${x("cotan2")}  = cosine2/sine2;\n                //${x("value2")}  = -cotan2 / a;\n                // result\n                //D = 1.0 + 4.0 * exp(value2)/ sine4;\n                //D *= normalisationTerm;\n            //#endif\n            \n            ${o?`\n                ${x("a")}  = roughness * roughness;\n                ${x("a2")}  = a*a;\n                // theta = asin(sqrt(8*a2*log(1-iY)/(8*a2*log(1-iY)-1)))\n                ${x("loga")}  = 8.0*a2*log(1.0-Xi.y);\n                ${x("value")}  = loga / (loga - 1.0);\n                ${x("SinTheta")}  = sqrt(value);\n                ${x("CosTheta")}  = sqrt(1.0 - value);\n\n                // cos^2\n                ${x("cosine2")}  = max(CosTheta*CosTheta,1e-6);\n                // sin^2\n                ${x("sine2")}  = max(SinTheta*SinTheta,1e-6);\n                normalisationTerm *= 1.0/(8.0*a2);\n                // cos^4\n                ${x("cosine4")}  = max(cosine2 * cosine2,1e-6);\n                // cotan^2\n                ${x("tan2")}  = sine2/cosine2;\n                ${x("value2")}  = -tan2/(a2*8.0);\n                // result\n                D = exp(value2) / cosine4 ;\n                D *= normalisationTerm ;\n                `:l}\n            ${i||a?`\n                ${x("value")}  = Xi.y;\n                ${x("SinTheta")}  = sqrt(value);\n                ${x("CosTheta")}  = sqrt(1.0 - value);\n                D = normalisationTerm;\n                `:l}\n            ${s?`\n                ${x("a")}  = roughness;\t\t\n                a = max(a, 1e-3);\n                ${x("SinTheta")}  = max(pow(Xi.y, a / (2.0 * a + 1.0)),1e-3);\n                ${x("CosTheta")}  = sqrt(1.0 - SinTheta*SinTheta);\n                normalisationTerm *= 0.5;\n                // result\n                D = (2.0 + 1.0 / a) * pow(SinTheta, 1.0 / a) ;\n                D *= normalisationTerm ;\n                `:l}\n\n            ${x("PDF")}  = D * CosTheta;\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n\n            return ${D()}(H, PDF);\n        }\n\n        ${g("sampleDualParaboloidFromLocation","v3",[f("dir"),p("lod")])}{\n\n            ${_("st")}  = ${_()}(0.5);\n\n            if (dir.z < 0.0) {\n\n                st *= 0.5 * (1.0 - dir.xy / (dpScale * (1.0 - dir.z)));\n\n            } else {\n\n                st *= 0.5 * (1.0 + dir.xy / (dpScale * (1.0 + dir.z)));\n                st.x += 0.5;\n            }\n\n            ${x("mipValue")}  = floor(lod);\n            ${x("mipNextValue")}  = mipValue + 1.0;\n            ${x("mipCoef")}  = fract(lod);\n\n            if (lod >= fMAX_LOD) {\n\n                mipValue = fMAX_LOD;\n                mipNextValue = fMAX_LOD;\n                mipCoef = 1.0;\n            }\n\n            ${T("color1")} ;\n            ${T("color2")} ;\n\n            ${_("uv1")}   = st;\n            ${_("uv2")}   = st;\n\n            ${x("scale1")}  = pow(2.0, -mipValue);\n            ${x("scale2")}  = pow(2.0, -mipNextValue);\n\n            uv1 *= scale1;\n            uv2 *= scale2;\n\n            uv1.y += 1.0 - scale1;\n            uv2.y += 1.0 - scale2;\n\n            color1 = ${M("tEnvMap","uv1")}.xyz;\n            color2 = ${M("tEnvMap","uv2")}.xyz;\n\n            return mix(color1, color2, mipCoef);\n        }\n\n        ${g("GetFilteredColor","v3",[f("L"),h("perturbedZ_PDF"),f("H"),f("N"),p("roughness"),p("NoL")])}{\t\t\n            ${x("factor")} = perturbedZ_PDF.w;\n            ${i?l:"factor /= (4.0 * clamp(dot(L,H),1e-6,1.0));"}\n            ${x("lod")}  = ${v("computeLODFromDirection","f",[f("L"),p("factor")])};\n            ${T("filteredColor")} = ${v("sampleDualParaboloidFromLocation","v3",[f("L"),p("lod")])};\n            filteredColor  = min(filteredColor, ${T()}(CLAMP_VALUE));\n            ${a?`\n                ${x("NoH")} = clamp(dot(N,H),1e-6,1.0);\n                filteredColor *= ${v("AshikminDistribution","f",[p("NoH"),p("roughness")])};\n                `:l}\n            return filteredColor;\n        }\n        `}function V(n){return`\n            ${_("screenUV")} = ${P("vUv")};\n            ${x("sampledRoughness")} = ${c("roughness")};\n            ${x("phi")}  = PI * (2.0 * screenUV.x - 1.0);\n            ${x("theta")}  = PI * screenUV.y;\n\n            // Cartesian components\n            ${T("N")};\n            N.x = sin(theta) * cos(phi);\n            N.y = sin(theta) * sin(phi);\n            N.z = cos(theta);\n        `}function F(e){return`           \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart()}\n                ${N("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd()}\n        `}return{Normal:new r(new t(function(n,e){const t=e.customDefines.NB_SAMPLES,r=o.getShaderOutput("out0");let a=`\n\n            ${z(e,!1)}\n\n            ${g("prefilterEnvMap","v3",[p("roughness"),f("N")])}{\n\n                ${T("filteredColor")} ;\n                ${x("weight")}  = 0.0;\n\n                ${x("fSamples")} = float(${t});\n                ${T("clampValue")} = ${T()}(CLAMP_VALUE);\n                for (${S("i")} = 0; i < ${t}; i++) {\n                    ${x("fI")} = ${x()}(i);\n                    ${_("E")} = ${v("LowDiscrepancy2D","v2",[p("fI"),p("fSamples")])};\n                    ${T("perturbedZ")}  = ${v("ImportanceSample","v3",[d("E"),p("roughness")])};\n                    ${T("H")}  = ${v("TangentToWorld","v3",[f("perturbedZ"),f("N")])};\n                    ${T("L")}  = ${v("GetLightVector","v3",[f("N"),f("H")])};\n\n                    ${x("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${x("w")}  = ${v("GetWeight","f",[p("NoL")])};\n                    filteredColor += w * min(${v("sampleLatLongFromLocation","v3",[f("L")])}, clampValue);\n                    weight += w;\n                }\n\n                return filteredColor / max(weight, 0.001);\n            }\n\n            ${m.getMainFragmentStart()}\n                ${V()}\n                ${r} = ${D()}(${v("prefilterEnvMap","v3",[p("sampledRoughness"),f("N")])}, 1.0);           \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:F(e),fragmentShader:a}},"PreConvolution"),b,U),FIS:new r(new t(function(n,e){const t=e.customDefines.NB_SAMPLES,r=o.getShaderOutput("out0");let a=`\n\n            ${z(e,!1)}\n\n            ${g("prefilterEnvMap","v3",[p("roughness"),f("N")])}{\n\n                ${T("filteredColor")} ;\n                ${x("weight")}  = 0.0;\n\n                ${x("fSamples")} = float(${t});\n                for (${S("i")} = 0; i < ${t}; i++) {\n                    ${x("fI")} = ${x()}(i);\n                    ${_("E")} = ${v("LowDiscrepancy2D","v2",[p("fI"),p("fSamples")])};\n                    ${D("perturbedZ_PDF")}  = ${v("ImportanceSamplePDF","v4",[d("E"),p("roughness")])};\n                    ${T("H")}  = ${v("TangentToWorld","v3",[f("perturbedZ_PDF.xyz"),f("N")])};\n                    ${T("L")}  = ${v("GetLightVector","v3",[f("N"),f("H")])};\n\n                    ${x("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${x("w")}  = ${v("GetWeight","f",[p("NoL")])};\n                    filteredColor += w * ${v("GetFilteredColor","v3",[f("L"),h("perturbedZ_PDF"),f("H"),f("N"),p("roughness"),p("NoL")])};\n                    weight += w;\n                }\n\n                return filteredColor / max(weight, 0.001);\n            }\n\n            ${m.getMainFragmentStart()}\n                ${V()}\n                ${r} = ${D()}(${v("prefilterEnvMap","v3",[p("sampledRoughness"),f("N")])}, 1.0);    \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:F(e),fragmentShader:a}},"PreConvolutionFIS"),b,U),Iterative:new r(new t(function(n,e){var t=e.customDefines;const r=t.NB_SAMPLES,a=t.NB_SAMPLES_IT,i=o.getShaderOutput("out0");let s=`\n\n            ${z(e,!0)}\n            \n            ${g("prefilterEnvMap","v4",[p("roughness"),f("N")])} {\n\n                ${T("filteredColor")} ;\n                ${x("weight")}  = 0.0;\n\n                ${x("fSamples")} = float(${r});\n                for (${S("i")} = 0; i < ${a}; i++) {\n                    ${x("fI")}  = ${x()}(${c("firstSample")} + i);\n                    ${_("E")} = ${v("LowDiscrepancy2D","v2",[p("fI"),p("fSamples")])};\n                    ${D("perturbedZ_PDF")}  = ${v("ImportanceSamplePDF","v4",[d("E"),p("roughness")])};\n                    ${T("H")}  = ${v("TangentToWorld","v3",[f("perturbedZ_PDF.xyz"),f("N")])};\n                    ${T("L")}  = ${v("GetLightVector","v3",[f("N"),f("H")])};\n\n                    ${x("NoL")}  = clamp(dot(N, L), 0.0, 1.0);\n\n                    ${x("w")}  = ${v("GetWeight","f",[p("NoL")])};\n                    filteredColor += w * ${v("GetFilteredColor","v3",[f("L"),h("perturbedZ_PDF"),f("H"),f("N"),p("roughness"),p("NoL")])};\n                    weight += w;\n                }\n\n                return ${D()}(filteredColor / max(weight, 0.001),max(weight, 0.001));\n            }\n\n            ${m.getMainFragmentStart()}\n                ${V()}\n                \n\t\t\t\t${D("prevTex")}  = ${M("tPrevEnvMap","screenUV")};\n\t\t\t\t${D("res")}  = ${v("prefilterEnvMap","v4",[p("sampledRoughness"),f("N")])};\n                ${i} = ${D()}((prevTex.rgb * prevTex.a + res.rgb * res.a) / (prevTex.a + res.a), prevTex.a + res.a);           \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:F(e),fragmentShader:s}},"PreConvolutionIT"),w,U)}}),define("DS/ShaderBuilders/PostPro/EncodingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>l.parameterV3(n),c=n=>l.parameterV4(n),p=(n,e,t)=>u.declareFunction(n,e,t),d=(n,e,t)=>u.callFunction(n,e,t),f=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},S=n=>o.addVarying(n),x=n=>o.getVarying(n,o.ShaderStages.in),y=n=>o.getVarying(n,o.ShaderStages.out),_=(n,e)=>u.sample2DTexture(n,e);class T extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new T}}function D(e){return`\n        \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${y("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}return{EncodeHDR:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${m({uniformName:"tInput",uniformType:"t2"})}\n\n            ${p("GetHDREncoded","v4",[$("color")])} {\n                ${f("value")} = max(color.r, max(color.g, color.b));\n                if (value < 1e-6) return ${v()}(0.0, 0.0, 0.0, 1.0);\n                // in [-128..127]\n                ${f("exponent")}  = clamp(ceil(log2(value)), -128.0, 127.0);\n\n                return ${v()}(color * pow(2.0, -exponent), (exponent + 128.0) / 255.0);\n            }\n\n            void main() {\n                ${h("screenUV")} = ${x("vUv")};\n                ${g("color")}  = ${_("tInput","screenUV")}.rgb;\n                ${t} = ${d("GetHDREncoded","v4",[$("color")])};\n            }\n        `;return{vertexShader:D(e),fragmentShader:r}},"EncodeHDR"),T,{}),DecodeDepth:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${S({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${m({uniformName:"tInput",uniformType:"t2"})}\n\n\n            void main() {\n                ${h("screenUV")} = ${x("vUv")};\n                ${v("packedDepth")}  = ${_("tInput","screenUV")};\n                ${t} = ${v()}(0.0);\n                gl_FragDepthEXT = ${d("unpackRGBA","f",[c("packedDepth")])};\n            }\n        `;return{vertexShader:D(e),fragmentShader:r}},"DecodeDepth"),T,{})}}),define("DS/ShaderBuilders/PostPro/BloomShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=(i.ParameterUtils,i.FunctionHandler),m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>u.sample2DTexture(n,e);class x extends e{constructor(){super(5),this.bloomFactor=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.bloomFactor,this.bloomFactor)}clone(){return new x}}function y(e){return`           \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}return{Blending:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput0",uniformType:"t2"})}\n            ${m({uniformName:"tInput1",uniformType:"t2"})}\n            ${m({uniformName:"tInput2",uniformType:"t2"})}\n            ${m({uniformName:"tInput3",uniformType:"t2"})}\n            ${m({uniformName:"tInput4",uniformType:"t2"})}\n            ${m({uniformName:"tInput5",uniformType:"t2"})}\n\n\n            ${u.getMainFragmentStart()}\n                ${p("screenUV")} = ${g("vUv")};\n                ${f("color")} = ${S("tInput0","screenUV")};\n                ${f("bloom1")}  = ${S("tInput1","screenUV")};\n                ${f("bloom2")}  = ${S("tInput2","screenUV")};\n                ${f("bloom3")}  = ${S("tInput3","screenUV")};\n                ${f("bloom4")}  = ${S("tInput4","screenUV")};\n                ${f("bloom5")}  = ${S("tInput5","screenUV")};\n\n                ${d("bloom")}  = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;\n\n                ${c("bloomFactor")}  = 0.9;\n\t\t\t\t${d("result")}  = color.rgb + bloomFactor * bloom;\n\t\t\t\t${c("maxComponent")}  = max(result.x, max(result.y, result.z));\n\t\t\t    if (maxComponent > 1.0) { result /= maxComponent; }\n\n                ${t} = ${f()}(result, color.a);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:y(e),fragmentShader:r}},"BloomBlend"),x,{}),Mix:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput0",uniformType:"t2"})}\n            ${t.USE_BLOOM>=1?`\n                ${m({uniformName:"tInput1",uniformType:"t2"})}\n                ${t.USE_BLOOM>=2?`\n                    ${m({uniformName:"tInput2",uniformType:"t2"})}\n                    ${m({uniformName:"tInput3",uniformType:"t2"})}\n                    ${m({uniformName:"tInput4",uniformType:"t2"})}\n                    ${m({uniformName:"tInput5",uniformType:"t2"})}\n                    `:l}\n                `:l}\n            ${m({uniformName:"bloomFactor",uniformType:"f"})}\n\n\n            ${u.getMainFragmentStart()}\n                ${p("screenUV")} = ${g("vUv")};\n                ${f("color")} = ${S("tInput0","screenUV")};\n                ${d("rgb")} = color.rgb;\n                ${c("factor")} = ${$("bloomFactor")};\n                ${t.USE_BLOOM>=1?`\n                    ${f("bloom1")}  = ${S("tInput1","screenUV")};\n                    ${t.USE_BLOOM>=2?`\n                        ${f("bloom2")}  = ${S("tInput2","screenUV")};\n                        ${f("bloom3")}  = ${S("tInput3","screenUV")};\n                        ${f("bloom4")}  = ${S("tInput4","screenUV")};\n                        ${f("bloom5")}  = ${S("tInput5","screenUV")};\n\n                        ${d("bloom")}  = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;\n                        rgb += factor * bloom;\n                        `:"\n                        rgb += factor * bloom1.rgb;\n                        "}\n                    `:l}\n                ${r} = ${f()}(rgb, color.a);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:y(e),fragmentShader:a}},"BloomMix"),x,{USE_BLOOM:0})}}),define("DS/ShaderBuilders/PostPro/CompositeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV3(n),f=(n,e,t)=>m.declareFunction(n,e,t),h=(n,e,t)=>m.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},T=n=>o.addVarying(n),D=n=>o.getVarying(n,o.ShaderStages.in),C=n=>o.getVarying(n,o.ShaderStages.out),P=n=>o.getBuiltin(n,o.ShaderStages.out),N=n=>o.getBuiltin(n,o.ShaderStages.in),M=(n,e)=>m.sample2DTexture(n,e);class b extends e{constructor(){super(1),this.gradingMap=null,this.gradingDepth=16,this.brightness=0,this.gamma=2.2,this.crushblacks=0,this.burnhighlights=0,this.saturation=1,this.colorCorrection=new n.Vector3(1,1,1),this.power=0,this.sensorSize=35,this.screenRatio=1,this.focalLength=38.6}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),e.loadTexture(t,r.gradingMap,this.gradingMap),t.uniform1f(r.gradingDepth,this.gradingDepth),t.uniform1f(r.brightness,this.brightness),t.uniform1f(r.gamma,this.gamma),t.uniform1f(r.crushblacks,this.crushblacks),t.uniform1f(r.burnhighlights,this.burnhighlights),t.uniform1f(r.saturation,this.saturation),t.uniform3f(r.colorCorrection,this.colorCorrection.x,this.colorCorrection.y,this.colorCorrection.z),t.uniform1f(r.power,this.power),t.uniform1f(r.sensorSize,this.sensorSize),t.uniform1f(r.screenRatio,this.screenRatio),t.uniform1f(r.focalLength,this.focalLength)}clone(){return new b}}const w={NONE:-1,FILMIC:0,PHOTOGRAPHIC:1,UNCHARTED:2,REINHARD:3},U={NONE:-1,GAMMA_SIMPLE:0,GAMMA:1,SRGB:2};const z={USE_AUTO_EXPOSURE:0,COLOR_GRADING:!1,COLOR_TONEMAP:w.NONE,COLOR_CORRECTION:U.GAMMA_SIMPLE};return{CompositingShader:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.COLOR_CORRECTION===U.GAMMA_SIMPLE,i=t.COLOR_CORRECTION===U.GAMMA,s=t.COLOR_CORRECTION===U.SRGB,u=t.COLOR_TONEMAP===w.FILMIC,b=t.COLOR_TONEMAP===w.PHOTOGRAPHIC,z=t.COLOR_TONEMAP===w.UNCHARTED,V=t.COLOR_TONEMAP===w.REINHARD;let F=`\n            \n            ${T({varyingName:"vUv",varyingType:"v2"})}\n\n            ${$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            \n            ${$({uniformName:"brightness",uniformType:"f"})}\n            ${t.USE_AUTO_EXPOSURE>0?`\n                ${$({uniformName:"tAutoExposure",uniformType:"t2",locationName:"tInput1"})}\n                `:l}\n\n            ${t.COLOR_GRADING?`          \n                ${$({uniformName:"gradingMap",uniformType:"t2"})}\n                ${$({uniformName:"gradingDepth",uniformType:"f"})}\n                `:l}\n\n            ${$({uniformName:"gamma",uniformType:"f"})}\n    \n            ${$({uniformName:"crushblacks",uniformType:"f"})}\n            ${$({uniformName:"burnhighlights",uniformType:"f"})}\n            ${$({uniformName:"saturation",uniformType:"f"})}\n            ${$({uniformName:"colorCorrection",uniformType:"v3"})}\n            \n            ${$({uniformName:"power",uniformType:"f"})}\n            ${$({uniformName:"sensorSize",uniformType:"f"})}\n            ${$({uniformName:"screenRatio",uniformType:"f"})}\n            ${$({uniformName:"focalLength",uniformType:"f"})}\n\n            ${u?`\n                ${S("FILMIC_NRE_A")} = 0.22;\n                ${S("FILMIC_NRE_B")} = 0.3;\n                ${S("FILMIC_NRE_C")} = 0.1;\n                ${S("FILMIC_NRE_D")} = 0.2;\n                ${S("FILMIC_NRE_E")} = 0.01;\n                ${S("FILMIC_NRE_F")} = 0.3;\n                ${S("FILMIC_NRE_W")} = 11.2;\n                `:l}\n\n            ${b?`\n                ${f("luminance_RGB","f",[d("iColor")])} {\n                    return dot(iColor,${y()}(0.176204,0.812985,0.0108109));\n                }\n                `:l}\n\n            ${z?`\n                ${S("A")} = 0.15;\n                ${S("B")} = 0.50;\n                ${S("C")} = 0.10;\n                ${S("D")} = 0.20;\n                ${S("E")} = 0.02;\n                ${S("F")} = 0.20;\n                ${S("W")} = 11.2;\n                ${f("Uncharted2Tonemap","v3",[d("x")])} {\n                    return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n                }\n                `:l}\n\n            ${S("dither")} = 0.004;\n\n            ${f("random","f",[d("scale"),p("seed"),d("seed2")])} {\n                return fract(sin(dot(seed2 + seed, scale)) * 43758.5453 + seed);\n            }\n\n            ${f("Random3D","v3",[p("seed"),d("seed2")])} {\n                ${y("res")};\n\n                res.x = ${h("random","f",[d(`${y()}(12.9898, 78.233, 151.7182)`),p("seed"),d("seed2")])};\n                res.y = ${h("random","f",[d(`${y()}(63.7264, 10.873, 623.6736)`),p("seed"),d("seed2")])};\n                res.z = ${h("random","f",[d(`${y()}(125.5736, 34.485, 437.2873)`),p("seed"),d("seed2")])};\n\n                return res;\n            }\n\n            ${S("fAutoExposureCount")} = ${v()}(${t.USE_AUTO_EXPOSURE});\n\n            ${m.getMainFragmentStart()}\n                ${x("screenUV")} = ${D("vUv")};\n\n                ${_("inColorSampled")} = ${M("tScene","screenUV")};\n                ${v("inColorAlpha")} = inColorSampled.a;\n                ${y("inColor")} = inColorSampled.rgb * pow(2.0, ${c("brightness")});\n                ${t.USE_AUTO_EXPOSURE>0?`\n                    ${x("ae_uv")} = ${x()}(0.0);\n                    ${x("sums")} = ${x()}(0.0);\n                    for (${g("i")} = 0; i < ${t.USE_AUTO_EXPOSURE}; i++) {\n                        ae_uv.x = (0.5+${v()}(i))/fAutoExposureCount;\n                        for (${g("j")} = 0; j < ${t.USE_AUTO_EXPOSURE}; j++) {\n                            ae_uv.y = (0.5+${v()}(j))/fAutoExposureCount;\n                            sums += ${M("tAutoExposure","ae_uv")}.rg;\n                        }\n                    }\n                    inColor *= 0.2176/exp(sums.x/sums.y);\n                    `:l}\n                // Vignetting\n                ${x("pos")} = (screenUV - 0.5) * 0.5;\n                pos.y = pos.y * ${c("screenRatio")};\n\n                ${v("f2")} = ${c("focalLength")} * ${c("focalLength")};\n                ${v("s2")} = ${c("sensorSize")} * ${c("sensorSize")};\n                ${v("vignetting")}  = pow(f2/(s2*(pos.x*pos.x+pos.y*pos.y)+f2),${c("power")});\n                \n                inColor *= vignetting;\n                inColorAlpha = max(inColorAlpha, (1.0-sqrt(vignetting)));\n\n                // Tone Mapping\n\n                ${y("outColor")} = inColor;\n\n                ${V?"\n                    outColor = inColor / (1.0 + inColor);\n                    ":l}\n                ${u?`\n                    ${_("tmpCol")}  = ${_()}(inColor.xyz, FILMIC_NRE_W);\n                    tmpCol = ((tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_C*FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_E)\n                            /(tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_F))\n                            -FILMIC_NRE_E/FILMIC_NRE_F;\n                    outColor = tmpCol.xyz/tmpCol.w;\n                    `:l}\n                ${z?`\n                    ${v("ExposureBias")} = 2.0;\n                    ${y("curr")} = ${h("Uncharted2Tonemap","v3",[d("ExposureBias * inColor")])};\n                    ${y("whiteScale")}  = 1.0 / ${h("Uncharted2Tonemap","v3",[d(`${y("W")}`)])};\n                    outColor = curr * whiteScale;\n                    `:l}\n                ${b?`\n                    ${y("c")} = inColor * ${c("colorCorrection")};\n                    c *= (c*${c("burnhighlights")}+1.0)/(c+1.0);\n                    ${v("lumC")} = ${h("luminance_RGB","f",[d("c")])};\n                    c = mix(${y()}(lumC),c,${c("saturation")});\n                    lumC = ${h("luminance_RGB","f",[d("c")])};\n                    if (lumC < 1.0) {\n                        ${y("_crushblacks")} = ${y()}(2.0 * ${c("crushblacks")} +1.0);\n                        lumC = sqrt(lumC);\n                        ${v("oms2")}  = 1.0 - lumC;\n                        c = c*lumC + pow(c,_crushblacks)*oms2;\n                    }\n                    outColor = c;\n                    `:l}\n\n                // Gamma\n                ${a?"\n                    outColor = sqrt( outColor );\n                    ":l}\n                ${i?`\n                    outColor = pow( outColor, ${y()}( 1.0 / ${c("gamma")} ) );\n                    `:l}\n                ${s?"\n                    if (outColor.r < 0.0031308) {\n                        outColor.r = outColor.r*12.92;\n                    } else {\n                        outColor.r = 1.055*pow(outColor.r,1.0/2.4)-0.055;;\n                    }\n                    if (outColor.g < 0.0031308) {\n                        outColor.g = outColor.g*12.92;\n                    } else {\n                        outColor.g = 1.055*pow(outColor.g,1.0/2.4)-0.055;;\n                    }\n                    if (outColor.b < 0.0031308) {\n                        outColor.b = outColor.b*12.92;\n                    } else {\n                        outColor.b = 1.055*pow(outColor.b,1.0/2.4)-0.055;;\n                    }\n                    ":l}\n                // Color Grading\n\n                ${t.COLOR_GRADING?`\n                    //NRE does this I don't know why and can't make it work with it\n                    //float threshold = gradingDepth/(gradingDepth-1.0);\n                    ${v("gradingDepth_")} = ${c("gradingDepth")};\n                    ${v("threshold")}  = (gradingDepth_-1.0)/gradingDepth_;\n                    ${v("halfTexelOffset")}  = 0.5/gradingDepth_;\n                    ${v("r")} = clamp (outColor.r,0.0,1.0) * threshold + halfTexelOffset;\n                    ${v("g")} = clamp (outColor.g,0.0,1.0) * threshold + halfTexelOffset;\n                    ${v("b")} = clamp (outColor.b,0.0,1.0) *(gradingDepth_ - 1.0);\n                    ${v("bFloor")}  = floor(b);\n                    ${v("bFract")}  = b-bFloor;\n                    ${x("uv1")}  = ${x()}((bFloor+r)/(gradingDepth_),g);\n                    ${x("uv2")}  = ${x()}((bFloor+1.0+r)/(gradingDepth_),g);\n                    ${y("c1")}  = ${M("gradingMap","uv1")}.rgb;\n                    ${y("c2")}  = ${M("gradingMap","uv2")}.rgb;\n                    outColor = bFract*c2+(1.0-bFract)*c1;\n                    `:l}\n\n                // Dithering\n                outColor += 2.0 * dither * (${h("Random3D","v3",[p("screenUV.x + screenUV.y"),d(`${N("fragCoord")}.xyz`)])} - 0.5);\n                //\n                ${r} = ${_()}(outColor, inColorAlpha);           \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:function(n){return`           \n            ${T({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart()}\n                ${_("pos")} = vec4( sign( position_.xy ), 0.0, 1.0 );\n                ${C("vUv")} = 0.5 * pos.xy + 0.5;\n                ${n.WebGPU?`${C("vUv")}=${x()}(${C("vUv")}.x,-${C("vUv")}.y);`:l}\n                ${P("position")} = pos;\n            ${m.getMainVertexEnd()}\n        `}(e),fragmentShader:F}},"Compositing"),b,z),ToneMapEnum:w,ColorCorrectionEnum:U}}),define("DS/ShaderBuilders/PostPro/SkyScatteringShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=()=>s.dereference(),$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=(n,e,t=!1)=>l.parameter(n,e,t),d=n=>l.parameterB(n),f=n=>l.parameterInOutB(n),h=n=>l.parameterRefB(n),g=n=>l.parameterF(n),v=n=>l.parameterInOutF(n),S=n=>l.parameterRefF(n),x=n=>l.parameterV2(n),y=n=>l.parameterV3(n),_=n=>l.parameterInOutV3(n),T=n=>l.parameterRefV3(n),D=n=>l.parameterV4(n),C=n=>l.parameterInOutV4(n),P=n=>l.parameterRefV4(n),N=n=>l.parameterT2(n),M=n=>p("densityProfileLayer",n,!0),b=n=>p("densityProfile",n,!0),w=(n,e,t)=>u.declareFunction(n,e,t),U=(n,e,t)=>u.callFunction(n,e,t),z=(n=null,e=0)=>{var t={name:n,size:e};return s.bool(t)},V=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},F=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},R=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},A=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},I=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},L=n=>o.addVarying(n),B=n=>o.getVarying(n,o.ShaderStages.in),k=n=>o.getVarying(n,o.ShaderStages.out),E=n=>o.getBuiltin(n,o.ShaderStages.out),O=(n,e)=>u.sample2DTexture(n,e),G=444e-8,H=6370,X=H+100,W=new n.Vector3(.0058,.0135,.0331),j=.003996,q=.8,Z=.004675,J=new n.Vector3(1.474,1.8504,1.91198),Y=new n.Vector2(1/256,1/64),K=new n.Vector4(1/8,1/32,1/128,1/32),Q=new n.Vector4(8,32,128,32);class nn extends e{constructor(){super(4),this.atmBottom=H,this.atmTop=X,this.rayleighScattering=W,this.mieScattering=j,this.transInvSize=Y,this.scatteringInvSize=K,this.scatteringSize=Q}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.atmBottom,this.atmBottom),t.uniform1f(r.atmTop,this.atmTop),t.uniform3f(r.rayleighScattering,this.rayleighScattering.x,this.rayleighScattering.y,this.rayleighScattering.z),t.uniform1f(r.mieScattering,this.mieScattering),t.uniform2f(r.transInvSize,this.transInvSize.x,this.transInvSize.y),t.uniform4f(r.scatterInvSize,this.scatteringInvSize.x,this.scatteringInvSize.y,this.scatteringInvSize.z,this.scatteringInvSize.w),t.uniform4f(r.scatterSize,this.scatteringSize.x,this.scatteringSize.y,this.scatteringSize.z,this.scatteringSize.w)}clone(){return new nn}}function en(n){return`\n            ${$({uniformName:"atmBottom",uniformType:"f"})}\n            ${$({uniformName:"atmTop",uniformType:"f"})}\n            ${$({uniformName:"rayleighScattering",uniformType:"v3"})}\n            ${$({uniformName:"mieScattering",uniformType:"f"})}           \n            //\n            ${$({uniformName:"tDiffuse",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"tTrans",uniformType:"t2",locationName:"tInput2"})}\n            ${$({uniformName:"transInvSize",uniformType:"v2"})}\n            ${$({uniformName:"tIrr",uniformType:"t2",locationName:"tInput3"})}\n            ${$({uniformName:"tScatter",uniformType:"t2",locationName:"tInput4"})}\n            ${$({uniformName:"scatterSize",uniformType:"v4"})}\n            ${$({uniformName:"scatterInvSize",uniformType:"v4"})}\n\n            ${F("PI")} = 3.14159265358979323846264;\n\n            ${w("SafeSqrt","f",[g("a")])}{\n\t\t\t    return sqrt(max(a, 0.0));\n\t\t\t}\n\t\t\t\n            ${w("ClampDistance","f",[g("d")])}{\n\t\t\t\treturn max(d, 0.0);\n\t\t\t}\n\t\t\t\n            ${w("ClampCosine","f",[g("mu")])}{\n\t\t\t    return clamp(mu, -1.0, 1.0);\n\t\t\t}\n\t\t\t\n            ${w("ClampRadius","f",[g("r")])}{\n\t\t\t    return clamp(r, ${c("atmBottom")}, ${c("atmTop")});\n\t\t\t}\n\t\t\t\n            ${w("GetTextureCoordFromUnitRange","f",[g("x"),g("inv_size")])}{\n\t\t\t\treturn 0.5 * inv_size + x * (1.0 - inv_size);\n\t\t\t}\n            ${w("GetUnitRangeFromTextureCoord","f",[g("u"),g("inv_size")])}{\n\t\t\t\treturn (u - 0.5 * inv_size) / (1.0 - inv_size);\n\t\t\t}\n\t\t\t\n            ${w("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])}{\n\t\t\t    ${V("discriminant")}  = r * r * (mu * mu - 1.0) + ${c("atmTop")} * ${c("atmTop")};\n                ${V("safe")} = ${U("SafeSqrt","f",[g("discriminant")])};\n\t\t\t    return ${U("ClampDistance","f",[g("-r * mu + safe")])};\n\t\t\t}\n\t\t\t\n            ${w("DistanceToBottomAtmosphereBoundary","f",[g("r"),g("mu")])}{\n\t\t\t    ${V("discriminant")}  = r * r * (mu * mu - 1.0) +${c("atmBottom")} * ${c("atmBottom")};\n                ${V("safe")} = ${U("SafeSqrt","f",[g("discriminant")])};\n\t\t\t    return ${U("ClampDistance","f",[g("-r * mu + safe")])};\n\t\t\t}\n\t\t\t\n            ${w("GetLayerDensity","f",[M("layer"),g("altitude")])}{\n\t\t\t    ${V("density")}  = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;\n\t\t\t    return clamp(density, 0.0, 1.0);\n\t\t\t}\n\t\t\t\n            ${w("GetProfileDensity","f",[b("profile"),g("altitude")])}{\n                if (altitude < profile.layer0.width) {\n                    return ${U("GetLayerDensity","f",[M("profile.layer0"),g("altitude")])};\n                }\n                return ${U("GetLayerDensity","f",[M("profile.layer1"),g("altitude")])};\n\t\t\t}\n\t\t\t\n            ${w("RayIntersectsGround","b",[g("r"),g("mu")])}{\n\t\t\t    return mu < 0.0 && r * r * (mu * mu - 1.0) + ${c("atmBottom")} * ${c("atmBottom")} >= 0.0;\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceTextureUvFromRMu","v2",[g("r"),g("mu"),x("invSize")])}{\n                ${V("atmBottom2")} = ${c("atmBottom")} * ${c("atmBottom")};\n                ${V("atmTop2")} = ${c("atmTop")} * ${c("atmTop")};\n\t\t\t    // Distance to top atmosphere boundary for a horizontal ray at ground level.\n\t\t\t    ${V("H")} = sqrt(atmTop2 - atmBottom2);\n\t\t\t    // Distance to the horizon.\n                ${V("rhoInput")} = r * r - atmBottom2;\n\t\t\t    ${V("rho")} = ${U("SafeSqrt","f",[g("rhoInput")])};\n\t\t\t    // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum\n\t\t\t    // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon).\n\t\t\t    ${V("d")}  = ${U("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])};\n\t\t\t    ${V("d_min")}  = ${c("atmTop")} - r;\n\t\t\t    ${V("d_max")}  = rho + H;\n\t\t\t    ${V("x_mu")}  = (d - d_min) / (d_max - d_min);\n\t\t\t    ${V("x_r")}  = rho / H;\n                ${R("uv")} = ${R()}(0.0, 0.0);\n                uv.x = ${U("GetTextureCoordFromUnitRange","f",[g("x_mu"),g("invSize.x")])};\n                uv.y = ${U("GetTextureCoordFromUnitRange","f",[g("x_r"),g("invSize.y")])};\n\t\t\t    return uv;\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r"),g("mu"),x("invSize")])}{\n\t\t\t    ${R("uv")} = ${U("GetTransmittanceTextureUvFromRMu","v2",[g("r"),g("mu"),x("invSize")])};\n\t\t\t    return ${O("transmittance_texture","uv")}.rgb;\n\t\t\t}\n        `}function tn(n){return`\n            ${F("g_HR")}  = 0.8*pow(10.0,7.0);\n            ${F("g_HM")}  = 0.12*pow(10.0,7.0);\n                \n            ${F("g_EpsilonInScatter")}  = 0.004;\n\n            ${$({uniformName:"miePhaseG",uniformType:"f"})}\n\n            ${$({uniformName:"viewAltitude",uniformType:"f"})}           \n            ${$({uniformName:"sunDirection",uniformType:"v3"})}\n            \n            ${$({uniformName:"nightHazeColor",uniformType:"v3"})}\n            ${$({uniformName:"nightHazeSkyPower",uniformType:"f"})}\n            ${$({uniformName:"nightHazeSkyIntensity",uniformType:"f"})}\n            ${$({uniformName:"nightHazeFogIntensity",uniformType:"f"})}\n\n            ${w("GetScatteringTextureUvwzFromRMuMuSNu","v4",[g("r"),g("mu"),g("mu_s"),g("nu"),d("ray_r_mu_intersects_ground")])}{\n\n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${I("invScatterSize")} = 1.0 / ${c("scatterSize")};\n                ${V("atmBottom2")} = ${c("atmBottom")} * ${c("atmBottom")};\n                ${V("atmTop2")} = ${c("atmTop")} * ${c("atmTop")};\n                ${V("H")} = sqrt(atmTop2 - atmBottom2);\n                // Distance to the horizon.\n                ${V("rho")} = ${U("SafeSqrt","f",[g("r * r - atmBottom2")])};\n                ${V("u_r")}   = ${U("GetTextureCoordFromUnitRange","f",[g("rho / H"),g("invScatterSize.w")])};\n\n                // Discriminant of the quadratic equation for the intersections of the ray\n                // (r,mu) with the ground (see RayIntersectsGround).\n                ${V("r_mu")}  = r * mu;\n                ${V("discriminant")}  = r_mu * r_mu - r * r + atmBottom2;\n                ${V("u_mu")} ;\n                if (ray_r_mu_intersects_ground) {\n                    // Distance to the ground for the ray (r,mu), and its minimum and maximum\n                    // values over all mu - obtained for (r,-1) and (r,mu_horizon).\n                    ${V("d")}  = -r_mu - ${U("SafeSqrt","f",[g("discriminant")])};\n                    ${V("d_min")}  = r - ${c("atmBottom")};\n                    ${V("d_max")}  = rho;\n                    ${V("d_use")} = 0.0;\n                    if (d_max != d_min) {\n                        d_use = (d - d_min) / (d_max - d_min);\n                    }\n                    u_mu = 0.5 - 0.5 * ${U("GetTextureCoordFromUnitRange","f",[g("d_use"),g("2.0 * invScatterSize.z")])};\n                } else {\n                    // Distance to the top atmosphere boundary for the ray (r,mu), and its\n                    // minimum and maximum values over all mu - obtained for (r,1) and\n                    // (r,mu_horizon).\n                    ${V("d")}  = -r_mu + ${U("SafeSqrt","f",[g("discriminant + H * H")])};\n                    ${V("d_min")}  = ${c("atmTop")} - r;\n                    ${V("d_max")}  = rho + H;\n                    u_mu = 0.5 + 0.5 * ${U("GetTextureCoordFromUnitRange","f",[g("(d - d_min) / (d_max - d_min)"),g("2.0* invScatterSize.z")])};\n                }\n                //Weird\n                ${V("d")}  = ${U("DistanceToTopAtmosphereBoundary","f",[g(c("atmBottom")),g("mu_s")])};\n                ${V("d_min")}  = ${c("atmTop")} - ${c("atmBottom")};\n                ${V("d_max")}  = H;\n                ${V("a")}  = (d - d_min) / (d_max - d_min);\n                ${V("mu_s_min")} =-0.207912;\n                ${V("A")}  =-2.0 * mu_s_min * ${c("atmBottom")} / (d_max - d_min);\n                ${V("u_mu_s")}  =  ${U("GetTextureCoordFromUnitRange","f",[g("max(1.0 - a / A, 0.0) / (1.0 + a)"),g("invScatterSize.y")])};\n\n                ${V("u_nu")}  = (nu + 1.0) / 2.0;\n                return ${I()}(u_nu, u_mu_s,1.0- u_mu, u_r);\n\t\t\t}\n\n\t\t\t${w("GetExtrapolatedSingleMieScattering","v3",[D("scattering")])}{\n\t\t\t    return scattering.rgb * scattering.a / max(scattering.r,0.0001) *\n\t\t\t\t\t(${c("rayleighScattering")}.r / ${c("rayleighScattering")});\n\t\t\t}\n\t\t\t\n\t\t\t//VALIDATED\n\t\t\t${w("texture4D","v4",[N("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu")])}{\n\t\t\t\t\n                ${V("atmBottom2")} = ${c("atmBottom")} * ${c("atmBottom")};\n                ${V("atmTop2")} = ${c("atmTop")} * ${c("atmTop")};\n                ${I("invScatterSize")} = 1.0 / ${c("scatterSize")};\n\t\t\t    //NRE CODE //slighly different but overall same\n\t\t\t\t${V("h")}        = sqrt(max(0.0, atmTop2 - atmBottom2));\n\t\t\t\t${V("rho")}      = sqrt(max(0.0, r * r - atmBottom2));\n\t\t\t\t\n\t\t\t\t${V("rmu")}      = r * mu;\n\t\t\t\t${V("delta")}    = rmu * rmu - r * r + atmBottom2;\n                ${I("cst")} = ${I()}(-1.0, h*h, h, 0.5 + 0.5 *invScatterSize.z);\n                if (rmu < 0.0 && delta > 0.0) {\n                    cst =  ${I()}(1.0, 0.0, 0.0, 0.5 - 0.5* invScatterSize.z);\n                }\n\t\t\t\t${V("uR")}       = 0.5 *invScatterSize.w + rho / h * (1.0 - invScatterSize.w);\n\t\t\t\t${V("uMu")}      = cst.w + (rmu * cst.x + sqrt(max(0.0, delta + cst.y)) ) / (rho + cst.z) * (0.5 - invScatterSize.z);\n\t\t\t\t${V("uMuS")}     = 0.5 *invScatterSize.y + (atan(max(mu_s, -0.1975) * 5.34962349919) / 1.1 + 0.74) * 0.5 * (1.0 - invScatterSize.y);\n\t\t\t\t${V("uNu")}      = 0.5 * (nu + 1.0);\n\t\t\t  \n                ${I("uvwz")}  = ${I()}(uNu,uMuS,1.0-uMu,uR);\n                \n                ${V("tex_coord_x")}  = uvwz.x * (${c("scatterSize")}.x-1.0);\n                ${V("tex_x")}  = floor(tex_coord_x);\n                ${V("lerpx")}  = tex_coord_x - tex_x;\n                ${V("tex_coord_y")}  = uvwz.w * (${c("scatterSize")}.w-1.0);\n                ${V("tex_y")}  = floor(tex_coord_y);\n                ${V("lerpy")}  = tex_coord_y - tex_y;\n                ${R("uv0")}  = ${R()}((tex_x + uvwz.z) *invScatterSize.x,((tex_y + uvwz.y) *invScatterSize.w));\n                ${R("uv1")}  = ${R()}((tex_x + 1.0 + uvwz.z) *invScatterSize.x,((tex_y + uvwz.y) *invScatterSize.w));\n                ${R("uv2")}  = ${R()}((tex_x + uvwz.z) *invScatterSize.x,((tex_y +1.0 + uvwz.y) *invScatterSize.w));\n                ${R("uv3")}  = ${R()}((tex_x + 1.0 + uvwz.z) *invScatterSize.x,((tex_y +1.0+ uvwz.y) *invScatterSize.w));\n                ${I("combined_scattering")}  = (\n                            ${O("scattering_texture","uv0")} * (1.0 - lerpx) + \n                            ${O("scattering_texture","uv1")} * lerpx\n                        )*(1.0 -lerpy)\n                        +\n                        (\n                            ${O("scattering_texture","uv2")} * (1.0 - lerpx) + \n                            ${O("scattering_texture","uv3")} * lerpx\n                        )*(lerpy);\n                                                \n\t\t\t\treturn combined_scattering;\n\t\t\t}\n\t\t\t\n            ${w("GetCombinedScattering","v4",[N("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),_("ioNightHaze")])}{\n\t\t\t\t\n\t\t\t\t${V("muHorizon")}  = -sqrt(max(0.0, 1.0 - (${c("atmBottom")} / r) * (${c("atmBottom")} /r)));\n\t\t\t\t\n\t\t\t\t// Night haze\n\t\t\t\t${A("surfacePos")}  = ${A()}(0.0,0.0,${c("atmBottom")});\n\t\t\t\t${A("nightHaze")} = ${A()}(1.0-abs(mu - muHorizon));\n\t\t\t\tnightHaze = ${c("nightHazeColor")}*pow(abs(nightHaze), vec3(${c("nightHazeSkyPower")})) * ${c("nightHazeSkyIntensity")};\n\t\t\t\tnightHaze *= smoothstep(${c("atmTop")}-${c("atmBottom")}, 0.0, ${c("viewAltitude")});\n\t\t\t\tnightHaze = clamp(nightHaze,0.0,1.0);\n                ${m()}ioNightHaze = nightHaze;\n\t\t\t\t\n\t\t\t\treturn ${U("texture4D","v4",[N("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu")])};\n\t\t\t}\n\t\t\t\n            ${w("RayleighPhaseFunction","f",[g("nu")])} {\n                ${V("k")}  = 3.0 / (16.0 * PI);\n                return k * (1.0 + nu * nu);\n\t\t\t}\n\t\t\t\n            ${w("MiePhaseFunction","f",[g("g"),g("nu")])} {\n                ${V("k")} = 3.0 / (8.0 * PI);\n                ${V("a")}  = (1.0 - g * g);\n                ${V("b")}  = (2.0 + g * g);\n                ${V("c")}  = 1.0 + g * g;\n                ${V("d")}  = 2.0 * g * nu;\n                ${V("e")}  = (1.0 + nu * nu);\n                return k * e * a * pow(abs(c - d), -1.5) / b;\n\t\t\t}\n\t\t\t\n            ${w("OpticalDepth","f",[g("iH"),g("iR"),g("iMu"),g("iD")])} {\n\t\t\t\t${V("a")}      = sqrt(max(0.0, (0.5/iH)*iR));\n\t\t\t\t${R("a01")}     = a*${R()}(iMu, iMu+iD/iR);\n\t\t\t\t${R("a01s")}    = sign(a01);\n\t\t\t\t${R("a01sq")}   = a01*a01;\n\t\t\t\t${V("x")}      = a01s.y > a01s.x ? exp(a01sq.x) : 0.0; \n\t\t\t\t${R("y")}       = a01s / (2.3193*abs(a01) + sqrt(max(${R()}(0.0), 1.52*a01sq + 4.0))) * ${R()}(1.0, exp(-iD/iH*(iD/(2.0*iR)+iMu)));\n\n\t\t\t\treturn sqrt(max(0.0, (6.2831*iH)*iR)) * exp((${c("atmBottom")}-iR)/iH) * (x + dot(y, ${R()}(1.0, -1.0)));\n\t\t\t}\n\t\t\t\n            ${w("AnalyticTransmittance","v3",[g("iR"),g("iMu"),g("iD")])} {\n                ${V("opticalRayleigh")} = ${U("OpticalDepth","f",[g("g_HR"),g("iR"),g("iMu"),g("iD")])};\n                ${V("opticalMie")} = ${U("OpticalDepth","f",[g("g_HM"),g("iR"),g("iMu"),g("iD")])};\n\t\t\t\treturn exp(-${c("rayleighScattering")} * opticalRayleigh - ${c("mieScattering")} * opticalMie);\n\t\t\t}\n\t\t\t\n            ${w("IntersectAtmosphere","b",[y("pos"),y("dir"),v("distToAtmosphere"),v("distInAtmosphere")])} {\n\t\t\t\t${A("l")} = -pos;\n\t\t\t\t${V("l2")}  = dot(l,l);\n\t\t\t\t${V("s")}  = dot(l,dir);\n\t\t\t\t${V("r2")}  = ${c("atmTop")}*${c("atmTop")};\n\t\t\t\t\n\t\t\t\tif (l2<=r2){\n\t\t\t\t\t${V("m2")}  = l2 - (s * s);\n\t\t\t\t\t${V("q")}   = sqrt(max(0.0, r2 - m2));\n\t\t\t\t\t${m()}distInAtmosphere = s + q;\n\t\t\t\t\t${m()}distToAtmosphere = 0.0;\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(s>=0.0){\n\t\t\t\t\t${V("m2")}  = l2 - (s * s);\n\t\t\t\t\tif(m2 <= r2){\n\t\t\t\t\t\t${V("q")}  = sqrt(max(0.0, r2 - m2));\n\t\t\t\t\t\t${m()}distToAtmosphere = s - q;\n\t\t\t\t\t\t${m()}distInAtmosphere = (s + q) - ${m()}distToAtmosphere;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n            ${w("getScatteringFromWorldParams","v4",[N("scattering_texture"),y("point"),y("view_ray"),y("sun_direction"),g("distance"),_("transmittance"),_("nightHaze")])} {\n\t\t\t\t// Compute the r, mu, mu_s and nu parameters needed for the texture lookups.\n\t\t\t\t${V("r")}  = length(point);\n\t\t\t\t${V("rmu")}  = dot(point, view_ray);\n\t\t\t\t${V("mu")}  = rmu / r;\n\t\t\t\t${V("mu_s")}  = dot(point, sun_direction) / r;\n\t\t\t\t${V("nu")}  = dot(view_ray, sun_direction);\n\t\t\t\t${m()}transmittance = ${U("AnalyticTransmittance","v3",[g("r"),g("mu"),g("distance")])};\n\t\t\t\t  \n\t\t\t\treturn ${U("GetCombinedScattering","v4",[N("scattering_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),_("nightHaze")])};\n\t\t\t}\n\t\t\t\n            ${w("ApplyMieRayleigh","v3",[C("scattering"),g("mu_s"),g("nu")])}{\n\t\t\t\t//NRE COPIED PARAMS\n                ${V("SunSize")}      = 10000.0;\n                ${V("sunFactor")}    = 0.001*SunSize;\n                //1.0 for hdr gen\n                ${V("g_MieBoost")}   = 0.0;\n                ${V("lerpFactor")}   = (max((1.0-sunFactor), nu)-(1.0-sunFactor))*(1.0/sunFactor);\n                ${V("theta")}        = smoothstep(0.0, 2.0, pow(lerpFactor, 8.0));\n                ${V("sunBoost")}     = 2.0+g_MieBoost*theta;\n                ${V("sunScatteringIntensity")}  = 60.0;\n                \n                ${m()}scattering.w *= smoothstep(0.0,0.02,mu_s);\n                ${A("single_mie_scattering")}  = ${U("GetExtrapolatedSingleMieScattering","v3",[y(`${m()}scattering`)])};\n                \n                ${A("InScattering")} = max((${m()}scattering.xyz * ${U("RayleighPhaseFunction","f",[g("nu")])} + single_mie_scattering * ${U("MiePhaseFunction","f",[g("miePhaseG"),g("nu")])} * sunBoost),0.0);\n                InScattering *= sunScatteringIntensity;\n                //NRE impl \n                return InScattering*0.6;\n\t\t\t}\n\t\t\t\n            ${w("GetSkyScattering","v3",[N("transmittance_texture"),N("scattering_texture"),_("cameraPos"),y("view_ray"),y("sun_direction"),_("nightHaze")])} {\n\t\t\t  \n                ${V("distance_to_atmosphere")}  = 0.0;\n                ${V("distance_in_atmosphere")}  = 0.0;\n                \n                ${z("goThroughAtmosphere")}  = ${U("IntersectAtmosphere","b",[y("cameraPos"),y("view_ray"),S("distance_to_atmosphere"),S("distance_in_atmosphere")])};\n                \n                if(!goThroughAtmosphere){\n                    // If the view ray does not intersect the atmosphere, simply return 0.\n                    return ${A()}(0.0);\n                }\n                \n                cameraPos = cameraPos + view_ray * distance_to_atmosphere;\n                \n                ${A("transmittance")} ;\n                \n                ${I("scattering")}  = ${U("getScatteringFromWorldParams","v4",[N("scattering_texture"),y("cameraPos"),y("view_ray"),y("sun_direction"),g("distance_in_atmosphere"),T("transmittance"),_("nightHaze")])};\n                \n                ${V("nu")}  = dot(view_ray, sun_direction);\n                ${V("mu_s")}  = dot(cameraPos, sun_direction) / length(cameraPos);\n                \n                return ${U("ApplyMieRayleigh","v3",[P("scattering"),g("mu_s"),g("nu")])};\n\t\t\t}\n\t\t\t\n            ${w("GetSkyScatteringWithDepth","v3",[N("scattering_texture"),_("cameraPos"),y("view_ray"),y("sun_direction"),y("pointPos"),_("attenuation")])}{\n\t\t\t\t${V("distance_to_atmosphere")}  = 0.0;\n\t\t\t\t${V("distance_in_atmosphere")}  = 0.0;\n\t\t\t\t  \n\t\t\t\tbool goThroughAtmosphere =  ${U("IntersectAtmosphere","b",[y("cameraPos"),y("view_ray"),S("distance_to_atmosphere"),S("distance_in_atmosphere")])};\n\t\t\t\t  \n\t\t\t\t${V("distanceToObject")}  = distance(cameraPos, pointPos);\n\t\t\t\t  \n\t\t\t\tif(!goThroughAtmosphere || distanceToObject<distance_to_atmosphere){\n\t\t\t\t    // If no atmosphere in front of object\n\t\t\t    \treturn ${A()}(0.0);\n\t\t\t\t}\n\t\t\t\t  \n\t\t\t\t${m()}cameraPos = ${m()}cameraPos + view_ray * distance_to_atmosphere;\n\t\t\t\tdistanceToObject -= distance_to_atmosphere;\n\t\t\t\t  \n\t\t\t\t${A("nightHaze")};//useless\n\t\t\t\t  \n\t\t\t\t${I("scattering")}  =  ${U("getScatteringFromWorldParams","v4",[N("scattering_texture"),y(`${m()}cameraPos`),y("view_ray"),y("sun_direction"),g("distance_in_atmosphere"),_("attenuation"),T("nightHaze")])};\n\t\t\t\t  \n\t\t\t\t${V("mu_s")}  = dot(${m()}cameraPos, sun_direction) / length(${m()}cameraPos);\n\t\t\t\t${V("nu")}  = dot(view_ray, sun_direction);\n\t\t\t\t  \n\t\t\t\tif(distanceToObject < distance_in_atmosphere){\n\t\t\t\t\t${V("heightEndPos")}  = length(pointPos);\n\t\t\t\t\t${V("musEndPos")}     = dot(pointPos, sun_direction) / heightEndPos;\t\n\t\t\t\t\t${V("muEndPos")}  = dot(pointPos, view_ray) / heightEndPos;\n\t\t\t\t\t${I("scatteringPoint")}  = ${U("getScatteringFromWorldParams","v4",[N("scattering_texture"),y("pointPos"),y("view_ray"),y("sun_direction"),g("distanceToObject"),_("attenuation"),T("nightHaze")])};\n\t\t\t\t\tscattering = max(scattering - attenuation.rgbr * scatteringPoint,0.0);\n\t\t\t\t}\n\t\t\t\t  \n\t\t\t\treturn ${U("ApplyMieRayleigh","v3",[P("scattering"),g("mu_s"),g("nu")])};\n\t\t\t}\n\n            ${w("GetHDREncoded","v4",[y("color")])} {\n                ${V("value")} = max(color.r, max(color.g, color.b));\n                if (value < 1e-6) return ${I()}(0.0, 0.0, 0.0, 1.0);\n                // in [-128..127]\n                ${V("exponent")}  = clamp(ceil(log2(value)), -128.0, 127.0);\n\n                return ${I()}(color * pow(2.0, -exponent), (exponent + 128.0) / 255.0);\n            }\n\t\t\t\n            ${w("Irradiance","v3",[N("tIrr"),g("iAlt"),g("iCosSunZenithAngle")])}{\n\t\t\t    ${V("uR")}     = (iAlt - ${c("atmBottom")}) / (${c("atmTop")} - ${c("atmBottom")});\n\t\t\t\t${V("uMuS")}   = (iCosSunZenithAngle + 0.2) / (1.0 + 0.2);\n                ${R("uv")} = ${R()}(uMuS, 1.0-uR);\n\t\t\t\treturn ${O("tIrr","uv")}.rgb;\n\t\t\t}\n\n\t\t\t// transmittance(=transparency) of atmosphere for infinite ray (alt,cosRayZenithAngle)\n\t\t\t// (cosRayZenithAngle=cos(view zenith angle)), intersections with ground ignored\n            ${w("Transmittance","v3",[N("tTrans"),g("iAlt"),g("iCosRayZenithAngle")])}{\n\t\t\t\t${V("uR")} = sqrt(max(0.0, (iAlt - ${c("atmBottom")}) / (${c("atmTop")} - ${c("atmBottom")})));\n                ${V("uMu")} = atan((iCosRayZenithAngle + 0.15) / (1.0 + 0.15) * tan(1.5)) / 1.5;\n                ${R("uv")} = ${R()}(uMu, 1.0-uR);\n\t\t\t\treturn ${O("tTrans","uv")}.rgb;\n\t\t\t}\n\t\t\t\n\t\t\t\n            ${w("GetReflectedLight","v3",[N("tIrradiance"),N("tTransmittance"),y("iSurfaceColor"),y("iSurfacePos"),y("iCameraPos"),y("sunDirection"),y("iAttenuation")])}{\n\t\t\t\t\n\t\t\t\t// irradiance at surface position due to sky light\n\t\t\t\t${V("surfacePosHeight")} \t= length(iSurfacePos);\t\t\n\t\t\t\t${V("dotSunSphere")}       = dot(iSurfacePos, sunDirection) / surfacePosHeight;\n                // CK added saturate\t\n\t\t\t\t${V("musSurfacePos")}      = clamp(dotSunSphere,0.0,1.0);\n\n\t\t\t\t${A("irradianceSurface")}   =  ${U("Irradiance","v3",[N("tIrradiance"),g("surfacePosHeight"),g("musSurfacePos")])};\n\t\t\t\t \n\t\t\t\t// attenuate direct sun light on its path from top of atmosphere to surface position\n\t\t\t\t${A("attenuationSunLight")}  = ${U("Transmittance","v3",[N("tTransmittance"),g("surfacePosHeight"),g("musSurfacePos")])};\n\t\t\t\t\n\t\t\t\t${V("sunScatteringIntensity")}  = 60.0;\n\t\t\t\t${A("reflectedLight")}  = iSurfaceColor * (attenuationSunLight + irradianceSurface) * sunScatteringIntensity * (0.1 / PI);\n\t\t\t  \n\t\t\t\t// factor to avoid discontinuities on the atmosphere boundary (and black materials above atmosphere)\n\t\t\t\t${V("inSpaceFactor")}  = smoothstep(${c("atmBottom")}+(${c("atmTop")}-${c("atmBottom")})*0.2, ${c("atmTop")}, surfacePosHeight);\n\t\t\t\treflectedLight = mix(reflectedLight, iSurfaceColor, inSpaceFactor);\n\n\t\t\t    ${V("cameraAlt")}                = length(iCameraPos) - ${c("atmBottom")};\n\t\t\t\t${V("planetSunlightFactor")}     = smoothstep(-0.05,  0.05, dotSunSphere);\n                // to avoid too much yellow in space (on shadow boundaries)\n\t\t\t\t${V("planetSunlightFactorBis")}  = smoothstep(-0.05,  0.2,  dotSunSphere); \n\t\t\t\t${V("bisFactor")}                = smoothstep(300.0, 1000.0, cameraAlt);\n\t\t\t\tplanetSunlightFactor = (1.0-bisFactor)*planetSunlightFactor + planetSunlightFactorBis*bisFactor;\n\t\t\t\n\t\t\t\t// Fog applied at night \n\t\t\t\t${A("fogColor")}      = ${c("nightHazeColor")} * ${c("nightHazeFogIntensity")};\n\t\t\t\t${V("fogDensity")}   = 0.009;\n\t\t\t\t${V("fogFactor")}    = 1.0 - 1.0 / pow(exp(length(iSurfacePos-iCameraPos) * fogDensity), 2.0);\n\t\t\t\tfogFactor *= smoothstep(100.0, 0.0, cameraAlt);\n\n\t\t\t\t${A("surfaceColor")} = (1.0-fogFactor) * iSurfaceColor + fogFactor * fogColor;\n\t\t\t\n\t\t\t\treturn planetSunlightFactor * reflectedLight + (1.0-planetSunlightFactor) * surfaceColor;\n\t\t\t}\n        `}function rn(n){return`\n            ${s.createStructure({structName:"densityProfileLayer",attributes:[{type:"f",name:"width"},{type:"f",name:"exp_term"},{type:"f",name:"exp_scale"},{type:"f",name:"linear_term"},{type:"f",name:"constant_term"}]})}\n            ${s.createStructure({structName:"densityProfile",attributes:[{type:"densityProfileLayer",name:"layer0",custom:!0},{type:"densityProfileLayer",name:"layer1",custom:!0}]})}\n        \n            ${s.declareStructure({name:"rayleighDensity",structName:"densityProfile",addressSpace:"private"})};\n            ${s.declareStructure({name:"mieDensity",structName:"densityProfile",addressSpace:"private"})};\n            \n            ${s.declareStructure({name:"flR",structName:"densityProfileLayer",addressSpace:"private"})};\n            ${s.declareStructure({name:"slR",structName:"densityProfileLayer",addressSpace:"private"})};\n            \n            ${s.declareStructure({name:"flM",structName:"densityProfileLayer",addressSpace:"private"})};\n            ${s.declareStructure({name:"slM",structName:"densityProfileLayer",addressSpace:"private"})};\n        `}function an(e){return`           \n            ${L({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${k("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}class on extends nn{constructor(){super(),this.mieExtinction=G,this.absorptionExtinction=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.mieExtinction,this.mieExtinction),t.uniform1f(r.absorptionExtinction,this.absorptionExtinction)}clone(){return new on}}class sn extends nn{constructor(){super(),this.solarIrradiance=J,this.angularRadius=Z}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.angularRadius,this.angularRadius),t.uniform3f(r.solarIrradiance,this.solarIrradiance.x,this.solarIrradiance.y,this.solarIrradiance.z)}clone(){return new sn}}class ln extends nn{constructor(){super(),this.sunDirection=new n.Vector3(-1,-1,1),this.viewAltitude=1,this.miePhaseG=q,this.nightHazeColor=new n.Vector3(.25,.34,.49),this.nightHazeSkyPower=.6,this.nightHazeSkyIntensity=.15,this.nightHazeFogIntensity=.15}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.viewAltitude,this.viewAltitude),t.uniform1f(r.miePhaseG,this.miePhaseG),t.uniform1f(r.nightHazeSkyPower,this.nightHazeSkyPower),t.uniform1f(r.nightHazeSkyIntensity,this.nightHazeSkyIntensity),t.uniform1f(r.nightHazeFogIntensity,this.nightHazeFogIntensity),t.uniform3f(r.sunDirection,this.sunDirection.x,this.sunDirection.y,this.sunDirection.z),t.uniform3f(r.nightHazeColor,this.nightHazeColor.x,this.nightHazeColor.y,this.nightHazeColor.z)}clone(){return new ln}}class un extends ln{constructor(){super(),this.texturesLoaded=0,this.near=0,this.far=0,this.screenToView=new n.Vector4,this.invView=new n.Matrix4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.texturesLoaded,this.texturesLoaded),t.uniform1f(r.near,this.near),t.uniform1f(r.far,this.far),t.uniform4f(r.screenToView,this.screenToView.x,this.screenToView.y,this.screenToView.z,this.screenToView.w),t.uniformMatrix4fv(r.invView,!1,e.float32Matrix4x4Temp.setDoubles(this.invView.elements))}clone(){return new un}}return{ComputeTransmittance:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${L({varyingName:"vUv",varyingType:"v2"})}\n            ${$({uniformName:"mieExtinction",uniformType:"f"})}\n            ${$({uniformName:"absorptionExtinction",uniformType:"f"})}\n\n            ${rn()}\n            ${en()}\n\n            \n\t\t\t${w("ComputeOpticalLengthToTopAtmosphereBoundary","f",[b("profile"),g("r"),g("mu")])}{\n                // Number of intervals for the numerical integration.\n                ${F("SAMPLE_COUNT")}  = 500.0;\n                // The integration step, i.e. the length of each integration interval.\n                ${V("dx")} = ${U("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])} / SAMPLE_COUNT;\n                // Integration loop.\n                ${V("result")}  = 0.0;\n                for (${V("i")}  = 0.0; i <= SAMPLE_COUNT; ++i) {\n                    ${V("d_i")}  = i * dx;\n                    // Distance between the current sample point and the planet center.\n                    ${V("r_i")}  = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n                    // Number density at the current sample point (divided by the number density\n                    // at the bottom of the atmosphere, yielding a dimensionless number).\n                    ${V("alt")} = r_i - ${c("atmBottom")};\n                    ${V("y_i")}  = ${U("GetProfileDensity","f",[b("profile"),g("alt")])};\n                    // Sample weight (from the trapezoidal rule).\n                    ${V("weight_i")}  = 1.0;\n                    if (i == 0.0 || i == SAMPLE_COUNT) {\n                        weight_i = 0.5;\n                    }\n                    result += y_i * weight_i * dx;\n                }\n                return result;\n\t\t\t}\n\t\t\t\n            ${w("ComputeTransmittanceToTopAtmosphereBoundary","v3",[g("r"),g("mu")])} {\n                ${A("rayleigh")} = ${c("rayleighScattering")} * ${U("ComputeOpticalLengthToTopAtmosphereBoundary","f",[b("rayleighDensity"),g("r"),g("mu")])};\n                ${A("mie")} = ${A()}(${c("mieScattering")}) * ${U("ComputeOpticalLengthToTopAtmosphereBoundary","f",[b("mieDensity"),g("r"),g("mu")])};\n\t\t\t\t//a decommenter si ozone prise en compte\n                // ${A("absorption")} = absorptionExtinction * ComputeOpticalLengthToTopAtmosphereBoundary(atmosphere.absorption_density, r, mu);\n\t\t\t    return exp(-(rayleigh+mie));\n\t\t\t}\t\t\n\t\t\t\n            ${w("GetRMuFromTransmittanceTextureUv","v2",[x("uv")])}{\n                ${R("invSize")} = ${c("transInvSize")};\n                ${V("x_mu")}  = ${U("GetUnitRangeFromTextureCoord","f",[g("uv.x"),g("invSize.x")])};\n                ${V("x_r")}  = ${U("GetUnitRangeFromTextureCoord","f",[g("uv.y"),g("invSize.y")])};\n                \n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${V("H")}  = sqrt(${c("atmTop")} * ${c("atmTop")} - ${c("atmBottom")} * ${c("atmBottom")});\n                // Distance to the horizon, from which we can compute r:\n                ${V("rho")}  = H * x_r;\n                ${V("r")} = sqrt(rho * rho + ${c("atmBottom")} * ${c("atmBottom")});\n                // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum\n                // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon) -\n                // from which we can recover mu:\n                ${V("d_min")}  = ${c("atmTop")} - r;\n                ${V("d_max")}  = rho + H;\n                ${V("d")}  = d_min + x_mu * (d_max - d_min);\n                ${V("mu")} = 1.0;\n                if (d != 0.0) {\n                    mu = (H * H - rho * rho - d * d) / (2.0 * r * d);\n                }\n                mu = ${U("ClampCosine","f",[g("mu")])};\n                return ${R()}(r, mu);\n\t\t\t}\n\t\t\t\n            ${w("ComputeTransmittanceToTopAtmosphereBoundaryTexture","v3",[x("frag_coord")])}{\n                ${R("r_mu")} = ${U("GetRMuFromTransmittanceTextureUv","v2",[x("frag_coord")])};\n                return ${U("ComputeTransmittanceToTopAtmosphereBoundary","v3",[g("r_mu.x"),g("r_mu.y")])};\n\t\t\t}\n      \n            ${u.getMainFragmentStart()}\n                ${R("screenUV")} = ${B("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                ${A("res")} = ${U("ComputeTransmittanceToTopAtmosphereBoundaryTexture","v3",[x("screenUV")])};\n\n                ${t} = ${I()}(res, 1.0);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:an(e),fragmentShader:r}},"SkyComputeTransmittance"),on,{}),ComputeScattering:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${L({varyingName:"vUv",varyingType:"v2"})}\n            ${$({uniformName:"angularRadius",uniformType:"f"})}\n            ${$({uniformName:"solarIrradiance",uniformType:"v3"})}\n\n            ${rn()}\n            ${en()}\n\n            ${w("GetRMuMuSNuFromScatteringTextureUvwz","v4",[D("uvwz"),f("ray_r_mu_intersects_ground")])} {\n\n                ${V("r")};\n                ${V("mu")};\n                ${V("mu_s")};\n                ${V("nu")};\n                ${I("invSize")} = ${c("scatterInvSize")};\n                ${V("aTop")} = ${c("atmTop")};\n                ${V("aBottom")} = ${c("atmBottom")};\n                // Distance to top atmosphere boundary for a horizontal ray at ground level.\n                ${V("H")} = sqrt(aTop * aTop - aBottom * aBottom);\n                // Distance to the horizon.\n                ${V("rho")}  = H * ${U("GetUnitRangeFromTextureCoord","f",[g("uvwz.w"),g("invSize.w")])};\n                r = sqrt(rho * rho + aBottom * aBottom);\n\n                if (uvwz.z < 0.5) {\n                    // Distance to the ground for the ray (r,mu), and its minimum and maximum\n                    // values over all mu - obtained for (r,-1) and (r,mu_horizon) - from which\n                    // we can recover mu:\n                    ${V("d_min")}  = r - aBottom;\n                    ${V("d_max")}  = rho;\n                    ${V("d")}  = d_min + (d_max - d_min) * ${U("GetUnitRangeFromTextureCoord","f",[g("1.0 - 2.0 * uvwz.z"),g("invSize.z * 2.0")])};\n                    if ( d == 0.0) {\n                        mu = -1.0;\n                    } else {\n                        mu = ${U("ClampCosine","f",[g("-(rho * rho + d * d) / (2.0 * r * d)")])};\n                    }\n                    ${m()}ray_r_mu_intersects_ground = true;\n                } else {\n                    // Distance to the top atmosphere boundary for the ray (r,mu), and its\n                    // minimum and maximum values over all mu - obtained for (r,1) and\n                    // (r,mu_horizon) - from which we can recover mu:\n                    ${V("d_min")}  = aTop - r;\n                    ${V("d_max")}  = rho + H;\n                    ${V("d")}  = d_min + (d_max - d_min) * ${U("GetUnitRangeFromTextureCoord","f",[g("2.0 * uvwz.z - 1.0"),g("invSize.z * 2.0")])};\n                    if ( d == 0.0) {\n                        mu = 1.0;\n                    } else {\n                        mu = ${U("ClampCosine","f",[g("(H * H - rho * rho - d * d) / (2.0 * r * d)")])};\n                    }\n                    ${m()}ray_r_mu_intersects_ground = false;\n                }\n\n                ${V("x_mu_s")} = ${U("GetUnitRangeFromTextureCoord","f",[g("uvwz.y"),g("invSize.y")])};\n                ${V("d_min")}  = aTop - aBottom;\n                ${V("d_max")}  = H;\n                ${V("mu_s_min")} =-0.207912;\n                ${V("A")}  =-2.0 * mu_s_min * aBottom / (d_max - d_min);\n                ${V("a")}  = (A - x_mu_s * A) / (1.0 + x_mu_s * A);\n                ${V("d")}  = d_min + min(a, A) * (d_max - d_min);          \n                if ( d == 0.0) {\n                    mu_s = 1.0;\n                } else {\n                    mu_s = ${U("ClampCosine","f",[g("(H * H - d * d) / (2.0 * aBottom * d)")])};\n                }\n\n                nu = ${U("ClampCosine","f",[g("uvwz.x * 2.0 - 1.0")])};\n                return ${I()}(r, mu, mu_s, nu);\n\t\t\t}\n\n\t\t\t${w("GetRMuMuSNuFromScatteringTextureFragCoord","v4",[x("frag_coord"),f("ray_r_mu_intersects_ground")])} {\n                // const vec4 SCATTERING_TEXTURE_SIZE = vec4(\n                    // SCATTERING_TEXTURE_NU_SIZE - 1,\n                    // SCATTERING_TEXTURE_MU_S_SIZE,\n                    // SCATTERING_TEXTURE_MU_SIZE,\n                    // SCATTERING_TEXTURE_R_SIZE);\n                ${R("coord")} = frag_coord;\n                ${I("invSize")} = ${c("scatterInvSize")};\n                //nu & mu on same coord\n                coord.x /=(invSize.x*invSize.z);\n                // mu_s & r on same coord\n                coord.y /=(invSize.y*invSize.w);\n                //mu size\n                ${V("frag_coord_nu")} = floor(coord.x *invSize.z);\n                //mu size\n                ${V("frag_coord_mu")} = mod(coord.x, 1.0/invSize.z);\n                //mu_s size\n                ${V("frag_coord_r")} = floor(coord.y *invSize.y);\n                //mu_s size\n                ${V("frag_coord_mu_s")} = mod(coord.y, 1.0/invSize.y);\n                ${I("uvwz")}  = ${I()}(frag_coord_nu, frag_coord_mu_s, frag_coord_mu, frag_coord_r)*invSize; \n\n                ${I("res")} = ${U("GetRMuMuSNuFromScatteringTextureUvwz","v4",[D("uvwz"),f("ray_r_mu_intersects_ground")])};\n                ${V("r")} = res.x;\n                ${V("mu")} = res.y;\n                ${V("mu_s")} = res.z;\n                ${V("nu")} = res.w;\n                // Clamp nu to its valid range of values, given mu and mu_s.\n                nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)),\n                     mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));\n                return ${I()}(r, mu, mu_s, nu);\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittance","v3",[N("transmittance_texture"),g("r"),g("mu"),g("d"),d("ray_r_mu_intersects_ground")])} {\n                ${R("invSize")} = ${c("transInvSize")};\n                ${V("r_d")} = ${U("ClampRadius","f",[g("sqrt(d * d + 2.0 * r * mu * d + r * r)")])};\n                ${V("mu_d")}  = ${U("ClampCosine","f",[g("(r * mu + d) / r_d")])};\n\n                if (ray_r_mu_intersects_ground) {\n                    return min(\n                        ${U("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r_d"),g("-mu_d"),x("invSize")])}\n                        /\n                        ${U("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r"),g("-mu"),x("invSize")])},\n                        ${A()}(1.0));\n                } else {\n                    return min(\n                        ${U("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r"),g("mu"),x("invSize")])} \n                        /\n                        ${U("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r_d"),g("mu_d"),x("invSize")])},\n                        ${A()}(1.0));\n                }\n\t\t\t}\n\t\t\t\n            ${w("GetTransmittanceToSun","v3",[N("transmittance_texture"),g("r"),g("mu_s")])}{\n                ${R("invSize")} = ${c("transInvSize")};\n                ${V("sin_theta_h")}  = ${c("atmBottom")} / r;\n                ${V("cos_theta_h")}  = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\n                ${V("smooth")} = smoothstep(-sin_theta_h * ${c("angularRadius")}, sin_theta_h * ${c("angularRadius")}, mu_s - cos_theta_h);\n                return ${U("GetTransmittanceToTopAtmosphereBoundary","v3",[N("transmittance_texture"),g("r"),g("mu_s"),x("invSize")])} * smooth;\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScatteringIntegrand","v4",[N("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),g("d"),d("ray_r_mu_intersects_ground")])} {\n                ${V("r_d")} = ${U("ClampRadius","f",[g("sqrt(d * d + 2.0 * r * mu * d + r * r)")])};\n                ${V("mu_s_d")}  = ${U("ClampCosine","f",[g("(r * mu_s + d * nu) / r_d")])};\n                ${V("alt")} = r_d - ${c("atmBottom")};\n                ${A("transmittance")}  =  \n                            ${U("GetTransmittance","v3",[N("transmittance_texture"),g("r"),g("mu"),g("d"),d("ray_r_mu_intersects_ground")])} \n                            * \n                            ${U("GetTransmittanceToSun","v3",[N("transmittance_texture"),g("r_d"),g("mu_s_d")])};\n                ${A("rayleigh")} = transmittance * GetProfileDensity(rayleighDensity, alt);\n                ${V("mie")} = (transmittance * GetProfileDensity(mieDensity, alt)).x;\n                return ${I()}(rayleigh, mie);\n\t\t\t}\n\t\t\t\n            ${w("DistanceToNearestAtmosphereBoundary","f",[g("r"),g("mu"),d("ray_r_mu_intersects_ground")])}{\n                if (ray_r_mu_intersects_ground) {\n                    return ${U("DistanceToBottomAtmosphereBoundary","f",[g("r"),g("mu")])};\n                } else {\n                    return ${U("DistanceToTopAtmosphereBoundary","f",[g("r"),g("mu")])};\n                }\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScattering","v4",[N("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),d("ray_r_mu_intersects_ground")])}{\n                // Number of intervals for the numerical integration.\n                ${F("SAMPLE_COUNT")}  = 50.0;\n                // The integration step, i.e. the length of each integration interval.\n                float dx = ${U("DistanceToNearestAtmosphereBoundary","f",[g("r"),g("mu"),d("ray_r_mu_intersects_ground")])} / SAMPLE_COUNT;\n                // Integration loop.\n                ${A("rayleigh_sum")}  = ${A()}(0.0);\n                ${V("mie_sum")}  = 0.0;\n                for (${V("i")} = 0.0; i <= SAMPLE_COUNT; ++i) {\n                    ${V("d_i")}  = i * dx;\n                    // The Rayleigh and Mie single scattering at the current sample point.\n                    ${I("computed")} =  ${U("ComputeSingleScatteringIntegrand","v4",[N("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),g("d_i"),d("ray_r_mu_intersects_ground")])};\n                    ${A("rayleigh_i")} = computed.xyz;\n                    ${V("mie_i")} = computed.w;\n                    // Sample weight (from the trapezoidal rule).\n                    ${V("weight_i")} = 1.0;\n                    if (i == 0.0 || i == SAMPLE_COUNT) {\n                        weight_i = 0.5;\n                    }\n                    rayleigh_sum += rayleigh_i * weight_i;\n                    mie_sum += mie_i * weight_i;\n                }\n                ${A("rayleigh")} = rayleigh_sum * dx * ${c("solarIrradiance")} * ${c("rayleighScattering")};\n                ${V("mie")} = (mie_sum * dx *  ${c("solarIrradiance")} *  ${c("mieScattering")}).x;\n                return ${I()}(rayleigh, mie);\n\t\t\t}\n\t\t\t\n            ${w("ComputeSingleScatteringTexture","v4",[N("transmittance_texture"),x("frag_coord")])}{\n                ${z("ray_r_mu_intersects_ground")} ;\n                ${I("coeffs")} = ${U("GetRMuMuSNuFromScatteringTextureFragCoord","v4",[x("frag_coord"),h("ray_r_mu_intersects_ground")])};\n                ${V("r")} = coeffs.x;\n                ${V("mu")} = coeffs.y;\n                ${V("mu_s")} = coeffs.z;\n                ${V("nu")} = coeffs.w;\n                \n                return ${U("ComputeSingleScattering","v4",[N("transmittance_texture"),g("r"),g("mu"),g("mu_s"),g("nu"),d("ray_r_mu_intersects_ground")])};\n\t\t\t}\n      \n            ${u.getMainFragmentStart()}\n                ${R("screenUV")} = ${B("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                ${I("res")} = ${U("ComputeSingleScatteringTexture","v4",[N("tTrans"),x("screenUV")])};\n\n                ${t} = res;           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:an(e),fragmentShader:r}},"SkyComputeScattering"),sn,{}),RenderSky:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${L({varyingName:"vUv",varyingType:"v2"})}\n\n            ${rn()}\n            ${en()}\n            ${tn()}\n      \n            ${u.getMainFragmentStart()}\n                ${R("screenUV")} = ${B("vUv")};\n                \n        \n            flR.width=0.0;\n            flR.exp_term=0.0;\n            flR.exp_scale=0.0;\n            flR.linear_term=0.0;\n            flR.constant_term=0.0;\n            \n            slR.width=0.0;\n            slR.exp_term=1.0;\n            slR.exp_scale=-0.000125;\n            slR.linear_term=0.0;\n            slR.constant_term=0.0;\n            \n            rayleighDensity.layer0 = flR;\n            rayleighDensity.layer1 = slR;\n            \n            \n            flM.width=0.0;\n            flM.exp_term=0.0;\n            flM.exp_scale=0.0;\n            flM.linear_term=0.0;\n            flM.constant_term=0.0;\n            \n            \n            slM.width=0.0;\n            slM.exp_term=1.0;\n            slM.exp_scale=-0.000833333;\n            slM.linear_term=0.0;\n            slM.constant_term=0.0;\n            \n            mieDensity.layer0 = flM;\n            mieDensity.layer1 = slM;\n        \n\n                    ${A("camPos")}  = ${A()}(0.0,0.0,${c("atmBottom")}+${c("viewAltitude")});\n\t\t\t\t\t${A("sunDir")}  = normalize(${c("sunDirection")});\n\t\t\t\t\t\n\t\t\t\t\t${A("view_ray")} ;\n\t\t\t\t\t${V("phi")}  = PI * (2.0 * screenUV.x - 1.0);\n\n                    ${V("theta")}  = PI * screenUV.y;\n\n\t\t\t\t\t//pour avoir un view ray cohrent avec l'espace monde _()_/\n\t\t\t\t\tview_ray.x = -sin(theta) * sin(phi);\n                    view_ray.y = sin(theta) * cos(phi);\n                    view_ray.z = -cos(theta); \n\t\t\t\t\t\n\t\t\t\t\tview_ray = normalize(view_ray);\n\t\t\t\t\t${A("nightHaze")} ;\n\t\t\t\t\t${A("scattering")}  = ${U("GetSkyScattering","v3",[N("tTrans"),N("tScatter"),T("camPos"),y("view_ray"),y("sunDir"),T("nightHaze")])};\n\n\t\t\t\t\t//sun\n\t\t\t\t\t//NRE IMPL\n\t\t\t\t\t${A("sunColor")}    = ${A()}(0.9911, 0.8308, 0.6172);\n\t\t\t\t\t${V("sunFactor")}  = smoothstep(0.999956, 0.999957, dot(view_ray, sunDir));\n\t\t\t\t\t${A("sun")}  = sunFactor * sunColor * 60.0;\n\t\t\t\t\tsun  *= min(sun.x,1.0);\n\t\t\t\t\t\n\t\t\t\t\t${V("r")} = length(camPos);\n\t\t\t\t\t${V("rmu")}  = dot(camPos, view_ray);\n\t\t\t\t\t${V("mu")}  = rmu / r;\n\t\t\t\t\t${z("intersectGround")}  = ${U("RayIntersectsGround","b",[g("r"),g("mu")])};\n\t\t\t\t\tif(intersectGround){\n                        //erase sun when goes behind earth, can be used to add a ground too\n\t\t\t\t\t\tsun  = ${A()}(0.0,0.0,0.0);\n\t\t\t\t\t}\n                ${A("color")} = scattering + nightHaze + sun;\n                ${t} = ${U("GetHDREncoded","v4",[y("color")])};           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:an(e),fragmentShader:r}},"SkyRendering"),ln,{}),PostProcessScattering:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");return{vertexShader:`\n            ${L({varyingName:"vUv",varyingType:"v2"})}\n            ${L({varyingName:"vRay",varyingType:"v4"})}\n\n            \n            ${$({uniformName:"near",uniformType:"f"})}\n            ${$({uniformName:"screenToView",uniformType:"v4"})}\n            ${$({uniformName:"invView",uniformType:"m4"})}\n\n            ${u.getMainVertexStart()}\n                ${I("pos")} = ${I()}( sign( position_.xy ), 0.0, 1.0 );\n                ${k("vUv")} = pos.xy * 0.5 + 0.5;\n                ${k("vRay")} = invView * vec4(${c("screenToView")}.xy + ${k("vUv")}*${c("screenToView")}.zw,-${c("near")},0.0);\n                ${E("position")} = pos;\n            ${u.getMainVertexEnd()}\n        `,fragmentShader:`\n            \n            ${L({varyingName:"vUv",varyingType:"v2"})}\n            ${L({varyingName:"vRay",varyingType:"v4"})}\n            \n            ${$({uniformName:"near",uniformType:"f"})}\n            ${$({uniformName:"far",uniformType:"f"})}\n            ${$({uniformName:"texturesLoaded",uniformType:"f"})}\n\n            ${rn()}\n            ${en()}\n            ${tn()}\n      \n            ${u.getMainFragmentStart()}\n                ${R("screenUV")} = ${B("vUv")};\n                ${I("ray")} = ${B("vRay")};\n\n                    ${A("camPos")}  = vec3(0.0,0.0,${c("atmBottom")}+${c("viewAltitude")});\n\t\t\t\t\t${A("sunDir")}  = ${c("sunDirection")};\n\t\t\t\t\tsunDir = normalize(sunDir);\n\t\t\t\t\t\n\t\t\t\t\t${A("viewRay")}  = ray.xyz;\n\t\t\t\t\tviewRay = normalize(viewRay);\n\t\t\t\t\t\n\t\t\t\t\t${I("color")}  = ${O("tDiffuse","screenUV")};\n\t\t\t\t\t\n\t\t\t\t\tif(${c("texturesLoaded")}==1.0){\n\t\t\t\t\t\n\t\t\t\t\t\tvec4 normalDepth = texture2D( tDepth, vUv );\n\t\t\t\t\t\t${V("zNDC")}  = 2.0*normalDepth.w - 1.0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//we don't build point position like NRE, its way too clunky for no reason\n\t\t\t\t\t\t//they rebuild the whole position instead of using cameraPosition and viewRay\n\t\t\t\t\t\t${V("viewZ")}  = zNDC *(2.0*${c("near")}*${c("far")} + ${c("far")} - ${c("near")} )/(${c("near")}+${c("far")});\n\t\t\t\t\t\t\n                        //ratio between actual depth to near\n\t\t\t\t\t\t${V("rayScale")}  = viewZ/${c("near")};\n                        //vRay contains the ray to near plane\n\t\t\t\t\t\t${A("rayToPoint")}  = ray.xyz * rayScale;\n                        //from mm to km\n\t\t\t\t\t\trayToPoint /= 1000000.0;\n\t\t\t\t\t\t${A("scatteringPos")}  = camPos + rayToPoint;\n\t\t\t\t\t\t\n\t\t\t\t\t\t${A("attenuation")}  = ${A()}(1.0);\n\t\t\t\t\t\t${A("nightHaze")}  = ${A()}(0.0);\n\t\t\t\t\t\t${A("scattering")}  = ${A()}(0.0);\n\t\t\t\t\t\t\n\t\t\t\t\t\t${V("r")}  = length(camPos);\n\t\t\t\t\t\t${V("rmu")}  = dot(camPos, viewRay);\n\t\t\t\t\t\t${V("mu")}  = rmu / r;\n\t\t\t\t\t\t${z("intersectGround")}  = ${U("RayIntersectsGround","b",[g("r"),g("mu")])};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(zNDC>-1.0){\n\t\t\t\t\t\t\tscattering = ${U("GetSkyScatteringWithDepth","v3",[N("tScatter"),T("camPos"),y("viewRay"),y("sunDir"),y("scatteringPos"),T("attenuation")])};\n                            ${A("reflColor")} = ${U("GetReflectedLight","v3",[N("tIrr"),N("tTrans"),y("color.xyz"),y("scatteringPos"),y("camPos"),y("sunDir"),y("attenuation")])};\n\t\t\t\t\t\t\tcolor.x = reflColor.x;\n\t\t\t\t\t\t\tcolor.y = reflColor.y;\n\t\t\t\t\t\t\tcolor.z = reflColor.z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor.x += scattering.x;\n\t\t\t\t\t\tcolor.y += scattering.y;\n\t\t\t\t\t\tcolor.z += scattering.z;\n\t\t\t\t\t\n\t\t\t\t\t}\n\n                ${t} = color;           \n            ${u.getMainFragmentEnd()}\n        `}},"SkyPostProcessScattering"),un,{})}}),define("DS/ShaderBuilders/PostPro/BlendingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=(i.ParameterUtils,i.FunctionHandler),m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>u.sample2DTexture(n,e);function x(e){return`          \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n\n        `}class y extends e{constructor(){super(1),this.offset=new n.Vector2(0,0),this.invSize=new n.Vector2(1,1),this.alphaMul=1,this.alphaAdd=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.offset,this.offset.x,this.offset.y),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y),t.uniform1f(r.alphaMul,this.alphaMul),t.uniform1f(r.alphaAdd,this.alphaAdd)}clone(){var n=new y;return n.offset=this.offset,n.invSize=this.invSize,n.alphaAdd=this.alphaAdd,n.alphaMul=this.alphaMul,n}}class _ extends e{constructor(){super(0),this.alphaMul=1,this.alphaAdd=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.alphaMul,this.alphaMul),t.uniform1f(r.alphaAdd,this.alphaAdd)}clone(){var n=new _;return n.alphaAdd=this.alphaAdd,n.alphaMul=this.alphaMul,n}}const T={POSTPRO:1};return{TextureAlphaBlend:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${t.POSTPRO?m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${m({uniformName:"tBlendingTexture",uniformType:"t2",locationName:"tInput1"})}\n\n            ${m({uniformName:"offset",uniformType:"v2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n            ${m({uniformName:"alphaAdd",uniformType:"f"})}\n            ${m({uniformName:"alphaMul",uniformType:"f"})}\n\n            void main() {\n                ${p("screenUV")} = (${g("vUv")} - ${$("offset")}) * ${$("invSize")};\n                ${f("sampling")} = ${S("tBlendingTexture","screenUV")};\n                ${d("color")} = sampling.rgb;\n                ${c("alpha")} = sampling.a;\n\n                ${t.POSTPRO?`               \n\t\t\t\t\t${f("sceneSampling")} = ${S("tScene","screenUV")};\n                    ${r} = ${f()}(color * alpha + (1.0 - alpha) * sceneSampling.rgb, alpha + sceneSampling.a * (1.0 - alpha));\n                    `:`\n                    ${r} = ${f()}(color, alpha);\n                    `}\n                ${c("finalAlpha")} = ${$("alphaMul")} * ${r}.a + ${$("alphaAdd")};\n                ${r} = ${f()}(${r}.rgb, finalAlpha);\n            }\n        `;return{vertexShader:x(e),fragmentShader:a}},"TextureAlphaBlend"),y,T),CopyBlend:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${t.POSTPRO?m({uniformName:"tInput",uniformType:"t2"}):l}\n            ${m({uniformName:"alphaAdd",uniformType:"f"})}\n            ${m({uniformName:"alphaMul",uniformType:"f"})}\n\n            void main() {\n                ${p("screenUV")} = ${g("vUv")};\n\n                ${t.POSTPRO?`               \n\t\t\t\t\t${f("sceneSampling")} = ${S("tInput","screenUV")};\n                    ${r} = ${f()}(sceneSampling.rgb, sceneSampling.a);\n                    `:`\n                    ${r} = ${f()}(0.0);\n                    `}\n                ${c("finalAlpha")} = ${$("alphaMul")} * ${r}.a + ${$("alphaAdd")};\n                ${r} = ${f()}(${r}.rgb, finalAlpha);\n            }\n        `;return{vertexShader:x(e),fragmentShader:a}},"CopyBlend"),_,T)}}),define("DS/ShaderBuilders/PostPro/BlurShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterV2(n),d=(n,e,t)=>m.declareFunction(n,e,t),f=(n,e,t)=>m.callFunction(n,e,t),h=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},y=n=>o.addVarying(n),_=n=>o.getVarying(n,o.ShaderStages.in),T=n=>o.getVarying(n,o.ShaderStages.out),D=(n,e)=>m.sample2DTexture(n,e),C={LEVEL:1};function P(e){return`\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            void main() {\n\n                ${T("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}function N(n){let e=[],t=[],r=l;switch(n){case 1:default:e.push(-1.2),t.push(.3125),e.push(0),t.push(.375),e.push(1.2),t.push(.3125);break;case 2:e.push(-1.285714285714),t.push(.328125),e.push(0),t.push(.3125),e.push(1.285714285714),t.push(.328125);break;case 3:e.push(-3.111111111111),t.push(.03515625),e.push(-1.333333333333),t.push(.328125),e.push(0),t.push(.2734375),e.push(1.333333333333),t.push(.328125),e.push(3.111111111111),t.push(.03515625);break;case 4:e.push(-3.181818181818),t.push(.0537109375),e.push(-1.363636363636),t.push(.322265625),e.push(0),t.push(.24609375),e.push(1.363636363636),t.push(.322265625),e.push(3.181818181818),t.push(.0537109375);break;case 5:e.push(-5.076923076923),t.push(.003173828125),e.push(-3.230769230769),t.push(.06982421875),e.push(-1.384615384615),t.push(.314208984375),e.push(0),t.push(.2255859375),e.push(1.384615384615),t.push(.314208984375),e.push(3.230769230769),t.push(.06982421875),e.push(5.076923076923),t.push(.003173828125)}for(let n=0;n<e.length;n++){let a=0!==e[n]?e[n]:"0.0";r=`\n                ${r}\n                result += ${D("tInput",`screenPos + ${a} * blurSize`)} * ${t[n]};\n            `}return r}class M extends e{constructor(){super(),this.direction=new n.Vector2(1,1),this.blurSize=1,this.ratio=1,this.kernel=[]}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.blurSize,this.blurSize),t.uniform1f(r.ratio,this.ratio),t.uniform2f(r.direction,this.direction.x,this.direction.y),t.uniform1fv(r.kernel,this.kernel)}clone(){var n=new M;return n.direction=this.direction,n.blurSize=this.blurSize,n.ratio=this.ratio,n.kernel=this.kernel,n}}class b extends e{constructor(e=0){super(e),this.invSize=new n.Vector2(1,1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){var n=new b;return n.invSize=this.invSize,n}}class w extends b{constructor(){super(),this.radius=1}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.radius,this.radius)}clone(){var n=new w;return n.invSize=this.invSize,n.radius=this.radius,n}}class U extends b{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){var n=new U;return n.invSize=this.invSize,n}}const z={NB_SAMPLES:4,STEP:1.5};function V(n){return`\n            ${d("getNormalDepth","v4",[p("uv")])} {\n                ${x("normalDepth")} = ${D("tNormalDepth","uv")};\n                ${n.renderToFloatTexture?`\n                    return ${x()}(normalDepth.xyz * 2.0 - 1.0, normalDepth.w);\n                    `:`\n                    ${S("normal")} = ${f("decodeOct22Normal","v3",[p("normalDepth.xy")])};\n                    ${g("depth")} = ${f("unpackForFloat16","f",[p("normalDepth.zw")])};\n                    return ${x()}(normal, depth);\n                    `}\n            }\n\n        `}function F(n,e){return`\n            ${x("normalDepth")} = ${f("getNormalDepth","v4",[p("screenPos")])};\n            ${S("normal")} = normalDepth.xyz;\n            ${g("depth")} = normalDepth.w;\n            for (${h("i")} = -${n}; i <= ${n}; i++) {\n                for (${h("j")} = -${e}; j <= ${e}; j++) {\n                    // no blur on center\n                    if (i == 0 && j == 0) {\n                        continue;\n                    }\n                    ${v("pos")} = screenPos + offset * ${v()}(${g()}(i), ${g()}(j));            \n                    \n                    ${x("normalDepth2")} = ${f("getNormalDepth","v4",[p("pos")])};\n                    ${S("normal2")} = normalDepth2.xyz;\n                    ${g("depth2")} = normalDepth2.w;\n\n                    ${g("weightDepth")} = 1.0 / (1.0 + 100.0 * abs(depth2 - depth));\n                    ${g("weightNormal")} = clamp(dot(normal, normal2), 0.0, 1.0);\n\n                    result += weightDepth * weightNormal * ${D("tInput","pos")}.xyz;\n                    total += weightDepth * weightNormal;\n                }\n            }\n        `}return{Blur:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            ${$({uniformName:"blurSize",uniformType:"f"})}\n            ${$({uniformName:"ratio",uniformType:"f"})}\n            ${$({uniformName:"direction",uniformType:"v2"})}\n            ${$({uniformName:"kernel",uniformType:"fv1",size:2*t.LEVEL+1})}\n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("screenPos")} = ${_("vUv")};\n\n                ${v("dir")} = ${c("direction")} * ${c("blurSize")} * ${c("ratio")} * 0.5 / ${g()}(${t.LEVEL});\n\n                ${x("color")} = ${x()}(0.0);\n                for (${h("i")} = -${t.LEVEL}; i <= ${t.LEVEL}; i++) {\n                    ${v("texCoord")} = dir * ${g()}(i) + screenPos;\n                    ${x("sampleCol")} = ${D("tInput","texCoord")};\n\n                    color += sampleCol * ${c("kernel")}[i+${t.LEVEL}];\n                }\n                ${r} = color;\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurBasic"),M,C),BlurH:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("screenPos")} = ${_("vUv")};\n\n                ${x("result")} = ${x()}(0.0);\n                ${v("blurSize")} = ${v()}(${c("invSize")}.x, 0.0);\n\n                ${N(t.LEVEL)}\n\n                ${r} = result;\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurH"),b,C),BlurV:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("screenPos")} = ${_("vUv")};\n\n                ${x("result")} = ${x()}(0.0);\n                ${v("blurSize")} = ${v()}(0.0, ${c("invSize")}.y);\n\n                ${N(t.LEVEL)}\n\n                ${r} = result;\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurV"),b,C),BlurPoisson:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0"),r="tInput",a=[-.326212,-.405805,-.840144,-.07358,-.695914,.457137,-.203345,.620716,.96234,-.194983,.473434,-.480026,.519456,.767022,.185461,-.893124,.507431,.064425,.530992,.412458,-.32194,-.871945,-.791559,.597705],i=2/a.length;let s=`\n            \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"radius",uniformType:"f"})}\n            ${$({uniformName:"tInput",uniformType:"t2"})}\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${v("screenPos")} = ${_("vUv")};\n\n                ${x("result")} = ${x()}(0.0);\n                ${v("blurSize")} = ${c("radius")} * ${c("invSize")};\n\n                ${function(){for(var n=l,e=0;e<a.length;e+=2)n=`\n                    ${n}\n                    result += ${D(r,`screenPos + blurSize *${v()}(${a[e]}, ${a[e+1]})`)};\n                `;return n}()}\n\n                ${t} = result * ${i};\n            }\n        `;return{vertexShader:P(e),fragmentShader:s}},"BlurPoisson"),w,{}),BlurAdaptativeHV:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${V(e)}\n\n            void main() {         \n                ${v("screenPos")} = ${_("vUv")};\n                ${S("result")} = ${D("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${v("offset")} = ${t.STEP} * ${c("invSize")};\n\n                ${F(t.NB_SAMPLES,t.NB_SAMPLES)}\n\n                ${r} = ${x()}(result / total, 1.0);\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurAdaptativeHV"),U,z),BlurAdaptativeH:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${V(e)}\n\n            void main() {         \n                ${v("screenPos")} = ${_("vUv")};\n                ${S("result")} = ${D("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${v("offset")} = ${t.STEP} * ${v()}(${c("invSize")}.x, 0.0);\n\n                ${F(t.NB_SAMPLES,0)}\n\n                ${r} = ${x()}(result / total, 1.0);\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurAdaptativeH"),U,z),BlurAdaptativeV:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=` \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${V(e)}\n\n            void main() {         \n                ${v("screenPos")} = ${_("vUv")};\n                ${S("result")} = ${D("tInput","screenPos")}.xyz;\n                ${g("total")} = 1.0;\n\n                ${v("offset")} = ${t.STEP} * ${v()}(0.0, ${c("invSize")}.y);\n\n                ${F(0,t.NB_SAMPLES)}\n\n                ${r} = ${x()}(result / total, 1.0);\n            }\n        `;return{vertexShader:P(e),fragmentShader:a}},"BlurAdaptativeV"),U,z)}}),define("DS/ShaderBuilders/PostPro/SSLRShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=()=>s.dereference(),p=n=>l.parameterF(n),d=n=>l.parameterInOutF(n),f=n=>l.parameterRefF(n),h=n=>l.parameterV2(n),g=n=>l.parameterV3(n),v=n=>l.parameterV4(n),S=(n,e,t)=>u.declareFunction(n,e,t),x=(n,e,t)=>u.callFunction(n,e,t),y=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},D=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},C=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},P=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},N=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},M=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},b=n=>o.addVarying(n),w=n=>o.getVarying(n,o.ShaderStages.in),U=n=>o.getVarying(n,o.ShaderStages.out),z=(n,e)=>u.sample2DTexture(n,e);function V(e){return`\n            ${b({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${U("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n\n        `}class F extends e{constructor(){super(2),this.realProjectionMatrix=new n.Matrix4,this.realProjectionMatrixInverse=new n.Matrix4,this.frustumPlanes=[],this.sceneSize=100,this.screenSize=new n.Vector2(512,512),this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.sceneSize,this.sceneSize),t.uniform1i(r.renderIteration,this.renderIteration),t.uniform4fv(r.frustumPlanes,this.frustumPlanes),t.uniform2f(r.screenSize,this.screenSize.x,this.screenSize.y),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.realProjectionMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrix.elements))}clone(){var n=new F;return n.realProjectionMatrix=this.realProjectionMatrix,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.frustumPlanes=this.frustumPlanes,n.sceneSize=this.sceneSize,n.screenSize=this.screenSize,n.renderIteration=this.renderIteration,n}}function R(n,e){return`\n            \n        ${b({varyingName:"vUv",varyingType:"v2"})}\n\n        ${m({uniformName:"tColor",uniformType:"t2",locationName:"tInput0"})}\n        ${m({uniformName:"tColorNormalDepth",uniformType:"t2",locationName:"tInput1"})}      \n        ${m({uniformName:"tNormalDepthIoRRoughness",uniformType:"t2",locationName:"tInput2"})}\n\n        ${m({uniformName:"realProjectionMatrix",uniformType:"m4"})}\n        ${m({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${m({uniformName:"frustumPlanes",uniformType:"fv4",size:6})}\n        ${m({uniformName:"sceneSize",uniformType:"f"})}\n        ${m({uniformName:"screenSize",uniformType:"v2"})}\n        ${m({uniformName:"renderIteration",uniformType:"i"})}\n\n        ${e?`          \n            ${_("MAX_RAY")} = 8;\n            ${D("MAX_RAY_F")} = 8.0;\n            ${D("I_MAX_RAY_F")} = 1.0 / 8.0;\n            `:`\n            ${_("MAX_RAY")} = 4;\n            ${D("MAX_RAY_F")} = 4.0;\n            ${D("I_MAX_RAY_F")} = 1.0 / 4.0;\n            `}\n        ${D("PI")} = 3.14159265359;\n        ${D("INV_GOLDEN_RATIO")} = 0.6180339887;\n        ${N("CLAMP_VALUE")} = ${P()}(3.0);\n            \n        ${S("toViewPos","v3",[h("uv"),p("depth")])}{\n\n            ${M("vertexPositionProjected")} = ${M()}(uv * 2.0 - 1.0, depth, 1.0);\n            ${M("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${S("toViewPos","v3",[h("uv")])}{\n\n            ${T("z")} = ${z("tColorNormalDepth","uv")}.w; // [0.0, 1.0]\n            if (z == 0.0) z = 1.0;\n\n            return ${x("toViewPos","v3",[h("uv"),p("2.0 * z - 1.0")])};\n        }\n\n        ${S("getScreenPos3","v3",[g("pos")])} {\n\n            ${M("offset")}  = ${$("realProjectionMatrix")} * ${M()}(pos, 1.0);\n            offset.x /= offset.w;\n            offset.y /= offset.w;\n            offset.z /= offset.w;\n            offset.x = offset.x * 0.5 + 0.5;\n            offset.y = offset.y * 0.5 + 0.5;\n\n            return offset.xyz;\n        }\n\n        ${S("sampleColorScene","v4",[h("uv")])} {\n            ${M("color")}  = ${z("tColor","uv")};\n            ${n.noCompositing?`\n                return ${M()}(${x("convertToLinear","v3",[g("color.rgb")])}, color.a);\n                `:"\n                return color;\n                "}\n        }\n\n        ${S("random","f",[g("scale"),p("seed")])} {\n            return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n\n        ${S("Random1D","f",[p("seed")])} {\n            ${P("scale")} = ${P()}(12.9898, 78.233, 151.7182);\n            return ${x("random","f",[g("scale"),p("seed")])};\n        }\n\n        ${S("GetLightVector","v3",[g("N"),g("H")])}{\n            return 2.0 * dot(N, H) * H - N;\n        }\n\n        ${S("ComputeIndex","f",[p("id"),p("N")])}{\n            float val = id * N * 24.0;\n            float n = val / N;\n            float m = mod(val, N);\n            return n + m;\n        }\n\n        ${S("LowDiscrepancy2D","v2",[p("i"),p("N")])} {\n            float id = ${x("ComputeIndex","f",[p("i"),p("N")])};\n            return vec2(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));\n        }\n\n        ${S("TangentToWorld","v3",[g("Vec"),g("TangentZ")])} {\n\n            ${P("UpVector")}  = ${P()}(1.0,0.0,0.0);\n            if (abs(TangentZ.z) < 0.999) {\n                UpVector = ${P()}(0.0, 0.0, 1.0);\n            }\n            ${P("TangentX")}  = normalize(cross(UpVector, TangentZ));\n            ${P("TangentY")}  = cross(TangentZ, TangentX);\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        ${S("ImportanceSampleGGX","v3",[h("Xi"),p("roughness")])}{\n\n            ${P("H")};\n            ${T("Phi")}  = 2.0 * PI * Xi.x;\n            ${T("a")}  = roughness * roughness;\n            ${T("a2")}  = a * a;\n\n            ${T("CosTheta")}  = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n            ${T("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n\n            H.x = SinTheta * cos(Phi);\n            H.y = SinTheta * sin(Phi);\n            H.z = CosTheta;\n            return H;\n        }\n\n        ${S("ClipByPlane","f",[g("origin"),g("direction"),v("plane"),p("t")])}{\n\n            ${T("clipVal")}  = dot(plane, ${M()}(origin, 1.0));\n            ${T("k")} = -clipVal / dot(plane.xyz, direction);\n            if (k < 0.0) return t;\n            return min(t, k);\n        }\n\n        ${S("ClipByFrustum","f",[g("origin"),g("direction")])} {\n\n            ${T("t")} = 1000000000000.0;\n\n            for (${y("k")} = 0; k < 6; ++k) {\n                t = ${x("ClipByPlane","f",[g("origin"),g("direction"),v(`${$("frustumPlanes")}[k]`),p("t")])};\n            }\n\n            return t;\n        }\n        `}function A(n,e){const t=o.getShaderOutput("out0");return`\n        \n\t\t\t\t${T("roughness")}  = normalDepth.z;\n                ${T("z")}  = normalDepth.w;\n\n                if ( z == 0.0 ) return;\n\n                ${P("normal")}  = ${x("decodeOct24Normal","v3",[p("normalDepth.x")])};\n\n                ${P("origin")}  = ${x("toViewPos","v3",[h("vUv"),p("2.0 * z - 1.0")])};\n                ${P("V")}  = ${P()}(0.0,0.0,1.0);\n                if (realProjectionMatrix[3][3] <= 0.5) {\n                    V = normalize(-origin);\n                }\n\n                ${P("L")} ;\n                ${T("hitDistance")}  = 0.0;\n\n                ${T("iteration")} = ${T()}(${$("renderIteration")});\n                if (iteration > 2.0 ) {\n                    for (${y("i")} = 0; i < MAX_RAY; i++) {\n                        ${T("id")} = ${T()}(i + 1);\n                        ${C("E")} = ${x("LowDiscrepancy2D","v2",[p("id * (iteration - 2.0)"),p("MAX_RAY_F * 125.0")])};\n\n                        ${P("perturbedZ")}  = ${x("ImportanceSampleGGX","v3",[h("E"),p("roughness")])};\n                        ${P("H")}  = ${x("TangentToWorld","v3",[g("perturbedZ"),g("normal")])};\n\n                        ${e?`\n                            ${P("Vflip")} = reflect(${x("GetLightVector","v3",[g("V"),g("H")])}, normal);\n                            L = refract(Vflip, normal, 1.0/ior);\n                            `:`\n                            L = ${x("GetLightVector","v3",[g("V"),g("H")])};\n                            `}\n                        ${t} += ${x("RayMarchNew","v4",[g("origin"),g("normalize(L)"),f("hitDistance")])};\n                    }\n                    ${t} *= I_MAX_RAY_F;\n                } else {\n                    ${P("H")}  = normal;              \n                    ${e?`\n                        ${P("Vflip")} = reflect(${x("GetLightVector","v3",[g("V"),g("H")])}, normal);\n                        L = refract(Vflip, normal, 1.0/ior);\n                        `:`\n                        L = ${x("GetLightVector","v3",[g("V"),g("H")])};\n                        `}\n                    ${t} = ${x("RayMarchNew","v4",[g("origin"),g("normalize(L)"),f("hitDistance")])};\n                }\n                ${P("clampedColor")} = min(${t}.rgb,CLAMP_VALUE);\n                ${t}.r = clampedColor.r;\n                ${t}.g = clampedColor.g;\n                ${t}.b = clampedColor.b;\n        `}class I extends e{constructor(){super(8),this.realProjectionMatrixInverse=new n.Matrix4,this.sceneSize=100,this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.sceneSize,this.sceneSize),t.uniform1i(r.renderIteration,this.renderIteration),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements))}clone(){var n=new I;return n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n.sceneSize=this.sceneSize,n.renderIteration=this.renderIteration,n}}function L(n){function e(n){const e="tMip"+(n+1);return`\n                {return mix(${z("tMip"+n,"uv")}, ${z(e,"uv")}, mipValues.y);}\n            `}return`\n\n        ${b({varyingName:"vUv",varyingType:"v2"})}\n\n        ${m({uniformName:"tMip0",uniformType:"t2",locationName:"tInput0"})}\n        ${m({uniformName:"tMip1",uniformType:"t2",locationName:"tInput1"})}   \n        ${m({uniformName:"tMip2",uniformType:"t2",locationName:"tInput2"})}      \n        ${m({uniformName:"tMip3",uniformType:"t2",locationName:"tInput3"})}     \n        ${m({uniformName:"tMip4",uniformType:"t2",locationName:"tInput4"})}      \n        ${m({uniformName:"tMip5",uniformType:"t2",locationName:"tInput5"})}      \n        ${m({uniformName:"tMip6",uniformType:"t2",locationName:"tInput6"})}      \n        ${m({uniformName:"tMip7",uniformType:"t2",locationName:"tInput7"})}          \n        ${m({uniformName:"tNormalDepthIoRRoughness",uniformType:"t2",locationName:"tInput8"})}\n\n        ${m({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n        ${m({uniformName:"sceneSize",uniformType:"f"})}\n        ${m({uniformName:"renderIteration",uniformType:"i"})}\n\n        ${S("toViewPos","v3",[h("uv"),p("depth")])}{\n\n            ${M("vertexPositionProjected")} = ${M()}(uv * 2.0 - 1.0, depth, 1.0);\n            ${M("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n            vertexPositionVS.x /= vertexPositionVS.w;\n            vertexPositionVS.y /= vertexPositionVS.w;\n            vertexPositionVS.z /= vertexPositionVS.w;\n            vertexPositionVS.w = 1.0;\n\n            return vertexPositionVS.xyz;\n        }\n\n        ${S("sampleScene","v4",[h("uv"),h("mipValues")])} {\n            if (mipValues.x == 0.0) ${e(0)}\n            if (mipValues.x == 1.0) ${e(1)}\n            if (mipValues.x == 2.0) ${e(2)}\n            if (mipValues.x == 3.0) ${e(3)}\n            if (mipValues.x == 4.0) ${e(4)}\n            if (mipValues.x == 5.0) ${e(5)}\n            if (mipValues.x == 6.0) ${e(6)}\n            return ${z($("tMip7"),"uv")};\n        }\n        `}function B(n){const e=o.getShaderOutput("out0");return`\n        \n            ${T("roughness")} = normalDepth.z;\n            ${T("powerVal")} = 0.8;\n            if (${$("renderIteration")} > 2) {\n                powerVal = 1.8;\n            }\n            ${C("mipValues")};\n            mipValues.x = 7.0 * pow(roughness, powerVal);\n            mipValues.y = fract(mipValues.x);\n            mipValues.x = floor(mipValues.x);\n\n            ${e} = ${x("sampleScene","v4",[h("screenPos"),h("mipValues")])};\n        `}return{SSLRefraction:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n        \n            ${R(e,!0)}\n\n            \n\n            ${S("RayMarchNew","v4",[g("origin"),g("direction"),d("hitDistance")])} {\n                ${M("outColor")}  = ${M()}(0.0);\n                ${c()}hitDistance = ${$("sceneSize")};\n\n                ${T("maxRayLength")}  = ${$("sceneSize")};\n                ${T("t")} = ${x("ClipByFrustum","f",[g("origin"),g("direction")])};\n                maxRayLength = min(t, maxRayLength);\n\n                ${P("endPos")}  = origin + maxRayLength * direction;\n                ${P("uviz0")}  = ${x("getScreenPos3","v3",[g("origin")])};\n                ${P("uviz1")}  = ${x("getScreenPos3","v3",[g("endPos")])};\n\n                ${C("uvDir")}  = uviz1.xy - uviz0.xy;\n                ${T("nbSteps")}  = length(${$("screenSize")} * uvDir);\n\n                if (nbSteps < 1.0) {\n                    ${P("curOnSegment")}  = ${x("toViewPos","v3",[h("uviz1.xy"),p("uviz1.z")])};\n                    ${P("curPt")}  = ${x("toViewPos","v3",[h("uviz1.xy")])};\n                    if (curPt.z > curOnSegment.z) {\n                        ${c()}hitDistance = length(curPt - origin);\n                        outColor = ${x("sampleColorScene","v4",[h("uviz1.xy")])};\n                    }\n                    return outColor;\n                }\n                nbSteps = ceil(nbSteps);\n\n                ${T("j")}  = 0.0;\n                ${T("prevDepth")}  = 1.0;\n                ${T("prevSegmentDepth")}  = 1.0;\n                for (${y("i")} = 0; i < 1024; i++) {\n                    ${P("sampleScreenPos")}  = mix(uviz0, uviz1, j / nbSteps);\n                    ${P("curOnSegment")}  = ${x("toViewPos","v3",[h("sampleScreenPos.xy"),p("sampleScreenPos.z")])};\n                    ${P("curPt")}  = ${x("toViewPos","v3",[h("sampleScreenPos.xy")])};\n                    if (abs(1.0 - curPt.z/curOnSegment.z) < 5e-3) {\n                        // ray has intersected \n                        ${c()}hitDistance = length(curPt - origin);\n                        outColor = ${x("sampleColorScene","v4",[h("sampleScreenPos.xy")])};\n                        break;\n                    }\n                    // ray was in front in previous\n                    // ray is behind on cur\n                    else if (prevSegmentDepth >= prevDepth && curOnSegment.z <= curPt.z) {\n                        ${c()}hitDistance = length(curPt - origin);                         \n                        ${P("sampleScreenPosToUse")}  = mix(uviz0, uviz1, (j - 1.0) / nbSteps);\n                        outColor = ${x("sampleColorScene","v4",[h("sampleScreenPosToUse.xy")])};\n                        break;\n                    }\n                    prevDepth = curPt.z;\n                    prevSegmentDepth = curOnSegment.z;\n                    if (j >= nbSteps) { break; }\n                    j += 1.0;\n                }\n                return outColor;\n            }\n\n            void main() {\n                // varying storage\n                ${C("screenPos")} = ${w("vUv")};\n\n                ${t} = ${M()}(0.0, 0.0, 0.0, 0.0);\n                ${M("normalDepth")}  = ${z("tNormalDepthIoRRoughness","screenPos")};\n                ${T("ior")} = normalDepth.y;\n                // current pixel is not transparent\n                if (ior < 1.0) {\n                    return;\n                }\n                ${A(0,!0)}\n            }\n        `;return{vertexShader:V(e),fragmentShader:r}},"RayMarchingRefraction"),F,{}),SSLRefractionMipSolver:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`                \n                ${L()}\n\n                void main() {\n                    // varying storage\n                    ${C("screenPos")} = ${w("vUv")};\n    \n                    ${t} = ${M()}(0.0, 0.0, 0.0, 0.0);\n\n                    ${M("normalDepth")} = ${z("tNormalDepthIoRRoughness","screenPos")};\n                    \n                    ${T("ior")}  = normalDepth.y;\n                    // current pixel is not transparent\n                    if (ior < 1.0) {\n                        return;\n                    }\n\n                    ${B()}\n                }\n            `;return{vertexShader:V(e),fragmentShader:r}},"RayMarchingRefractionSolver"),I,{}),SSLReflectionMipSolver:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`            \n                ${L()}\n    \n                void main() {\n                    // varying storage\n                    ${C("screenPos")} = ${w("vUv")};\n    \n                    ${t} = ${M()}(0.0, 0.0, 0.0, 0.0);\n\n                    ${M("normalDepth")} = ${z("tNormalDepthIoRRoughness","screenPos")};\n                    ${B()}\n                }\n            `;return{vertexShader:V(e),fragmentShader:r}},"RayMarchingReflectionSolver"),I,{}),SSLReflection:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n        \n            ${R(e,!1)}\n\n            \n            ${S("RayMarchNew","v4",[g("origin"),g("direction"),d("hitDistance")])} {\n\n                ${M("outColor")}  = ${M()}(0.0);\n                ${c()}hitDistance = ${$("sceneSize")};\n\n                ${T("maxRayLength")}  = ${$("sceneSize")};\n                ${T("t")}  = ${x("ClipByFrustum","f",[g("origin"),g("direction")])};\n\n                if (t <= 0.0) {\n                    return outColor;\n                }\n                maxRayLength = min(t, maxRayLength);\n\n                ${P("endPos")}  = origin + maxRayLength * direction;\n                ${P("uviz0")}  = ${x("getScreenPos3","v3",[g("origin")])};\n                ${P("uviz1")}  = ${x("getScreenPos3","v3",[g("endPos")])};\n\n                ${C("uvDir")}  = uviz1.xy - uviz0.xy;\n                ${T("nbSteps")}  = max(1.0, length(${$("screenSize")} * uvDir));\n\n                ${T("ray_marching_step")}  = 16.0;\n                ${T("j")}  = ray_marching_step;\n\n                for (${y("i")}  = 0; i < 1024; ++i) {\n                    // reach the border of the screen\n                    if (j > nbSteps) break; \n\n                    ${P("sampleScreenPos")}  = mix(uviz0, uviz1, j / nbSteps);\n\n                    ${M("normalDepth")}  = ${z("tColorNormalDepth","sampleScreenPos.xy")};\n                    ${T("z")}  = 2.0 * normalDepth.w - 1.0;\n\n                    ${T("diffZ")}  = sampleScreenPos.z - z; \n                    // the ray is behind the object\n                    if (normalDepth.w > 0.0 && diffZ > 0.0) {\n                        if (ray_marching_step == 1.0) {\n                            ${P("hit")}  = ${x("toViewPos","v3",[h("sampleScreenPos.xy"),p("sampleScreenPos.z")])};\n                            ${T("zOrigin")}  = ${x("toViewPos","v3",[h("sampleScreenPos.xy")])}.z;\n                            if (abs(1.0 - hit.z / zOrigin) < 1e-2) {                  \n                                ${c()}hitDistance = length(hit - origin);\n                                outColor = ${x("sampleColorScene","v4",[h("sampleScreenPos.xy")])};\n                            }\n                            break;\n                        } else {\n                            ray_marching_step *= 0.5;\n                            j -= ray_marching_step;\n                        }\n                    } else {\n                        ${T("seed")} = ${T()}(${$("renderIteration")}) + j;\n                        j += (0.5 + 0.5 * ${x("Random1D","f",[p("seed")])}) * ray_marching_step;\n                    }\n                }\n                return outColor;\n            }\n\n            void main() {\n                // varying storage\n                ${C("screenPos")} = ${w("vUv")};\n\n                ${t} = ${M()}(0.0, 0.0, 0.0, 0.0);\n\n                ${M("normalDepth")}  = ${z("tNormalDepthIoRRoughness","screenPos")};\n\n                ${A(0,!1)}\n            }\n        `;return{vertexShader:V(e),fragmentShader:r}},"RayMarchingReflection"),F,{})}}),define("DS/ShaderBuilders/PostPro/ConvertShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterT2(n),h=(n,e,t)=>m.declareFunction(n,e,t),g=(n,e,t)=>m.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>m.sample2DTexture(n,e),P=(n,e)=>m.sampleCubeTexture(n,e);class N extends e{constructor(){super(),this.size=new n.Vector2(1,1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.size,this.size.x,this.size.y)}clone(){var n=new N;return n.size=this.size,n}}function M(e){return`      \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}const b={SRGB_INPUT:0,RGBE_INPUT:0};return{CubemapToLatlong:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0"),a=t.ORIENTATION;let i=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tCube",uniformType:"tc",locationName:"tInput"})}\n\n            ${S("PI")} = 3.14159265358979323846264;\n\n            void main() {\n                ${x("screenUV")} = ${T("vUv")};\n\n                ${y("N")};\n                ${v("phi")} = PI * (2.0 * screenUV.x - 1.0);\n                ${v("theta")};\n\n                ${1===a?"\n                    theta = PI * screenUV.y;\n                    N.x = sin(theta) * sin(phi);\n                    N.y = cos(theta);\n                    N.z = sin(theta) * cos(phi);\n                    ":`\n                    theta = PI * (1.0 - screenUV.y);\n                    N.x = sin(theta) * cos(phi);\n                    ${2===a?"\n                        N.y = -cos(theta);\n                        N.z = sin(theta) * sin(phi);\n                        ":"\n                        N.y = sin(theta) * sin(phi);\n                        N.z = cos(theta);\n                        "}\n                    `}\n                ${r} = ${P("tCube","N")};\n            }\n        `;return{vertexShader:M(e),fragmentShader:i}},"CubemapToLatlong"),N,{ORIENTATION:0}),LatlongToDualParaboloid:new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0"),i=r.SRGB_INPUT>0,s=r.RGBE_INPUT>0;let u=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tMap",uniformType:"t2",locationName:"tInput"})}\n            ${$({uniformName:"size",uniformType:"v2"})}\n\n            ${S("PI")} = 3.14159265358979323846264;\n            ${S("SCALE")} = 1.2;\n\n            ${h("myAtan2","f",[p("y"),p("x")])} {\n                if (x > 0.0) {\n                    return sign(y) * atan(abs(y/x));\n                } else if (x < 0.0) {\n                    return sign(y) * (PI - atan(abs(y/x)));\n                }\n                return 0.5 * PI * sign(y);\n            }\n\n            ${n._DefaultShaderChunk.rgbe_sample_methods(t)}\n\n            void main() {\n                ${x("screenUV")} = ${T("vUv")};\n                ${x("uv")} = ${x()}(fract(2.0 * screenUV.x), screenUV.y);\n\n                ${v("phi")} = ${g("myAtan2","f",[p("2.0 * uv.y - 1.0"),p("2.0 * uv.x - 1.0")])};\n                ${v("theta")};\n                ${v("u")};\n\n                // z < 0\n                if(screenUV.x < 0.5) {\n                    theta = 2.0 * atan(cos(phi) / (SCALE * (2.0 * uv.x - 1.0)));\n                    u = fract(0.5 * phi / PI);\n                } else {\n                    theta = 2.0 * atan(SCALE * (1.0 - 2.0 * uv.x) / cos(phi));\n                    phi += 1.0*PI;\n                    u = fract(0.5*phi / PI);\n                }\n                ${v("v")} = abs(theta / PI);\n                ${x("fetchUV")} = ${x()}(u,v);\n                ${s?`\n                    ${x("mapSize")} = ${c("size")};\n                    ${a} = ${g("texture2DBilinearFromRGBE","v4",[f("tMap"),d("fetchUV"),d("mapSize"),d("1.0 / mapSize")])};\n                    `:`\n                    ${a} = ${C("tMap","fetchUV")};\n                    `}\n                ${i?`\n                    ${a}.x *= ${a}.x;\n                    ${a}.y *= ${a}.y;\n                    ${a}.z *= ${a}.z;\n                    `:l}\n            }\n        `;return{vertexShader:M(t),fragmentShader:u}},"LatlongToDualParaboloid"),N,b),ToRGBLuminance:new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0"),i=r.RGBE_INPUT>0,s=r.SRGB_INPUT>0;let u=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${$({uniformName:"tMap",uniformType:"t2",locationName:"tInput"})}\n            ${$({uniformName:"size",uniformType:"v2"})}\n\n            ${n._DefaultShaderChunk.rgbe_sample_methods(t)}\n\n            void main() {\n                ${x("screenUV")} = ${T("vUv")};\n                ${i?`\n                    ${x("mapSize")} = ${c("size")};\n                    ${a} = ${g("texture2DBilinearFromRGBE","v4",[f("tMap"),d("screenUV"),d("mapSize"),d("1.0 / mapSize")])};\n                    `:`\n                    ${a} = ${C("tMap","screenUV")};\n                    `}\n                ${s?`\n                    ${a}.x *= ${a}.x;\n                    ${a}.y *= ${a}.y;\n                    ${a}.z *= ${a}.z;\n                    `:l}\n                ${a}.a = dot(${a}.xyz, ${y()}(0.299, 0.587, 0.114));\n            }\n        `;return{vertexShader:M(t),fragmentShader:u}},"ToRGBLuminance"),N,b)}}),define("DS/ShaderBuilders/PostPro/ExposureShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=(i.ParameterUtils,i.FunctionHandler),m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},h=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},g=n=>o.addVarying(n),v=n=>o.getVarying(n,o.ShaderStages.in),S=n=>o.getVarying(n,o.ShaderStages.out),x=(n,e)=>u.sample2DTexture(n,e);class y extends e{constructor(){super(1),this.clampMin=-10,this.clampMax=20}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.clampMin,this.clampMin),t.uniform1f(r.clampMax,this.clampMax)}clone(){return new y}}return{WeightedLuminance:new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0");let i=`\n            \n            ${g({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${r.USE_WEIGHT_TEXTURE>0?m({uniformName:"tWeight",uniformType:"t2",locationName:"tInput1"}):l}\n            ${m({uniformName:"clampMin",uniformType:"f"})}\n            ${m({uniformName:"clampMax",uniformType:"f"})}\n\n            ${f("luminance_weight")} = ${d()}(0.176204,0.812985,0.0108109);\n  \n\n            ${u.getMainFragmentStart()}\n                ${p("screenUV")} = ${v("vUv")};\n                ${h("color")} = ${x("tInput","screenUV")};\n                ${c("weight")} = 1.0;\n                ${r.USE_WEIGHT_TEXTURE>0?`\n                    weight = ${x("tWeight","screenUV")}.r;\n                    `:l}\n                ${c("luminance")} = dot(color.xyz, luminance_weight);\n                ${c("value")} = weight * clamp(log(luminance),${$("clampMin")},${$("clampMax")});\n                ${a} = ${h()}(value,weight,0.0, 1.0);       \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:function(e){return`           \n            ${g({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${S("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}(t),fragmentShader:i}},"WeightedLuminance"),y,{USE_WEIGHT_TEXTURE:0})}}),define("DS/ShaderBuilders/PostPro/CompareShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterV4(n),h=(n,e,t)=>m.declareFunction(n,e,t),g=(n,e,t)=>m.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},y=n=>o.addVarying(n),_=n=>o.getVarying(n,o.ShaderStages.in),T=n=>o.getVarying(n,o.ShaderStages.out),D=(n,e)=>m.sample2DTexture(n,e);class C extends e{constructor(){super(3),this.realProjectionMatrixInverse=new n.Matrix4,this.tolerance=1e-4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.tolerance,this.tolerance),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements))}clone(){var n=new C;return n.tolerance=this.tolerance,n.realProjectionMatrixInverse=this.realProjectionMatrixInverse,n}}return new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0");let i=`\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${r.POSTPRO?$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${$({uniformName:"tCommonColor",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"tDepthOld",uniformType:"t2",locationName:"tInput2"})}\n            ${$({uniformName:"tDepthNew",uniformType:"t2",locationName:"tInput3"})}\n            ${$({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${$({uniformName:"tolerance",uniformType:"f"})}\n\n            ${h("getLinearDepth","f",[d("iUV"),p("iDepth")])}{\n                ${S("xy")} = iUV * 2.0 - 1.0;\n\n                ${x("posProjected")} = ${x()}(xy, 2.0 * iDepth - 1.0, 1.0);\n                ${x("posVS")}  = ${c("realProjectionMatrixInverse")} * posProjected;\n                return posVS.z / posVS.w;\n            }\n\n            ${m.getMainFragmentStart()}\n                ${S("screenUV")} = ${_("vUv")};\n\n                ${x("_common")} = ${D("tCommonColor","screenUV")};\n                ${v("depthOld")} = ${g("unpackRGBA","f",[f(D("tDepthOld","screenUV"))])};\n                ${v("depthNew")} = ${g("unpackRGBA","f",[f(D("tDepthNew","screenUV"))])};\n\n                ${1===r.MODE?`\n                    ${v("isDifferent")} = step(depthOld*depthNew, 0.0) - step(abs(depthOld) + abs(depthNew), 0.0);\n                    `:`\n                    ${v("diff")}  = abs(${g("getLinearDepth","f",[d("screenUV"),p("depthOld")])} - ${g("getLinearDepth","f",[d("screenUV"),p("depthNew")])});\n                    ${v("isDifferent")} = step(tolerance, diff);\n                    `}\n\n                ;\n                ${r.POSTPRO?`\n                    ${x("color")} = ${D("tScene","screenUV")};\n                    color = mix(vec4(mix(color.rgb, _common.rgb, _common.a), color.a), color, isDifferent);\n                    `:`\n                    ${x("color")}  = vec4(_common.rgb, _common.a * (1.0 - isDifferent));\n                    `}\n\n                ${a} = color;           \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:function(e){return`           \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart()}\n                ${T("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd()}\n        `}(t),fragmentShader:i}},"CompareModel"),C,{POSTPRO:1,MODE:0})}),define("DS/ShaderBuilders/PostPro/ESMBlurShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterV3(n),h=(n,e,t)=>m.declareFunction(n,e,t),g=(n,e,t)=>m.callFunction(n,e,t),v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},y=n=>o.addVarying(n),_=n=>o.getVarying(n,o.ShaderStages.in),T=n=>o.getVarying(n,o.ShaderStages.out),D=(n,e)=>m.sample2DTexture(n,e);class C extends e{constructor(){super(),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){var n=new C;return n.invSize=this.invSize,n}}const P={LEVEL:1};function N(e){return`\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n            \n\n            void main() {\n\n                ${T("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n        `}function M(n){const e=n=>g("unpackDepth","f",[d(n)]);return`\n        \n            ${$({uniformName:"invSize",uniformType:"v2"})}\n            ${$({uniformName:"tShadowMap",uniformType:"t2",locationName:"tInput"})}\n            \n            ${y({varyingName:"vUv",varyingType:"v2"})}\n\n            ${h("unpackDepth","f",[d("uv")])}{\n                ${x("rgba_depth")}  = ${D("tShadowMap","uv")};\n                ${n.uintESM?`\n                    return ${g("unpackRGB","f",[f("rgba_depth.xyz * pow(10.0,rgba_depth.w*255.0)")])};\n                    `:"\n                    return rgba_depth.x;\n                    "}\n            }\n\n            ${h("unpackLerp","f",[d("coord")])} {\n                ${n.uintESM?`                \n                    ${S("invScreenSize")} = ${c("invSize")} ;  \n                    ${S("fractCoord")}  = fract(coord/invScreenSize + 0.5);\n                    ${S("centroidUV")}  = (coord/invScreenSize - fractCoord) * invScreenSize;\n\n                    ${v("lb")} = ${e("centroidUV")};\n                    ${v("lt")} = ${e(`centroidUV + ${S()}(0.0, invSize.y)`)};\n                    ${v("rb")} = ${e(`centroidUV + ${S()}(invSize.x, 0.0)`)};\n                    ${v("rt")} = ${e("centroidUV + invSize")};\n                    ${v("a")} = mix(lb, lt, fractCoord.y);\n                    ${v("b")} = mix(rb, rt, fractCoord.y);\n                    return mix(a, b, fractCoord.x);\n                    `:`\n                    return ${e("coord")};\n                    `}\n            }\n\n            ${h("packDepth","v4",[p("depth")])} {\n                ${n.uintESM?`\n                    //orders above 1\n                    ${v("exposant")} = ceil(log(depth)/log(10.0));\n                    //[0-1]\n                    ${v("normDepth")} = depth/pow(10.0,exposant);\n                    return ${x()}(${g("packRGB","v3",[f("normDepth")])}, exposant / 255.0);\n                    `:`\n                    return ${x()}(depth,0.0,0.0,1.0);\n                    `}\n            }\n        \n        `}function b(n){let e=[],t=[],r=l;switch(n){case 1:default:e.push(-1.2),t.push(.3125),e.push(0),t.push(.375),e.push(1.2),t.push(.3125);break;case 2:e.push(-1.285714285714),t.push(.328125),e.push(0),t.push(.3125),e.push(1.285714285714),t.push(.328125);break;case 3:e.push(-3.111111111111),t.push(.03515625),e.push(-1.333333333333),t.push(.328125),e.push(0),t.push(.2734375),e.push(1.333333333333),t.push(.328125),e.push(3.111111111111),t.push(.03515625);break;case 4:e.push(-3.181818181818),t.push(.0537109375),e.push(-1.363636363636),t.push(.322265625),e.push(0),t.push(.24609375),e.push(1.363636363636),t.push(.322265625),e.push(3.181818181818),t.push(.0537109375);break;case 5:e.push(-5.076923076923),t.push(.003173828125),e.push(-3.230769230769),t.push(.06982421875),e.push(-1.384615384615),t.push(.314208984375),e.push(0),t.push(.2255859375),e.push(1.384615384615),t.push(.314208984375),e.push(3.230769230769),t.push(.06982421875),e.push(5.076923076923),t.push(.003173828125)}for(let n=0;n<e.length;n++){let a=0!==e[n]?e[n]:"0.0";r=`\n                ${r}\n                res += ${g("unpackLerp","f",[d(`screenPos + ${a} * blurSize`)])} * ${t[n]};\n            `}return r}return{BlurH:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n\n            ${M(e)}\n\n            void main() {\n\n                ${S("screenPos")} = ${_("vUv")};\n                ${v("res")} = 0.0;\n                ${S("blurSize")} = ${S()}(${c("invSize")}.x, 0.0);\n\n                ${b(t.LEVEL)}\n                \n                ${r} = ${g("packDepth","v4",[p("res")])};\n            }\n        `;return{vertexShader:N(e),fragmentShader:a}},"ESM_Blur_H"),C,P),BlurV:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n\n            ${M(e)}\n\n            void main() {\n\n                ${S("screenPos")} = ${_("vUv")};\n                ${v("res")} = 0.0;\n                ${S("blurSize")} = ${S()}(0.0, ${c("invSize")}.y);   \n\n                ${b(t.LEVEL)}\n                \n                ${r} = ${g("packDepth","v4",[p("res")])};\n            }\n        `;return{vertexShader:N(e),fragmentShader:a}},"ESM_Blur_V"),C,P)}}),define("DS/ShaderBuilders/PostPro/MergeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterV3(n),h=n=>u.parameterT2(n),g=(n,e,t)=>m.declareFunction(n,e,t),v=(n,e,t)=>m.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},T=n=>o.addVarying(n),D=n=>o.getVarying(n,o.ShaderStages.in),C=n=>o.getVarying(n,o.ShaderStages.out),P=(n,e)=>m.sample2DTexture(n,e);class N extends e{constructor(e=0){super(e,!0);for(var t=0;t<this.inputs.length;t++)this["offset"+t]=new n.Vector2,this["scale"+t]=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i);for(var s=0;s<this.inputs.length;s++)t.uniform2f(r["offset"+s],this["offset"+s].x,this["offset"+s].y),t.uniform2f(r["scale"+s],this["scale"+s].x,this["scale"+s].y)}clone(){return new N}}function M(e,t,r,a){return function(i,s){s.customDefines;let l="",u="",m="";for(let n=0;n<e.length;n++){const t=e[n];l=`\n                    ${l}\n                    ${$({uniformName:"tInput"+n,uniformType:"t2"})}\n                    ${$({uniformName:"offset"+n,uniformType:"v2"})}\n                    ${$({uniformName:"scale"+n,uniformType:"v2"})}\n                `;const r="inputUV"+n;u=`\n                    ${u}\n                    ${x(r)} = (screenUV - ${c("offset"+n)}) / ${c("scale"+n)};\n                `,m=`\n                    ${m} if (${r}.x > 0.0 && ${r}.y > 0.0 && ${r}.x < 1.0 && ${r}.y < 1.0) {\n                        color = ${t("tInput"+n,r,s)};\n                    } else\n                `,n===e.length-1&&(m=`\n                        ${m}{\n                            color = ${_()}(0.0);\n                        }\n                    `)}const p=o.getShaderOutput("out0");let d=`\n                \n                ${T({varyingName:"vUv",varyingType:"v2"})}\n                \n                ${l}\n\n                ${r(i,s)}\n    \n                void main() {\n                    ${x("screenUV")} = ${D("vUv")};\n                    ${_("color")};\n                    ${a(i,s)}\n\n                    ${u}\n                    ${m}\n\n                    ${p} = ${t("color",s)};\n                }\n            `;return{vertexShader:function(e){return`\n        ${T({varyingName:"vUv",varyingType:"v2"})}\n\n        void main() {\n            ${C("vUv")} = uv.xy;\n            ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n        }\n\n    `}(s),fragmentShader:d}}}return{ShadowMerge4:new r(new t(function(){function n(n,e){const t=P(n,e),r=`${y()}(${t}.w)`;return`${_()}(${r}, 0.7)`}return M([n,n,n,n],n=>n,()=>l,()=>l)}(),"ShadowMerge4"),N,{},3),DisplayMerge4:new r(new t(function(){function n(n,e){const t=P(n,e),r=`${y()}(${t}.xyz)`;return`${_()}(${r}, 1.0)`}return M([n,n,function(n,e){const t=P(n,e),r=`${y()}(${t}.w)`;return`${_()}(${r}, 1.0)`},n],n=>n,()=>l,()=>l)}(),"DisplayMerge4"),N,{},3),IrradianceMerge1:new r(new t(M([function(n,e){const t=P(n,e),r=`${y()}(${t}.xyz)`;return`${_()}(${(n=>`pow(${n}, ${y()}(1.0 / 2.2))`)(r)}, 1.0)`}],n=>n,()=>l,()=>l),"IrradianceMerge1"),N,{},0),RoughnessMipsMerge:new r(new t(function(){function n(n,e){const t=`${x()}(1.0 - ${e}.x, ${e}.y)`,r=P(n,t);return`${_()}(${r}.xyz, 1.0)`}return M([n,n,n,n,n,n,n],function(n,e){return 0===e.customDefines.OUTPUT_TO_RGBE?`${_()}(${n}.xyz, 1.0)`:`\n                ${v("toRGBE","v4",[f(`${n}.xyz`)])}\n            `},function(n,e){return 0===e.customDefines.OUTPUT_TO_RGBE?l:`\n                ${g("toRGBE","v4",[f("color")])} {\n                    ${S("value")} = max(color.r, max(color.g, color.b));\n                    if (value < 1e-6) return ${_()}(0.0, 0.0, 0.0, 1.0);\n                    // in [-128..127]\n                    ${S("exponent")}  = clamp(ceil(log2(value)), -128.0, 127.0);\n\n                    return ${_()}(color * pow(2.0, -exponent), (exponent + 128.0) / 255.0);\n                }\n            `},()=>l)}(),"RoughnessMipsMerge"),N,{OUTPUT_TO_RGBE:1},6),RoughnessCustomMipsMerge:new r(new t(function(){function e(n){return function(e,t){return`${v("getColor","v4",[p(`${n}`),d(t)])}`}}const t=(n,e,t)=>v("texture2DBilinearFromRGBE","v4",[h(n),d(e),d(t),d(`1.0 / ${t}`)]);let r=[()=>`${_()}(0.0)`,e(.04911045206),e(.08973030532),e(.1639473341),e(.29955017162),e(.54731176821),e(.99999999999),function(n,e){const r=`${x()}(1.0 - ${e}.x, ${e}.y)`,a=c("size7"),o=t(n,r,a);return`${_()}(${o}.xyz, 1.0)`}];return M(r,function(n,e){return`\n                ${v("toRGBE","v4",[f(`${n}.xyz`)])}\n            `},function(e,a){var o=a.customDefines;let i="";for(let n=0;n<r.length;n++)i=`\n                    ${i}\n                    ${$({uniformName:"size"+n,uniformType:"v2"})}\n                `;const s=o.MAPPING,u=0===s,m=1===s,h=2===s,y=3===s,T=`${S()}(${o.MIP_OFFSET})`,D=0!==o.ZERO_RBGE;return`\n\n                ${i}\n\n                ${n._DefaultShaderChunk.rgbe_sample_methods(a)}\n\n                ${g("roughnessToMips","f",[p("roughness")])}{\n                    float mip;\n                    ${u?`mip = roughness * (6.0 - ${T});`:l}           \n                    ${m?`\n                        if (roughness == 0) {\n                            mip = 0.0;\n                        } else {\n                            mip =  (6.0 - ${T} ) + 1.15 * log2(roughness);\n                        }\n                        `:l}\n                    \n                    ${h?`mip = (1.0 - roughness) * (6.0 - ${T});`:l}\n                    ${y?`\n                        if (roughness == 1) {\n                            mip = 6.0 - ${T};\n                        } else {\n                            mip = (6.0 - ${T} ) + 1.15 * log2(1.0 - roughness);\n                        }`:l}\n                    return mip + ${T};\n                } \n\n                ${g("toRGBE","v4",[f("color")])} {\n                    ${S("value")} = max(color.r, max(color.g, color.b));\n                    if (value < 1e-6) return ${_()}(0.0, 0.0, 0.0, 1.0);\n                    // in [-128..127]\n                    ${S("exponent")}  = clamp(ceil(log2(value)), -128.0, 127.0);\n\n                    return ${_()}(color * pow(2.0, -exponent), (exponent + 128.0) / 255.0);\n                }\n\n                ${g("getColor","v4",[p("roughness"),d("iUv")])} {\n                    float mipValue = ${v("roughnessToMips","f",[p("roughness")])};\n                    float leftMip = floor(mipValue);\n                    float factor = fract(mipValue);\n                    ${x("uv")} = iUv;\n                    uv.x = 1.0 - uv.x;\n                    vec4 color;\n                    if (leftMip == 0.0) {\n                        ${D?`\n                            color = mix(${t("tInput0","uv",c("size0"))}, ${t("tInput1","uv",c("size1"))}, factor);\n                            `:`\n                            color = mix(${P("tInput0","uv")}, ${t("tInput1","uv",c("size1"))}, factor); \n                            `}\n                    }\n                    if (leftMip == 1.0) {\n                        color = mix(${t("tInput1","uv",c("size1"))}, ${t("tInput2","uv",c("size2"))}, factor);\n                    }\n                    if (leftMip == 2.0) {\n                        color = mix(${t("tInput2","uv",c("size2"))}, ${t("tInput3","uv",c("size3"))}, factor);\n                    }\n                    if (leftMip == 3.0) {\n                        color = mix(${t("tInput3","uv",c("size3"))}, ${t("tInput4","uv",c("size4"))}, factor);\n                    }\n                    if (leftMip == 4.0) {\n                        color = mix(${t("tInput4","uv",c("size4"))}, ${t("tInput5","uv",c("size5"))}, factor);\n                    }\n                    if (leftMip == 5.0) {\n                        color = mix(${t("tInput5","uv",c("size5"))}, ${t("tInput6","uv",c("size6"))}, factor);\n                    }            \n                    if (leftMip == 6.0) {\n                        color = ${t("tInput6","uv",c("size6"))};\n                    }\n                    return ${_()}(color.xyz, 1.0);\n                }\n            `},function(n,e){return"screenUV.x = 1.0 - screenUV.x;"})}(),"RoughnessCustomMipsMerge"),class extends N{constructor(e=0){super(e);for(var t=0;t<this.inputs.length;t++)this["size"+t]=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i);for(var s=0;s<this.inputs.length;s++)t.uniform2f(r["size"+s],this["size"+s].x,this["size"+s].y)}clone(){return new N}},{MAPPING:0,MIP_OFFSET:0,ZERO_RBGE:1},7)}}),define("DS/ShaderBuilders/PostPro/FXAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterV2(n),p=(n,e,t)=>u.declareFunction(n,e,t),d=(n,e,t)=>u.callFunction(n,e,t),f=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},h=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},v=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.out),D=(n,e)=>u.sample2DTexture(n,e);function C(n){return`\n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n            ${m({uniformName:"resolution",uniformType:"v2"})}\n\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${h("FXAA_REDUCE_MIN")} =   (1.0/128.0);\n            ${h("FXAA_REDUCE_MUL")}  =   (1.0/8.0);\n            ${h("FXAA_SPAN_MAX")}  =     8.0;\n\n            ${x("luma")} = ${S()}(0.299, 0.587, 0.114);\n\n            ${v("positiveY")} = ${g()}(0.0, 1.0);\n            ${v("positiveX")} = ${g()}(1.0, 0.0);\n            ${v("negativeY")} = ${g()}(0.0, -1.0);\n            ${v("negativeX")} = ${g()}(-1.0, 0.0);\n\n            ${v("winMax")} = ${g()}(FXAA_SPAN_MAX,  FXAA_SPAN_MAX);\n            ${v("winMin")} = ${g()}(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX);\n        `}function P(n){return`\n        ${g("screenRes")} = ${$("resolution")};\n        ${g("screenUV")} = gl_FragCoord.xy * screenRes;\n        ${S("rgbNW")}  = ${D("tScene","screenUV + (negativeX + negativeY) * screenRes")}.xyz;\n        ${S("rgbNE")}   = ${D("tScene","screenUV + (positiveX + negativeY) * screenRes")}.xyz;\n        ${S("rgbSW")}   = ${D("tScene","screenUV + (negativeX + positiveY) * screenRes")}.xyz;\n        ${S("rgbSE")}   = ${D("tScene","screenUV + (positiveX + positiveY) * screenRes")}.xyz;\n        ${y("rgbaM")}    = ${D("tScene","screenUV")};\n        ${S("rgbM")}    = rgbaM.xyz;\n        ${f("opacity")}    = rgbaM.w;\n\n        ${f("lumaNW")}  = dot( rgbNW, luma );\n        ${f("lumaNE")}   = dot( rgbNE, luma );\n        ${f("lumaSW")}   = dot( rgbSW, luma );\n        ${f("lumaSE")}   = dot( rgbSE, luma );\n        ${f("lumaM")}    = dot( rgbM,  luma );\n        ${f("lumaMin")}   = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n        ${f("lumaMax")}   = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\n\n        ${g("dir")} ;\n        dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n        dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n        ${f("dirReduce")}   = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\n\n        ${f("rcpDirMin")}   = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n        dir = min( winMax, max( winMin, dir * rcpDirMin)) * resolution;\n        `}function N(e){return`\n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${T("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n\n            }\n        `}class M extends e{constructor(){super(),this.resolution=new n.Vector2(1/1024,1/512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.resolution,this.resolution.x,this.resolution.y)}clone(){var n=new M;return n.resolution=this.resolution,n}}return{FXAAShader:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            ${C()}\n\n            void main() {\n\n                ${P()}\n\n                ${S("rgbA")}  = 0.5 * (\n                    ${D("tScene","screenUV + dir * ( 1.0 / 3.0 - 0.5 )")}.xyz \n                    +\n                    ${D("tScene","screenUV + dir * ( 2.0 / 3.0 - 0.5 )")}.xyz \n                );\n\n                ${S("rgbB")}  = rgbA * 0.5 + 0.25 * (\n                    ${D("tScene","screenUV + dir * -0.5 ")}.xyz \n                    +\n                    ${D("tScene","screenUV + dir * 0.5")}.xyz\n                );\n\n                ${f("lumaB")}  = dot( rgbB, luma );\n\n                if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\n\n                    ${t} = ${y()}( rgbA, opacity );\n\n                } else {\n\n                    ${t} = ${y()}( rgbB, opacity );\n\n                }\n            }\n        `;return{vertexShader:N(e),fragmentShader:r}},"FXAA"),M,{}),OITFXAAShader:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0"),r=(n,e)=>d("sampleColor","v4",[c(n),prmV4(e)]);let a=`\n            ${C()}\n\n            ${p("sampleColor","v4",[c("uv"),prmV4("color")])} {\n                ${y("res")} = ${D("tScene","uv")};\n                if (res.a < 1e-6) {\n                    return ${y()}(color.rgb, 0.2 * color.a);\n                }\n                return res;\n            }\n\n            void main() {\n\n                ${P()}\n\n                ${y("rgbA")}  = 1.0 / 3.0 * ( rgbaM + \n                        ${r("screenUV + dir * ( 1.0 / 3.0 - 0.5 )","rgbaM")}\n                        +\n                        ${r("screenUV + dir * ( 2.0 / 3.0 - 0.5 )","rgbaM")}\n                );\n\n                ${y("rgbB")}  = rgbA * 0.6 + 0.2 * (\n                        ${r("screenUV + dir * -0.5","rgbaM")} \n                        +\n                        ${r("screenUV + dir * 0.5","rgbaM")} \n                );\n\n                ${f("lumaB")}  = dot( rgbB.rgb, luma );\n\n                if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\n\n                    ${t} = rgbA;\n\n                } else {\n\n                    ${t} = rgbB;\n\n                }\n            }\n        `;return{vertexShader:N(e),fragmentShader:a}},"FXAAOIT"),M,{})}}),define("DS/ShaderBuilders/PostPro/GraphicsOptimizerShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterV2(n),p=n=>l.parameterV3(n),d=n=>l.parameterV4(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},D=n=>o.addVarying(n),C=n=>o.getVarying(n,o.ShaderStages.in),P=n=>o.getVarying(n,o.ShaderStages.out),N=(n,e)=>u.sample2DTexture(n,e);class M extends e{constructor(e=0){super(e),this.empty=0,this.texelSize=new n.Vector2}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.empty,this.empty),t.uniform2f(r.texelSize,this.texelSize.x,this.texelSize.y)}clone(){var n=new M;return n.empty=this.empty,n}}function b(e){return`           \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${P("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}return{Pixels:[new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"empty",uniformType:"f"})}\n\n            ${f("mod289","v4",[d("x")])}{\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("mod289","v3",[p("x")])}{\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("mod289","v2",[c("x")])} {\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n              }\n  \n              ${f("permute","v3",[p("x")])}{\n                  ${y("value")}  = ((x*34.0)+1.0)*x;\n                  return ${h("mod289","v3",[p("value")])};\n              }\n  \n              ${f("permute","v4",[d("x")])}{\n                  ${_("value")}  = ((x*34.0)+1.0)*x;\n                  return ${h("mod289","v4",[d("value")])};\n              }\n  \n              ${f("taylorInvSqrt","v4",[d("r")])}{\n                  return 1.79284291400159 - 0.85373472095314 * r;\n              }\n  \n              ${f("snoise","f",[p("v")])}{\n  \n                  ${x("C")} = ${S()}(1.0/6.0, 1.0/3.0);\n                  ${T("D")} = ${_()}(0.0, 0.5, 1.0, 2.0);\n  \n                  ${y("i")}   = floor(v + dot(v, C.yyy) );\n                  ${y("x0")}  =   v - i + dot(i, C.xxx) ;\n  \n                  ${y("g")}  = step(x0.yzx, x0.xyz);\n                  ${y("l")}  = 1.0 - g;\n                  ${y("i1")}  = min( g.xyz, l.zxy );\n                  ${y("i2")}  = max( g.xyz, l.zxy );\n  \n                  ${y("x1")}  = x0 - i1 + C.xxx;\n                  // 2.0*C.x = 1/3 = C.y\n                  ${y("x2")}  = x0 - i2 + C.yyy; \n                  // -1.0+3.0*C.x = -0.5 = -D.y\n                  ${y("x3")}  = x0 - D.yyy;      \n  \n                  i = mod289(i);\n                  ${_("permutationAux")}  = i.z + ${_()}(0.0, i1.z, i2.z, 1.0 );\n                  permutationAux = ${h("permute","v4",[d("permutationAux")])} + i.y + ${_()}(0.0, i1.y, i2.y, 1.0 );\n                  permutationAux = ${h("permute","v4",[d("permutationAux")])} + i.x + ${_()}(0.0, i1.x, i2.x, 1.0 );\n                  ${_("permutation")}  = ${h("permute","v4",[d("permutationAux")])};\n  \n                  // 1.0/7.0\n                  ${v("n_")}  = 0.142857142857;\n                  ${y("ns")} = n_ * D.wyz - D.xzx;\n                  //  mod(permutation,7*7)\n                  ${_("j")} = permutation - 49.0 * floor(permutation * ns.z * ns.z);  \n  \n                  ${_("x_")}  = floor(j * ns.z);\n                  // mod(j,N)\n                  ${_("y_")}  = floor(j - 7.0 * x_ );    \n  \n                  ${_("x")}  = x_ *ns.x + ns.yyyy;\n                  ${_("y")}  = y_ *ns.x + ns.yyyy;\n                  ${_("h")}  = 1.0 - abs(x) - abs(y);\n  \n                  ${_("b0")}  = vec4( x.xy, y.xy );\n                  ${_("b1")}  = vec4( x.zw, y.zw );\n  \n                  ${_("s0")}  = floor(b0)*2.0 + 1.0;\n                  ${_("s1")}  = floor(b1)*2.0 + 1.0;\n                  ${_("sh")}  = -step(h, vec4(0.0));\n  \n                  ${_("a0")}  = b0.xzyw + s0.xzyw*sh.xxyy;\n                  ${_("a1")}  = b1.xzyw + s1.xzyw*sh.zzww;\n  \n                  ${y("p0")}  = ${y()}(a0.xy,h.x);\n                  ${y("p1")}  = ${y()}(a0.zw,h.y);\n                  ${y("p2")}  = ${y()}(a1.xy,h.z);\n                  ${y("p3")}  = ${y()}(a1.zw,h.w);\n  \n                  ${_("r")} = ${_()}(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3));\n                  ${_("norm")}  = ${h("taylorInvSqrt","v4",[d("r")])};\n                  p0 *= norm.x;\n                  p1 *= norm.y;\n                  p2 *= norm.z;\n                  p3 *= norm.w;\n  \n                  ${_("m")}  = max(0.6 - ${_()}(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                  m = m * m;\n                  return 42.0 * dot( m*m, ${_()}( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n              }\n  \n\n            ${u.getMainFragmentStart()}\n                ${S("screenUV")} = ${C("vUv")};\n\n                if (${$("empty")} == 1.0) {\n                    return;\n                }\n                ${y("pos")}  = gl_FragCoord.xyz;\n                ${y("seed")} = sin(pos);\n                ${v("a")} = 0.0;\n                for (${g("i")} = 0; i < ${t.LOOP_COUNT}; i++) {\n                    ${y("noiseIn")} = pos + ${v()}(i) * seed;\n                    a += ${h("snoise","f",[p("noiseIn")])};\n                }\n                ${r} = ${_()}(${y()}(a) / ${v()}(${t.LOOP_COUNT}), 1.0);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:a}},"PixelGO"),M,{LOOP_COUNT:128})],Textures:[new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            ${function(){for(var n=`\n            \n            ${m({uniformName:"empty",uniformType:"f"})}\n            ${m({uniformName:"texelSize",uniformType:"v2"})}\n            `,e=0;e<8;e++)n=`\n                    ${n}\n                    ${m({uniformName:"tInput"+e,uniformType:"t2"})}\n                `;return n}()}\n\n\n            ${u.getMainFragmentStart()}\n                ${S("screenUV")} = ${C("vUv")};\n                ${S("size")} = ${$("texelSize")};\n\n                if (${$("empty")} == 1.0) {\n                    return;\n                }\n                ${function(){for(var n="",e=0;e<8;e++)n=`\n                    ${n}\n                    for (${g("i")} = 0; i < ${t.FETCH_COUNT}; i++) {\n                        screenUV = ${N(`tInput${e}`,`screenUV + 1e-2 * ${v()}(i) / size`)}.rg;\n                    }\n                `;return n}()}\n                ${r} = ${_()}(screenUV.xy, 0.0, 1.0);\n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:a}},"TextureGO"),M,{FETCH_COUNT:128},7)]}}),define("DS/ShaderBuilders/PostPro/DOFShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterI(n),p=n=>l.parameterF(n),d=n=>l.parameterV2(n),f=(n,e,t)=>u.declareFunction(n,e,t),h=(n,e,t)=>u.callFunction(n,e,t),g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},v=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},D=n=>o.addVarying(n),C=n=>o.getVarying(n,o.ShaderStages.in),P=n=>o.getVarying(n,o.ShaderStages.out),N=(n,e)=>u.sample2DTexture(n,e);class M extends e{constructor(){super(1),this.textureWidth=512,this.textureHeight=512,this.focalDepth=1,this.focalLength=64,this.fstop=.9,this.sensorSize=24,this.sceneScale=1,this.maxCoC=1,this.realProjectionMatrixInverse=new n.Matrix4,this.maxblur=5,this.manualdof=0,this.bias=.5,this.noise=1,this.dithering=1e-4}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.textureWidth,this.textureWidth),t.uniform1f(r.textureHeight,this.textureHeight),t.uniform1f(r.focalDepth,this.focalDepth),t.uniform1f(r.focalLength,this.focalLength),t.uniform1f(r.fstop,this.fstop),t.uniform1f(r.sensorSize,this.sensorSize),t.uniform1f(r.sceneScale,this.sceneScale),t.uniform1f(r.maxCoC,this.maxCoC),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniform1f(r.maxblur,this.maxblur),t.uniform1i(r.manualdof,this.manualdof),t.uniform1f(r.bias,this.bias),t.uniform1i(r.noise,this.noise),t.uniform1f(r.dithering,this.dithering)}clone(){return new M}}return{Bokeh:new r(new t(function(e,t){var r=t.customDefines;const a=o.getShaderOutput("out0"),i=r.DOF_BEHAVIOUR,s=r.PHYSIC,l=n=>`th / ${$("sensorSize")} * ${n}`;let M=`\n            \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n            \n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${m({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n\n            ${m({uniformName:"textureWidth",uniformType:"f"})}\n            ${m({uniformName:"textureHeight",uniformType:"f"})}\n\n            //focal distance value in mm, but you may use autofocus option below\n            ${m({uniformName:"focalDepth",uniformType:"f"})}\n            //focal length in mm\n            ${m({uniformName:"focalLength",uniformType:"f"})}\n            //f-stop value\n            ${m({uniformName:"fstop",uniformType:"f"})}\n            //physical sensor size 24mm by default\n            ${m({uniformName:"sensorSize",uniformType:"f"})}\n            //1 for mm, 1000 for m\n            ${m({uniformName:"sceneScale",uniformType:"f"})}\n            //ratio of screenHeight a physical blur can have\n            ${m({uniformName:"maxCoC",uniformType:"f"})}\n            ${m({uniformName:"maxblur",uniformType:"f"})}\n            ${m({uniformName:"dithering",uniformType:"f"})}\n            // bokeh edge bias\n            ${m({uniformName:"bias",uniformType:"f"})}\n\n            ${m({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n\n            // manual dof calculation\n            ${m({uniformName:"manualdof",uniformType:"b"})}\n            //use noise instead of pattern for sample dithering\n            ${m({uniformName:"noise",uniformType:"b"})}\n\n            ${x("PI")} = 3.14159265;\n\n            //samples on the first ring\n            ${v("samples")}  = ${r.SAMPLES};\n            //ring count\n            ${v("rings")}  = ${r.RINGS};\n            ${x("rings2")}  = ${S()}(rings);\n\n            ${v("maxringsamples")}  = rings * samples;\n\n            // near dof blur start\n            ${x("ndofstart")}  = 1.0;\n            // near dof blur falloff distance\n            ${x("ndofdist")}  = 2.0;\n            // far dof blur start\n            ${x("fdofstart")}  = 1.0;\n            // far dof blur falloff distance\n            ${x("fdofdist")}  = 3.0;\n            //circle of confusion size in mm (35mm film = 0.03mm)\n            ${x("CoC")}  = 0.03;\n            \n            ${S("maxPhysicalBlurSize")}; \n\n            ${f("getZ","f",[d("coords")])} {\n                ${T("normalDepth")}  = ${N("tNormalDepth","coords")};\n                \n                // [0.0, 1.0]\n                ${t.renderToFloatTexture?`\n                    ${S("z")} = normalDepth.w; \n                    `:`\n                    ${S("z")}  = ${h("unpackForFloat16","f",[d("normalDepth.zw")])};\n                    `}\n                ${3===t.dofBehavior?"       \n                    //background at distance 0\n                    if ( z == 0.0 ) {\n                        return 0.0;\n                    }\n                    ":"                   \n                    //background at far\n                    if ( z == 0.0 ) {\n                        z=1.0;\n                    }\n                    "}\n                return z;\n            }\n            \n            ${f("getDepth","f",[d("coords"),p("z")])}{\n\n                ${y("xy")}  = coords * 2.0 - 1.0;\n\n                ${T("vertexPositionProjected")}  = ${T()}( xy, 2.0 * z - 1.0, 1.0 );\n                ${T("vertexPositionVS")}  = ${$("realProjectionMatrixInverse")} * vertexPositionProjected;\n                vertexPositionVS /= vertexPositionVS.w;\n                vertexPositionVS.w = 1.0;\n\n                return -vertexPositionVS.z*${$("sceneScale")};\n            }\n\n            //paraxial thin lens approxiamtion\n            ${f("getHalfPhysicalBlurSize","f",[p("depth")])}{\n                ${S("fDepth")} = ${$("focalDepth")};\n                ${S("fLength")} = ${$("focalLength")};\n                if(depth>=fDepth){\n                    //case A :beyond focalDepth formula \n                    ${S("maxBlur")}  = maxPhysicalBlurSize;\n                    //depth > focalDepth in case A\n                    ${S("distToFocus")}  = abs(depth-fDepth);\n                    ${S("focusRatio")}  = distToFocus/depth;\n                    return 0.5 * maxBlur*focusRatio;\n                }else if(depth>=fLength){\n                    //case B :in front of focalDepth formula\n                    ${S("currFocal")}  = depth*fLength/(depth-fLength);\n                    ${S("focusFocal")}  = fDepth*fLength/(fDepth-fLength);\n                    //currFocal > focusFocal in case B\n                    ${S("distToFocus")}  = abs(currFocal-focusFocal);\n                    ${S("focusRatio")}  = distToFocus/currFocal;\n                    return 0.5*fLength/${$("fstop")} * focusRatio;\n                \n                }else {\n                    //case C :closer than focalLength\n                    //virtual image, don't know how to deal with that yet, return max blur instead\n                    //aperture size\n                    return 0.5*fLength/${$("fstop")};\n                }\n            }\n\n            ${f("getOffsetedUV","v2",[d("uv"),p("length"),p("j"),p("w"),p("h"),p("steps")])}{\n                ${S("tw")} = ${$("textureWidth")};\n                ${S("th")} = ${$("textureHeight")};\n                ${S("pw")}  = cos(j*steps)*length;\n                ${S("ph")} = sin(j*steps)*length;\n                ${y("res_uv")}  =uv + ${y()}(pw*w, ph*h);\n                res_uv.x = floor(0.5+res_uv.x*tw)/tw;\n                res_uv.y = floor(0.5+res_uv.y*th)/th;\n                return res_uv;\n            }\n\n            ${f("gather","v4",[p("i"),p("j"),d("uv"),c("ringsamples"),p("w"),p("h")])}{\n                ${S("step")}  = PI*2.0 / ${S()}(ringsamples);\n                ${S("pw")}  = cos(j*step)*i;\n                ${S("ph")}  = sin(j*step)*i;\n                ${S("weight")}  = mix(1.0, i/rings2, ${$("bias")});\n                ${y("uvToUse")}  = uv+ ${y()}(pw*w, ph*h);\n                ${_("col")} = ${N("tScene","uvToUse")}.rgb* weight;\n                return ${T()}(col, weight);\n            }\n\n            \n            ${f("rand","v2",[d("coord")])}{\n\n                ${S("tw")} = 0.5*${$("textureWidth")};\n                ${S("th")} = 0.5*${$("textureHeight")};\n\n                ${S("noiseX")}  = (fract(1.0 - coord.s * tw) * 0.25 + fract(coord.t * th) * 0.75) * 2.0 - 1.0;\n                ${S("noiseY")}  = (fract(1.0 - coord.s * tw) * 0.75 + fract(coord.t * th) * 0.25) * 2.0 - 1.0;\n\n                if (${$("noise")}) {\n                    noiseX = clamp(fract(sin(dot(coord ,${y()}(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n                    noiseY = clamp(fract(sin(dot(coord ,${y()}(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n                }\n\n                return ${y()}(noiseX, noiseY);\n            }\n\n            ${u.getMainFragmentStart()}\n                ${y("screenUV")} = ${C("vUv")};\n\n                ${S("pixelZ")} = ${h("getZ","f",[d("screenUV")])};\n                ${S("depth")} = ${h("getDepth","f",[d("screenUV"),p("pixelZ")])};\n                ${S("fDepth")} = ${$("focalDepth")};\n                ${S("fLength")} = ${$("focalLength")};\n\n                ${T("colAlpha")} = ${N("tScene","screenUV")};\n                ${_("col")} = colAlpha.rgb;\n\n                ${S("tw")} = ${$("textureWidth")};\n                ${S("th")} = ${$("textureHeight")};\n\n                ${S("s")} = 1.0;\n                ${g("ringsamples")};\n                ${y("randNoise")}  = ${h("rand","v2",[d("screenUV")])} * ${$("dithering")};\n                ${3===i?`          \n                    ${S("blur")}  = 0.0;\n\n                    if (${$("manualdof")}) {\n                        ${S("a")} = depth - fDepth;\n                        ${S("b")} = (a - fdofstart) / fdofdist;\n                        ${S("c")} = (- a - ndofstart) / ndofdist;\n                        if (a > 0.0) {\n                            blur = b;\n                        } else {\n                            blur = c;\n                        }\n                    } else {\n                        ${S("f")} = fLength;\n                        ${S("d")} = fDepth;\n                        ${S("o")} = depth;\n\n                        ${S("a")} = (o * f) / (o - f);\n                        ${S("b")} = (d * f) / (d - f);\n                        ${S("c")} = (d - f) / (d * ${$("fstop")} * ${$("CoC")});\n\n                        blur = abs(a - b) * c;\n                    }\n\n                    blur = clamp(blur, 0.0, 1.0);\n\n                    randNoise *= blur;\n\n                    ${S("w")}  = (1.0 / tw) * blur * ${$("maxblur")} + randNoise.x;\n                    ${S("h")}  = (1.0 / th) * blur * ${$("maxblur")} + randNoise.y;\n\n                    for (${g("i")} = 1; i <= rings; i++) {\n                        ringsamples = i * samples;\n                        ${S("fI")} = ${S()}(i);\n\n                        for (${g("j")} = 0 ; j < maxringsamples ; j++) {\n                            if (j >= ringsamples) break;\n                            ${S("fJ")} = ${S()}(j);\n                            ${T("colWeight")}= ${h("gather","f",[p("fI"),p("fJ"),d("screenUV"),c("ringsamples"),p("w"),p("h")])};\n                            col += colWeight.rgb;\n                            s += colWeight.w;\n                        }\n                    }\n                    `:`\n                    maxPhysicalBlurSize = fLength / ${$("fstop")} * clamp(fLength/(fDepth-fLength),0.0,1.0);\n\n                    ${S("sensorBlurRadius")}  = ${h("getHalfPhysicalBlurSize","f",[p("depth")])};\n                    ${S("radiusLower")} = ${$("maxCoC")}*th;\n                    ${S("blurRadius")}  = min(${l("sensorBlurRadius")},radiusLower);\n                    ${S("hBlur")}  = blurRadius/tw+randNoise.x;\n                    ${S("vBlur")}  = blurRadius/th+randNoise.y;\n                    ${S("maxSensorBlurRadius")}  = maxPhysicalBlurSize * 0.5;\n                    ${S("maxBlurRadius")}  =  min(${l("maxSensorBlurRadius")},radiusLower);\n                    ${S("maxHBlur")}  = maxBlurRadius/tw+randNoise.x;\n                    ${S("maxVBlur")}  = maxBlurRadius/th+randNoise.y;\n                    for (${g("i")} = 1; i <= rings; i++) {\n                        ringsamples = i * samples;\n                        ${S("fI")} = ${S()}(i);\n                        ${S("iRatio")}  = fI/rings2;\n\n                        ${S("dist")}  =iRatio*maxBlurRadius;\n\n                        for (${g("j")} = 0; j < maxringsamples ; j++) {\n                            if (j >= ringsamples) break;\n                            ${S("fJ")} = ${S()}(j);\n                            ${S("weight")}  = mix(1.0, iRatio, ${$("bias")});\n                            \n                            ${S("step")}  = PI*2.0 / ${S()}(ringsamples);\n                            //part1:fetch according to current pixel coc, gross approximation, but give nice blurry blur\n                            ${1===s?`            \n                                ${y("uv")} = ${h("getOffsetedUV","v2",[d("screenUV"),p("iRatio"),p("fJ"),p("hBlur"),p("vBlur"),p("step")])};\n                                ${S("sampleZ")} =${h("getZ","f",[d("uv")])};\n                                ${S("takeSample")} ;\n                                if (sampleZ>=pixelZ) {\n                                    takeSample = 1.0;\n                                } else {\n                                    takeSample = 0.0;\n                                }\n\n                                col += takeSample*${N("tScene","uv")}.rgb * weight;\n                                s+= takeSample*weight;\n                                `:`\n                                //part2:fetch according to max coc, retrieve potential wider cocs affecting this pixel\n                                //lossy because of low number of fetch\n                                ${y("uvMax")}  = ${h("getOffsetedUV","v2",[d("screenUV"),p("iRatio"),p("fJ"),p("maxHBlur"),p("maxVBlur"),p("step")])};\n                                ${S("sampleZMax")} =${h("getZ","f",[d("uvMax")])};\n                                ${S("currentDepth")}  = ${h("getDepth","f",[d("uvMax"),p("sampleZMax")])};\n                                ${S("currentsensorBlurRadius")}  = ${h("getHalfPhysicalBlurSize","f",[p("currentDepth")])};\n                                ${S("currentblurRadius")}  = ${l("currentsensorBlurRadius")};\n                                if(currentblurRadius>=dist){\n                                    col += ${N("tScene","uvMax")}.rgb * weight;\n                                    s+= weight;\n                                }\n                                `}\n                        }\n                    }\n                    `}\n                    \n                col /= s;\n                ${a} = ${T()}(col, colAlpha.a);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:function(e){return`           \n            ${D({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${P("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}(t),fragmentShader:M}},"BokehDOF"),M,{PHYSIC:1,DOF_BEHAVIOUR:0,RINGS:3,SAMPLES:8})}}),define("DS/ShaderBuilders/PostPro/DownSamplingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";i.ParameterUtils;const l=i.FunctionHandler,u=n=>a.addUniform(n),m=n=>{var e={uniformName:n};return a.getUniform(e)},$=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},c=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},p=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},d=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},f=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},h=n=>o.addVarying(n),g=n=>o.getVarying(n,o.ShaderStages.in),v=n=>o.getVarying(n,o.ShaderStages.out),S=(n,e)=>l.sample2DTexture(n,e);class x extends e{constructor(){super(),this.invSize=new n.Vector2(512,512)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){var n=new x;return n.invSize=this.invSize,n}}function y(e){return`\n            ${h({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${v("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            }\n\n        `}class _ extends e{constructor(n){super(n)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new _}}var T=new Map;return{DownSamplingBlur:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n          \n            ${u({uniformName:"tInput",uniformType:"t2"})}\n            ${u({uniformName:"invSize",uniformType:"v2"})}\n\n            void main() {\n                // varying storage\n                ${p("screenUV")} = ${g("vUv")};\n                ${p("factor")} = ${m("invSize")};\n\n                ${d("result")} = ${d()}(0.0, 0.0, 0.0);\n                ${c("total")} = 0.0;\n\n                for (${$("i")} = -2; i <= 2; i++) {\n                    for (${$("j")} = -2; j <= 2; j++) {\n                        ${p("offset")}  = 1.0 * factor * ${p()}(${c()}(i), ${c()}(j));\n                        ${c("weight")}  = 1.0 / (1.0 + dot(offset, offset));\n                        result += weight * ${S("tInput","screenUV + offset")}.xyz;\n                        total += weight;\n                    }\n                }\n                result /= total;\n                ${t} = ${f()}(result, 1.0);\n            }\n        `;return{vertexShader:y(e),fragmentShader:r}},"DownsamplingBlur"),x,{}),DownSamplingBlurWithAlpha:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${h({varyingName:"vUv",varyingType:"v2"})}\n          \n            ${u({uniformName:"tInput",uniformType:"t2"})}\n            ${u({uniformName:"invSize",uniformType:"v2"})}\n\n            void main() {\n                // varying storage\n                ${p("screenUV")} = ${g("vUv")};\n                ${p("factor")} = ${m("invSize")};\n\n                ${f("result")} = ${f()}(0.0, 0.0, 0.0, 0.0);\n                ${c("totalRGB")} = 0.0;\n                ${c("totalA")} = 0.0;\n\n                for (${$("i")} = -2; i <= 2; i++) {\n                    for (${$("j")} = -2; j <= 2; j++) {\n                        ${p("offset")}  = 1.0 * factor * ${p()}(${c()}(i), ${c()}(j));\n                        ${c("weightRGB")}  = 1.0 / (1.0 + dot(offset, offset));\n                        ${c("weightA")}  = 1.0;\n                        ${f("sampledValue")} = ${S("tInput","screenUV + offset")};\n                        result += ${f()}(weightRGB * sampledValue.rgb, weightA * sampledValue.a);\n                        totalRGB += weightRGB;\n                        totalA += weightA;\n                    }\n                }\n                result.r /= totalRGB;\n                result.g /= totalRGB;\n                result.b /= totalRGB;\n                result.a /= totalA;\n                ${t} = result;\n            }\n        `;return{vertexShader:y(e),fragmentShader:r}},"DownsamplingBlurWithAlpha"),x,{}),MergeMips:function(n){if(0===n)throw"Invalid Operation Exception: expected mips in MergeMipsShader, got 0";if(T.has(n))return T.get(n);var e=new r(new t(function(e,t){t.customDefines;const r=o.getShaderOutput("out0");let a=u({uniformName:"tMip0",uniformType:"t2",locationName:"tInput0"}),i=`\n                if (screenUV.y < 0.5) {\n                    ${p("factor")} = ${p()}(1.0, 2.0);\n                    ${r} = ${S("tMip0","factor * screenUV")};\n                    return;\n                }\n            `;for(let e=0;e<n;e++){const n=e+2,t="tMip"+(e+1);a=`\n                    ${a}\n                    ${u({uniformName:t,uniformType:"t2",locationName:"tInput"+(e+1)})}\n                `;const o=Math.pow(2,-n),s=1/o,l=2*o;i=`\n                    ${i}\n                    if (screenUV.y < ${1-o} && screenUV.x < ${l}) {\n                        ${p("uv")} = ${p()}(screenUV.x * ${c()}(${s/2}), (screenUV.y - ${1-l}) * ${c()}(${s}));\n                        ${r} = ${S(t,"uv")};\n                        return;\n                    }\n                `}let s=`\n                \n                ${h({varyingName:"vUv",varyingType:"v2"})}\n              \n                ${a}\n    \n                void main() {\n                    // varying storage\n                    ${p("screenUV")} = ${g("vUv")};\n                    ${r} = ${f()}(0.0, 0.0, 0.0, 1.0);\n                    \n                    ${i}\n                }\n            `;return{vertexShader:y(t),fragmentShader:s}},"MergeMips"+n),_,{},n);return T.set(n,e),e}}}),define("DS/ShaderBuilders/PostPro/VolumeRenderingShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u=i.ParameterUtils,m=i.FunctionHandler,$=n=>a.addUniform(n),c=n=>{var e={uniformName:n};return a.getUniform(e)},p=n=>u.parameterF(n),d=n=>u.parameterV2(n),f=n=>u.parameterV3(n),h=n=>u.parameterV4(n),g=(n,e,t)=>m.declareFunction(n,e,t),v=(n,e,t)=>m.callFunction(n,e,t),S=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},C=n=>o.addVarying(n),P=n=>o.getVarying(n,o.ShaderStages.in),N=n=>o.getVarying(n,o.ShaderStages.out),M=(n,e)=>m.sample2DTexture(n,e);class b extends e{constructor(){super(1)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new b}}class w extends e{constructor(){super(1),this.nbCol=0,this.map0=null,this.mapDim=new n.Vector3,this.minDisplayValue=0,this.maxDisplayValue=1,this.rangeDisplayValue=1,this.minTileValue=0,this.maxTileValue=1,this.rangeTileValue=1,this.isoValue=.1,this.uTMK=128,this.attenuationCoeff=.01,this.attenuationScale=1,this.colorMap=null,this.transferFctMap=null,this.gridSize=new n.Vector3,this.realProjectionMatrixInverse=new n.Matrix4,this.realModelViewMatrix=new n.Matrix4,this.realModelViewMatrixInverse=new n.Matrix4,this.clipPlaneEquation=new n.Vector4,this.debugChunkBox=new n.Vector4,this.renderIteration=0}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.nbCol,this.nbCol),e.loadTexture(t,r.map0,this.map0),t.uniform3f(r.mapDim,this.mapDim.x,this.mapDim.y,this.mapDim.z),t.uniform1f(r.minDisplayValue,this.minDisplayValue),t.uniform1f(r.maxDisplayValue,this.maxDisplayValue),t.uniform1f(r.rangeDisplayValue,this.rangeDisplayValue),t.uniform1f(r.minTileValue,this.minTileValue),t.uniform1f(r.maxTileValue,this.maxTileValue),t.uniform1f(r.rangeTileValue,this.rangeTileValue),t.uniform1f(r.isoValue,this.isoValue),t.uniform1f(r.uTMK,this.uTMK),t.uniform1f(r.attenuationCoeff,this.attenuationCoeff),t.uniform1f(r.attenuationScale,this.attenuationScale),e.loadTexture(t,r.colorMap,this.colorMap),e.loadTexture(t,r.transferFctMap,this.transferFctMap),t.uniform3f(r.gridSize,this.gridSize.x,this.gridSize.y,this.gridSize.z),t.uniformMatrix4fv(r.realProjectionMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realProjectionMatrixInverse.elements)),t.uniformMatrix4fv(r.realModelViewMatrix,!1,e.float32Matrix4x4Temp.setDoubles(this.realModelViewMatrix.elements)),t.uniformMatrix4fv(r.realModelViewMatrixInverse,!1,e.float32Matrix4x4Temp.setDoubles(this.realModelViewMatrixInverse.elements)),t.uniform4f(r.clipPlaneEquation,this.clipPlaneEquation.x,this.clipPlaneEquation.y,this.clipPlaneEquation.z,this.clipPlaneEquation.w),t.uniform4f(r.debugChunkBox,this.debugChunkBox.x,this.debugChunkBox.y,this.debugChunkBox.z,this.debugChunkBox.w),t.uniform1f(r.renderIteration,this.renderIteration)}clone(){return new w}}function U(e){return`           \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n            ${m.getMainVertexStart()}\n                ${N("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${m.getMainVertexEnd()}\n        `}return{Transfer:new r(new t(function(n,e){var t=e.customDefines;const r=o.getShaderOutput("out0");let a=`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            ${$({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tVolume",uniformType:"t2",locationName:"tInput1"})}\n\n\n            ${m.getMainFragmentStart()}\n                ${_("screenUV")} = ${P("vUv")};\n\n                ${T("finalColor")};\n                ${x("finalAlpha")};\n\n                ${D("mainMap")} = ${M("tScene","screenUV")};\n                ${D("volumeMap")} = ${M("tVolume","screenUV")};\n\n                // for classic volume rendering\n                ${T("volumeCol")}  = volumeMap.rgb;\n                ${x("alpha")}  = 1.0 - volumeMap.a;\n                ${D("volume")}  = ${D()}(volumeCol / (alpha + 0.0000001), alpha);\n\n                ${t.ISO_SURFACE>0?"\n                    finalAlpha = mix(mainMap.a, 1.0, volumeMap.a);\n                    finalColor = mix(mainMap.rgb * mainMap.a, volumeMap.rgb, volumeMap.a) / finalAlpha;\n                    ":"\n                    finalAlpha = mix(mainMap.a, 1.0, volume.a);\n                    finalColor = mix(mainMap.rgb * mainMap.a, volume.rgb, volume.a) / finalAlpha;\n                    "}\n\n                ${r} = ${D()}(finalColor, finalAlpha);\n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:U(e),fragmentShader:a}},"VolRTransfer"),b,{ISO_SURFACE:!1}),RenderChunk:new r(new t(function(n,e){var t=e.customDefines;const r=!!t.USE_CLIP_PLANE,a=n=>v("sampleVolTex","f",[f(n)]),i=o.getShaderOutput("out0");let s=`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n            ${$({uniformName:"tInput",uniformType:"t2",locationName:"tInput0"})}\n            ${$({uniformName:"tNormalDepth",uniformType:"t2",locationName:"tInput1"})}\n            ${$({uniformName:"realProjectionMatrixInverse",uniformType:"m4"})}\n            ${$({uniformName:"realModelViewMatrix",uniformType:"m4"})}\n            ${$({uniformName:"realModelViewMatrixInverse",uniformType:"m4"})}\n\n            ${r?$({uniformName:"clipPlaneEquation",uniformType:"v4"}):l}\n         \n            ${$({uniformName:"gridSize",uniformType:"v3"})}\n            ${$({uniformName:"uTMK",uniformType:"f"})}\n            ${$({uniformName:"attenuationCoeff",uniformType:"f"})}\n            ${$({uniformName:"attenuationScale",uniformType:"f"})}\n            ${$({uniformName:"colorMap",uniformType:"t2"})}\n            ${$({uniformName:"transferFctMap",uniformType:"t2"})}\n            ${$({uniformName:"nbCol",uniformType:"f"})}\n            ${$({uniformName:"mapDim",uniformType:"v3"})}\n            ${$({uniformName:"map0",uniformType:"t2"})}\n            ${$({uniformName:"minDisplayValue",uniformType:"f"})}\n            ${$({uniformName:"maxDisplayValue",uniformType:"f"})}\n            ${$({uniformName:"rangeDisplayValue",uniformType:"f"})}\n            ${$({uniformName:"minTileValue",uniformType:"f"})}\n            ${$({uniformName:"maxTileValue",uniformType:"f"})}\n            ${$({uniformName:"rangeTileValue",uniformType:"f"})}\n            ${$({uniformName:"isoValue",uniformType:"f"})}\n            ${$({uniformName:"debugChunkBox",uniformType:"v4"})}\n            ${$({uniformName:"renderIteration",uniformType:"f"})}\n        \n            ${y("TM_MIN")} = 0.05;\n            ${y("EPS")} = 0.0001;\n            ${y("PI")} = 3.14159265;\n            ${y("HALFPI")} = 1.57079633;\n            ${y("ROOTTHREE")} = 1.73205081;\n\n            ${x("stepSize")};\n            ${x("stepSizeModel")};\n            ${y("randomStep")} = 1.0 / 64.0;\n            ${x("depthVS")};\n            ${T("weight")} = ${T()}(1.0, 0.32, 0.08);\n            ${T("lightColor")} = ${T()}(1.0, 1.0, 1.0);\n            ${T("lightPos")} = ${T()}(100.0, 100.0, 100.0);\n            ${y("shininess")} = 40.0;\n\n            ${g("fetchDepthVS","f",[d("uv")])} {\n\n                ${D("normalDepth")}  = ${M("tNormalDepth","uv")};\n\n                // [0.0, 1.0]\n                ${e.renderToFloatTexture?`\n                    ${x("depth")} = normalDepth.w; \n                    `:`\n                    ${x("depth")}  = ${v("unpackForFloat16","f",[d("normalDepth.zw")])};\n                    `}\n\n                if (depth == 0.0) { depth = 1.0; };\n\n                ${D("vertexPositionProjected")}  = ${D()}(uv * 2.0 - 1.0, 2.0 * depth - 1.0, 1.0);\n                ${D("vertexPositionVS")}  = ${c("realProjectionMatrixInverse")} * vertexPositionProjected;\n                return vertexPositionVS.z / vertexPositionVS.w;\n            }\n\n            ${g("sampleVolTex","f",[f("pos")])} {\n\n              ${x("rowID")} = floor(pos.z / ${c("nbCol")});\n              ${x("rowID2")}  = rowID;\n              ${x("colID")}  = mod(floor(pos.z), ${c("nbCol")});\n              ${x("colID2")}  = mod(ceil(pos.z), ${c("nbCol")});\n              if (colID2 == 0.0) { rowID2 = rowID2 + 1.0; }\n\n              ${x("x1")}  = colID  * CHUNK_SIZE + pos.x + 0.5;\n              ${x("x2")}  = colID2 * CHUNK_SIZE + pos.x + 0.5;\n              ${x("y1")}  = rowID  * CHUNK_SIZE + pos.y + 0.5;\n              ${x("y2")}  = rowID2 * CHUNK_SIZE + pos.y + 0.5;\n\n              ${_("mapUV")}   = ${_()}(x1 * MAP_INVSIZE, 1.0 - y1 * MAP_INVSIZE);\n              ${_("mapUV2")}  = ${_()}(x2 * MAP_INVSIZE, 1.0 - y2 * MAP_INVSIZE);\n\n              ${x("alpha1")}  = ${M("map0","mapUV")}.a;\n              ${x("alpha2")}  = ${M("map0","mapUV2")}.a;\n\n              return mix(alpha1, alpha2, fract(pos.z));\n            }\n            ${t.ISO_SURFACE>0?`\n                ${g("add_lighting","v4",[p("value"),f("loc"),f("step"),f("rd")])} {\n\n                    ${T("V")}  = normalize(rd);\n    \n                    // Calculate normal vector from gradient\n                    ${T("N")} ;\n                    ${x("val1")} , val2;\n                    val1 = ${a(`loc + ${T()}(-step.x, 0.0, 0.0)`)};\n                    val2 = ${a(`loc + ${T()}(+step.x, 0.0, 0.0)`)};\n                    N.x = val1 - val2;\n                    value = max(max(val1, val2), value);\n                    val1 = ${a(`loc + ${T()}(0.0, -step.y, 0.0)`)};\n                    val2 = ${a(`loc + ${T()}(0.0, +step.y, 0.0)`)};\n                    N.y = val1 - val2;\n                    value = max(max(val1, val2), value);\n                    val1 = ${a(`loc + ${T()}(0.0, 0.0, -step.z)`)};\n                    val2 = ${a(`loc + ${T()}(0.0, 0.0, +step.z)`)};\n                    N.z = val1 - val2;\n                    value = max(max(val1, val2), value);\n    \n                    ${x("gm")}  = length(N); // gradient magnitude\n                    N /= gm;\n    \n                    // Flip normal so it points towards viewer\n                    ${x("Nselect")}  = ${x()}(dot(N, rd) > 0.0);\n                    // ==\tNselect * N - (1.0-Nselect)*N;\n                    N = (2.0 * Nselect - 1.0) * N; \n    \n                    // Init colors\n                    ${T("ambient_color")}  = ${T()}(0.0);\n                    ${T("diffuse_color")}  = ${T()}(0.0);\n                    ${T("specular_color")}  = ${T()}(0.0);\n    \n                    // Get light direction (make sure to prevent zero devision)\n                    ${T("L")}  = normalize(rd);\n                    ${x("lightEnabled")}  = ${x()}(length(L) > 0.0);\n                    L = normalize(L + (1.0 - lightEnabled));\n    \n                    // Calculate lighting properties\n                    ${x("lambertTerm")}  = clamp(dot(N, L), 0.0, 1.0);\n                    ${T("H")}  = normalize(L+rd); // Halfway vector\n                    ${x("specularTerm")}  = pow(max(dot(H, N), 0.0), shininess);\n    \n                    // Calculate mask\n                    ${x("mask1")}  = lightEnabled;\n    \n                    // Calculate colors\n                    ambient_color += mask1 * ambient_color;\n                    diffuse_color += mask1 * lambertTerm;\n                    specular_color += mask1 * specularTerm * specular_color;\n    \n                    // Calculate final color by componing different components\n                    ${T("color")}  = ${M("colorMap",`vec2(${c("rangeTileValue")}, 0.5)`)}.rgb;\n                    return ${D()}(color * (ambient_color + diffuse_color) + specular_color, 1.0);\n                }\n    \n                ${g("raymarchIso","v4",[f("ro"),f("rd"),h("prevData")])} {\n    \n                  ${T("ratio")}  = (${c("mapDim")} - ${T()}(1.0)) / ${c("gridSize")};\n                  ${t.RANDOM_STEP?`\n                    ${x("offset")}  = 1.0 + 0.8 * ${c("renderIteration")} * randomStep;\n                    `:`\n                    ${x("offset")}  = 1.0;\n                    `}\n                  ${T("stepModel")}  = offset * rd * stepSizeModel;\n                  ${T("stepGrid")}  = stepModel * ratio;\n                  ${T("posModel")}  = ro;\n                  ${T("posGrid")}  = (ro + 0.5 * ${c("gridSize")}) * ratio;\n                  ${T("dStep")}  = 1.5 / ${c("mapDim")};\n    \n                  ${T("col")}  = prevData.rgb;\n                  ${x("tm")}  = prevData.a;\n    \n                  if (tm > 0.5) { return prevData; }\n    \n                  for (${S("i")}=0; i<MAX_STEPS; ++i) {\n    \n                    ${x("density")}  = ${a("posGrid.xyz")};\n                    ${x("remappedDensity")}  = (density - ${c("minDisplayValue")}) / ${c("rangeDisplayValue")};\n                    remappedDensity = min(max(remappedDensity, 0.0), 1.0);\n    \n                    if (remappedDensity > ${c("rangeTileValue")}) {\n    \n                        ${T("interPosGrid")}  = posGrid - 1.0 * stepGrid;\n                        ${T("interPosModel")}  = posModel - 1.0 * stepModel;\n                        ${T("smallStepGrid")}  = 0.25 * stepGrid;\n                        ${T("smallStepModel")}  = 0.25 * stepModel;\n    \n                        for (${S("i")}=0; i<4; i++) {\n    \n                            density = ${a("interPosGrid.xyz")};\n                            remappedDensity = (density - ${c("minDisplayValue")}) / ${c("rangeDisplayValue")};\n                            remappedDensity = min(max(remappedDensity, 0.0), 1.0);\n    \n                            if (remappedDensity > ${c("rangeTileValue")}) {\n    \n                                return ${v("add_lighting","v4",[p("remappedDensity"),f("interPosGrid"),f("dStep"),f("rd")])};\n                            }\n    \n                            interPosGrid += smallStepGrid;\n                            interPosModel += smallStepModel;\n                        }\n                    }\n    \n                    posGrid += stepGrid;\n                    posModel += stepModel;\n    \n                    if (tm < 0.0 || posGrid.x > ${c("mapDim")}.x - 1.0 || posGrid.x < 0.0 || posGrid.y > ${c("mapDim")}.y - 1.0 || posGrid.y < 0.0 || posGrid.z > ${c("mapDim")}.z - 1.0 || posGrid.z < 0.0)\n                      break;\n    \n                    ${D("posVS")} = ${c("realModelViewMatrix")}  *  ${D()}(posModel, 1.0);\n                    if (posVS.z < depthVS) { break; }\n                  }\n    \n                  return ${D()}(0.0);\n                }\n                `:`\n                \n\n            ${g("raymarch","v4",[f("ro"),f("rd"),h("prevData")])} {\n\n                ${T("ratio")}  = (${c("mapDim")} - ${T()}(1.0)) / ${c("gridSize")};\n                ${t.RANDOM_STEP?`\n                  ${x("offset")}  = 1.0 + 0.8 * ${c("renderIteration")} * randomStep;\n                  `:`\n                  ${x("offset")}  = 1.0;\n                  `}\n  \n                ${T("posModel")}  = ro;\n                ${T("posGrid")}  = (ro + 0.5 * ${c("gridSize")}) * ratio;\n  \n                ${T("stepModel")}  = offset * rd * stepSizeModel;\n                ${T("stepGrid")}  = stepModel * ratio;\n  \n                ${T("col")}  = prevData.rgb;\n                ${x("tm")}  = prevData.a;\n  \n                for (${S("i")}=0; i<MAX_STEPS; ++i) {\n  \n                  ${D("posVS")} = ${c("realModelViewMatrix")} * ${D()}(posModel, 1.0);\n                  if (posVS.z < depthVS) { break; }\n  \n                  // clipping plane\n  \n                  ${r?`\n                      ${x("clipDist")}  = dot(posVS.xyz, ${c("clipPlaneEquation")}.xyz) + ${c("clipPlaneEquation")}.w;\n                      if (clipDist >= 0.0) {\n                      `:l}\n  \n                      ${x("normalizedDensity")}  = ${a("posGrid.xyz")};\n                      ${x("density")}  = ${c("minTileValue")} + normalizedDensity * ${c("rangeTileValue")};\n                      ${x("remappedDensity")}  = (density - ${c("minDisplayValue")}) / ${c("rangeDisplayValue")};\n                      // clamp [0 + 0.5/180, 1 - 0.5/180]\n                      remappedDensity = min(max(remappedDensity, 0.0028), 0.997); \n                      ${_("mapUV")} = ${_()}(remappedDensity, 0.5);\n                      ${T("color")}  = ${M("colorMap","mapUV")}.rgb;\n                      ${x("opacity")}  = ${M("transferFctMap","mapUV")}.r;\n                      opacity *= step(${c("minDisplayValue")}, density) * step(-${c("maxDisplayValue")}, -density);\n  \n                      ${x("dtm")}  = exp( -${c("uTMK")} * stepSizeModel * ${c("attenuationCoeff")} * ${c("attenuationScale")} * opacity );\n                      tm *= dtm;\n                      col += (1.0 - dtm) * color * tm;\n  \n                  ${r?"\n                      }\n                      ":l}\n  \n                  posGrid += stepGrid;\n                  posModel += stepModel;\n  \n                  if (tm < 0.0 || posGrid.x > ${c("mapDim")}.x - 1.0 || posGrid.x < 0.0 || posGrid.y > ${c("mapDim")}.y - 1.0 || posGrid.y < 0.0 || posGrid.z > ${c("mapDim")}.z - 1.0 || posGrid.z < 0.0) {\n                      break;\n                  }\n                }\n                return ${D()}(col, tm);\n              }\n                `}\n           \n\n            ${m.getMainFragmentStart()}\n                ${_("screenUV")} = ${P("vUv")};\n\n                ${D("outColor")} = ${M("tInput","screenUV")};\n\n                ${D("clipVec")} = ${D()}(screenUV * 2.0 - 1.0, 0.0, 1.0);\n                ${D("posVS")} = ${c("realProjectionMatrixInverse")} * clipVec;\n                posVS.xyz /= posVS.w;\n                posVS.w = 1.0;\n                ${T("rd")}  = (${c("realModelViewMatrixInverse")}  * posVS).xyz;\n                ${T("ro")}  = (${c("realModelViewMatrixInverse")} * ${D()}(0.0, 0.0, 0.0, 1.0)).xyz;\n                rd = normalize(rd - ro);\n\n                ${T("rad")}  = 0.5 * ${c("gridSize")};\n\n                ${T("m")}  = 1.0 / rd;\n                ${T("n")}  = m * ro;\n                ${T("k")}  = abs(m) * rad;\n                ${T("t1")}  = -n - k;\n                ${T("t2")}  = -n + k;\n\n                ${x("tN")}  = max(max(t1.x, t1.y), t1.z);\n                ${x("tF")}  = min(min(t2.x, t2.y), t2.z);\n\n                if(tN <= tF && tF >= 0.0) { // intersection with the grid\n\n                    ${T("intersect")}  = ro + tN * rd;\n                    ${D("intersectVS")} = ${c("realModelViewMatrix")}  * ${D()}(intersect, 1.0);\n\n                    depthVS = fetchDepthVS(screenUV);\n\n                    if (intersectVS.z >= depthVS) { // no occlusion with the scene\n\n                        stepSize = max(${c("mapDim")}.x, max(${c("mapDim")}.y, ${c("mapDim")}.z)) * ROOTTHREE / ${x()}(MAX_STEPS);\n                        stepSizeModel = max(${c("gridSize")}.x, max(${c("gridSize")}.y, ${c("gridSize")}.z)) * ROOTTHREE / ${x()}(MAX_STEPS);\n\n                        ${t.ISO_SURFACE>0?`     \n                            outColor = ${v("raymarchIso","v4",[f("intersect"),f("rd"),h("outColor")])} + ${c("debugChunkBox")};\n                            `:`\n                            outColor = ${v("raymarch","v4",[f("intersect"),f("rd"),h("outColor")])} + ${c("debugChunkBox")};            \n                            `}\n                    }\n                }\n\n                ${i} = outColor;           \n            ${m.getMainFragmentEnd()}\n        `;return{vertexShader:U(e),fragmentShader:s}},"VolRRenderChunk"),w,{MAX_STEPS:"256",CHUNK_SIZE:"64.0",MAP_INVSIZE:"0.001953125",USE_CLIP_PLANE:!1,RANDOM_STEP:!0,ISO_SURFACE:0})}}),define("DS/ShaderBuilders/PostPro/SDFFontIterativeShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterV2(n),p=n=>l.parameterV4(n),d=(n,e,t)=>u.declareFunction(n,e,t),f=(n,e,t)=>u.callFunction(n,e,t),h=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},g=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},S=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},x=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},_=n=>o.addVarying(n),T=n=>o.getVarying(n,o.ShaderStages.in),D=n=>o.getVarying(n,o.ShaderStages.out),C=(n,e)=>u.sample2DTexture(n,e);class P extends e{constructor(){super()}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i)}clone(){return new P}}class N extends P{constructor(){super(),this.size=new n.Vector2(256,256),this.invSize=new n.Vector2(1/256,1/256)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.size,this.size.x,this.size.y),t.uniform2f(r.invSize,this.invSize.x,this.invSize.y)}clone(){return new N}}class M extends e{constructor(){super(),this.tileMin=new n.Vector2(0,0),this.tileMax=new n.Vector2(64,64),this.realTileMax=new n.Vector2(64,646)}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform2f(r.tileMin,this.tileMin.x,this.tileMin.y),t.uniform2f(r.tileMax,this.tileMax.x,this.tileMax.y),t.uniform2f(r.realTileMax,this.realTileMax.x,this.realTileMax.y)}clone(){return new M}}function b(e){return`           \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n\n            ${u.getMainVertexStart()}\n                ${D("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(e)}\n            ${u.getMainVertexEnd()}\n        `}return{SDFFontDisplay:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n                ${h("dist")} = ${C("tInput","screenUV")}.r;\n                ${t} = ${y()}(${x()}(mod(10.0*dist, 1.0)), 1.0);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:r}},"SDFFontDisplay"),P,{}),SDFFontMerge:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n\n                ${y("texel")} = ${C("tInput","screenUV")};\n                ${h("diff")} = length(texel.rg) - length(texel.ba);\n                diff = clamp(20.0 * diff, -1.0, 1.0);\n                diff = clamp(0.5 * diff + 0.5, 0.0, 1.0);\n                ${t} = ${y()}(${x()}(diff), 1.0);           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:r}},"SDFFontMerge"),P,{}),SDFFontSeed:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n\n                ${y("texel")} = ${C("tInput","screenUV")};\n                if (texel.r > 0.99999) {\n                    ${t} = ${y()}(9999.0, 9999.0, 0.0, 0.0);   \n                } else {\n                    ${t} = ${y()}(0.0, 0.0, 9999.0, 9999.0);   \n                }        \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:r}},"SDFFontSeed"),P,{}),SDFFontFlood:new r(new t(function(n,e){e.customDefines;const t=(n,e,t,r)=>f("ComputeDistance","v4",[c(n),c(`${v()}(${e}, ${t})`),p(r)]),r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n\n            ${d("ComputeDistance","v4",[c("uv"),c("offset"),p("bestseed")])}{\n\n                ${v("newvec")}  = uv + offset;\n                ${y("newseed")}  = ${C("tInput","newvec")};\n                ${y("returnSeed")} = bestseed;\n                // if the new seed is not indeterminate distance\n                if (newvec.x >= 0.0 && newvec.x <= 1.0 && newvec.y >= 0.0 && newvec.y <= 1.0) { \n\n                    newseed.r += offset.x;\n                    newseed.g += offset.y;\n                    newseed.b += offset.x;\n                    newseed.a += offset.y;\n\n                    if (length(newseed.rg) < length(returnSeed.rg)) {\n\n                        returnSeed.r = newseed.r;\n                        returnSeed.g = newseed.g;\n                    }\n\n                    if (length(newseed.ba) < length(returnSeed.ba)) {\n\n                        returnSeed.b = newseed.b;\n                        returnSeed.a = newseed.a;\n                    }\n                }\n                return returnSeed;\n            }\n\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n\n                ${y("bestseed")} = ${C("tInput","screenUV")};\n\n                ${v("iSize")} = ${$("invSize")};\n\n                bestseed = ${t("screenUV","-iSize.x","-iSize.y","bestseed")};\n                bestseed = ${t("screenUV","-iSize.x","0.0","bestseed")};\n                bestseed = ${t("screenUV","-iSize.x","iSize.y","bestseed")};\n\n                bestseed = ${t("screenUV","0.0","-iSize.y","bestseed")};\n                bestseed = ${t("screenUV","0.0","iSize.y","bestseed")};\n\n                bestseed = ${t("screenUV","iSize.x","-iSize.y","bestseed")};\n                bestseed = ${t("screenUV","iSize.x","0.0","bestseed")};\n                bestseed = ${t("screenUV","iSize.x","iSize.y","bestseed")};\n\n                ${r} = bestseed;     \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:a}},"SDFFontFlood"),N,{}),SDFFontCompute:new r(new t(function(n,e){const t=!!e.customDefines.OUTSIDE,r=o.getShaderOutput("out0");let a=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n\n            ${g("SQRT2")} = 1.41421356;\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n\n                ${h("value")} = ${C("tInput","screenUV")}.r;\n\n                ${v("iSize")} = ${$("invSize")};\n                ${h("qv")} = iSize.x;\n                ${h("qd")} = SQRT2 * iSize.y;\n\n                ${h("lValue")}   = ${C("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y)`)}.r + qv;\n                ${h("rValue")}   = ${C("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y)`)}.r + qv;\n                ${h("bValue")}   = ${C("tInput",`${v()}(screenUV.x, screenUV.y - iSize.y)`)}.r + qv;\n                ${h("tValue")}   = ${C("tInput",`${v()}(screenUV.x, screenUV.y + iSize.y)`)}.r + qv;\n\n                ${h("tlValue")}  = ${C("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y + iSize.y)`)}.r + qd;\n                ${h("trValue")}  = ${C("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y + iSize.y)`)}.r + qd;\n                ${h("blValue")}  = ${C("tInput",`${v()}(screenUV.x - iSize.x, screenUV.y - iSize.y)`)}.r + qd;\n                ${h("brValue")}  = ${C("tInput",`${v()}(screenUV.x + iSize.x, screenUV.y - iSize.y)`)}.r + qd;\n\n                ${t?"\n                    if (screenUV.x - iSize.x > 0.0) { value = min(lValue, value); }\n                    if (screenUV.x + iSize.x < 1.0) { value = min(rValue, value); }\n                    if (screenUV.y - iSize.y > 0.0) { value = min(bValue, value); }\n                    if (screenUV.y + iSize.y < 1.0) { value = min(tValue, value); }\n    \n                    if (screenUV.x - iSize.x > 0.0 && screenUV.y + iSize.y < 1.0) { value = min(tlValue, value); }\n                    if (screenUV.x + iSize.x < 1.0 && screenUV.y + iSize.y < 1.0) { value = min(trValue, value); }\n                    if (screenUV.x - iSize.x > 0.0 && screenUV.y - iSize.y > 0.0) { value = min(blValue, value); }\n                    if (screenUV.x + iSize.x < 1.0 && screenUV.y - iSize.y > 0.0) { value = min(brValue, value); }\n    \n                    ":'\n                    // JBN10: what is inScreen4?? This code does not compile nor touch "value"\n                    lValue  = mix(1.0, lValue, inScreen4.x);\n                    rValue   = mix(1.0, rValue, inScreen4.y);\n                    bValue   = mix(1.0, bValue, inScreen4.z);\n                    tValue   = mix(1.0, tValue, inScreen4.w);\n    \n                    tlValue  = mix(1.0, tlValue, inScreen4.x * inScreen4.w);\n                    trValue  = mix(1.0, trValue, inScreen4.y * inScreen4.w);\n                    blValue  = mix(1.0, blValue, inScreen4.x * inScreen4.z);\n                    brValue  = mix(1.0, brValue, inScreen4.y * inScreen4.z);\n                    '}\n\n                ${r} = ${y()}(${x()}(value), 1.0);     \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:a}},"SDFFontCompute"),N,{OUTSIDE:!1}),SDFFontDisplayResult:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            ${m({uniformName:"invSize",uniformType:"v2"})}\n            ${m({uniformName:"size",uniformType:"v2"})}\n\n            ${g("SQRT2")} = 1.41421356;\n\n            ${S("halfVec2")} = ${v()}(0.5);\n\n            ${u.getMainFragmentStart()}\n                // Scale texcoords to range ([0,texw], [0,texh])\n                ${v("uv")} = ${T("vUv")} * ${$("size")};\n                ${v("iSize")} = ${$("invSize")};\n\n                // Compute texel-local (u,v) coordinates for the four closest texels\n                // Lower left corner of lower left texel\n                ${v("uv00")}  = floor(uv - halfVec2); \n                // Texel-local lerp blends [0,1]\n                ${v("uvlerp")}  = uv - uv00 - halfVec2;\n\n                // Perform explicit texture interpolation of distance value.\n                // This is required for the split RG encoding of the 8.8 fixed-point value,\n                // and as a bonus it works around the bad texture interpolation precision\n                // in at least some ATI hardware.\n\n                // Center st00 on lower left texel and rescale to [0,1] for texture lookup\n                ${v("st00")}  = (uv00 + halfVec2) * iSize;\n\n                // Compute distance value from four closest 8-bit RGBA texels\n                ${y("D00")}  = ${C("tInput","st00")};\n                ${y("D10")}  = ${C("tInput",`st00 + ${v()}(iSize.x, 0.0)`)};\n                ${y("D01")}  = ${C("tInput",`st00 + ${v()}(0.0, iSize.y)`)};\n                ${y("D11")}  = ${C("tInput",`st00 + ${v()}(iSize.x, iSize.y)`)};\n\n                // Restore the values for D from their 8.8 fixed point encoding in RG channels\n                ${v("D00_10")}  = ${v()}(D00.r, D10.r)*255.0-128.0 + ${v()}(D00.g, D10.g)*(255.0/256.0);\n                ${v("D01_11")}  = ${v()}(D01.r, D11.r)*255.0-128.0 + ${v()}(D01.g, D11.g)*(255.0/256.0);\n\n                // Interpolate along v\n                ${v("D0_1")}  = mix(D00_10, D01_11, uvlerp.y);\n                // Interpolate along u\n                ${h("D")}  = mix(D0_1.x, D0_1.y, uvlerp.x);\n\n                // Replacement for RSL's 'filterstep()', with fwidth() done right.\n                // 'threshold ' is constant , 'D ' is smoothly varying\n                ${h("threshold")} = 0.0;\n                ${h("afwidth")}  = 0.7 * length ( ${v()}(dFdx(D), dFdy(D)));\n                ${h("g")} = smoothstep (threshold - afwidth, threshold + afwidth, D);\n\n                ${t} = ${y()}(${x()}(g), 1.0);     \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:r}},"SDFFontDisplayResult"),N,{}),SDFFontMergeTiles:new r(new t(function(n,e){e.customDefines;const t=o.getShaderOutput("out0");let r=`\n            \n            ${_({varyingName:"vUv",varyingType:"v2"})}\n            ${m({uniformName:"tInput",uniformType:"t2"})}\n            // offset\n            ${m({uniformName:"tileMin",uniformType:"v2"})}\n            // offset + tile size\n            ${m({uniformName:"tileMax",uniformType:"v2"})}\n            // offset + real size\n            ${m({uniformName:"realTileMax",uniformType:"v2"})}\n\n            ${u.getMainFragmentStart()}\n                ${v("screenUV")} = ${T("vUv")};\n                if (screenUV.x < ${$("tileMin")}.x) { \n                    discard; \n                }\n                ${v("tiledUV")}  = (screenUV - ${$("tileMin")}) / (${$("tileMax")} - ${$("tileMin")});\n                tiledUV.y = 1.0 - tiledUV.y;\n\n                ${t} = ${C("tInput","tiledUV")};           \n            ${u.getMainFragmentEnd()}\n        `;return{vertexShader:b(e),fragmentShader:r}},"SDFFontMergeTiles"),M,{})}}),define("DS/ShaderBuilders/PostPro/HighlightShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l="",u="true"===localStorage.getItem("__1x3HL__"),m=i.ParameterUtils,$=i.FunctionHandler,c=()=>s.dereference(),p=n=>a.addUniform(n),d=n=>{var e={uniformName:n};return a.getUniform(e)},f=(n,e,t=!1)=>m.parameter(n,e,t),h=n=>m.parameterF(n),g=n=>m.parameterI(n),v=n=>m.parameter("b",n),S=n=>m.parameterInOut("b",n),x=n=>m.parameterRef("b",n),y=n=>m.parameterV2(n),_=n=>m.parameterV4(n),T=n=>m.parameterInOutV4(n),D=n=>m.parameterRefV4(n),C=(n,e,t)=>$.declareFunction(n,e,t),P=(n,e,t)=>$.callFunction(n,e,t),N=(n=null,e=0)=>{var t={name:n,size:e};return s.bool(t)},M=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},b=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},w=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},U=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},z=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},V=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},F=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},R=n=>o.addVarying(n),A=n=>o.getVarying(n,o.ShaderStages.in),I=n=>o.getVarying(n,o.ShaderStages.out),L=(n,e)=>$.sample2DTexture(n,e);class B extends e{constructor(){super(1),this.h=1/1024,this.v=1/1024,this.empty=0,this.poisson=[],this.iHaloColors=[],this.iLineicHaloColors=[],this.iColors=[],this.iOutlineColors=[],this.iLineicOutlineColors=[]}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.h,this.h),t.uniform1f(r.v,this.v),t.uniform1i(r.empty,this.empty),t.uniform1fv(r.poisson,this.poisson),t.uniform4fv(r.iHaloColors,this.iHaloColors),t.uniform4fv(r.iLineicHaloColors,this.iLineicHaloColors),t.uniform4fv(r.iColors,this.iColors),t.uniform4fv(r.iOutlineColors,this.iOutlineColors),t.uniform4fv(r.iLineicOutlineColors,this.iLineicOutlineColors)}clone(){var n=new B;return n.h=this.h,n.v=this.v,n.empty=this.empty,n.poisson=this.poisson,n.iHaloColors=this.iHaloColors,n.iLineicHaloColors=this.iLineicHaloColors,n.iColors=this.iColors,n.iOutlineColors=this.iOutlineColors,n.iLineicOutlineColors=this.iLineicOutlineColors,n}}const k={POSTPRO:1,NB_CONFIG:0,HALO_THICKNESS:2,HAS_POLITE:0,QA_AUTOMATION:0};let E={UNROLLED:1};Object.assign(E,k);let O={UNROLLED:0};Object.assign(O,k);const G=new t(function(e,t){var r=t.customDefines;let a=`\n            ${R({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n                ${I("vUv")} = uv.xy;\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const i=r.NB_CONFIG,m=1===i,$=!!r.POSTPRO,B=!!r.UNROLLED,k=!B&&!!r.HAS_POLITE,E=!!r.QA_AUTOMATION,O="tSceneHighlight",G=r.HALO_THICKNESS,H=o.getShaderOutput("out0"),X=n=>P("GetID","i",[h(n)]),W=n=>P("GetID","i",[_(n)]);function j(n){for(var e="",t=0;t<i;t++)e=`\n                    ${e}\n                    if (${t} + 1 == index) {\n                        ${b("i")} = ${t};\n                        ${n};\n                    }\n                `;return e}return{vertexShader:a,fragmentShader:`\n            \n            ${R({varyingName:"vUv",varyingType:"v2"})}\n        \n            ${$?p({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"}):l}\n            ${p({uniformName:"tSceneHighlight",uniformType:"t2",locationName:"tInput1"})}\n            ${p({uniformName:"h",uniformType:"f"})}\n            ${p({uniformName:"v",uniformType:"f"})}\n            ${p({uniformName:"empty",uniformType:"i"})}\n            ${p({uniformName:"poisson",uniformType:"fv1",size:24})}\n            //\n            ${p({uniformName:"iHaloColors",uniformType:"fv4",size:i})}\n            ${p({uniformName:"iLineicHaloColors",uniformType:"fv4",size:i})}\n            //\n            ${p({uniformName:"iOutlineColors",uniformType:"fv4",size:i})}\n            ${p({uniformName:"iLineicOutlineColors",uniformType:"fv4",size:i})}\n            //\n            ${p({uniformName:"iColors",uniformType:"fv4",size:i})}\n\n            ${U("fHaloThickness")} = ${w()}(${G});\n            ${b("haloThickness")} = ${G};\n\n            \n            ${s.createStructure({structName:"highlightConfig",attributes:[{type:"b",name:"colorEnabled"},{type:"v3",name:"color"},{type:"v2",name:"colorIntensity"},{type:"b",name:"outlineEnabled"},{type:"v3",name:"outlineColor"},{type:"v3",name:"lineicOutlineColor"},{type:"f",name:"outlineAlpha"},{type:"f",name:"outlineThickness"}]})}\n\n            \n            ${s.declareStructure({name:"emptyConfig",structName:"highlightConfig",addressSpace:"private"})};\n\n            ${U("outlineCheck")} = 8.0;\n\n            ${C("GetID","i",[h("texR")])} {\n                return ${M()}(floor(255.0 * texR + 0.5));\n            }\n\n            ${C("GetID","i",[_("tex")])} {\n                return ${M()}(floor(255.0 * tex.r + 0.5));\n            }\n\n            ${C("GetHaloData","v4",[g("index"),h("glType")])}{\n                ${F("res")} = ${F()}(0.0);\n                ${k?`\n                    if (${X("glType")} == 2 || ${X("glType")} == 4) {\n                        return res;\n                    }\n                    `:l}\n                ${w("factor")} = 0.0;\n                if (${X("glType")} <= 2) {\n                    factor = ceil(glType);\n                }\n                if (index > 0) {\n                    ${m?`\n                        res.a = (1.0 + factor) * ${d("iHaloColors")}[0].a;\t\t\t\t\t\n                        res.r = ${d("iHaloColors")}[0].r;\t\t\n                        res.g = ${d("iHaloColors")}[0].g;\t\t\n                        res.b = ${d("iHaloColors")}[0].b;\n                        `:function(){const n=`       \n                res.a = (1.0 + factor) * ${d("iHaloColors")}[i].a;\n                ${V("color")} = ${d("iHaloColors")}[i].rgb;\n                res.r = color.r;\n                res.g = color.g;\n                res.b = color.b;\n            `;return B?j(n):`\n            for (${M("i")} = 0; i < ${i}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                }\n                return res;\n            }\n\n            ${C("GetLineicHaloData","v4",[g("index")])}{\n                ${F("res")} = ${F()}(0.0);\n                if (index > 0) {\n                    ${m?`\t\t\t\n                        res.r = ${d("iLineicHaloColors")}[0].x;\t\t\n                        res.g = ${d("iLineicHaloColors")}[0].y;\t\t\n                        res.b = ${d("iLineicHaloColors")}[0].z;\n                        `:function(){const n=`          \n                ${V("color")} = ${d("iLineicHaloColors")}[i].rgb;\n                res.r = color.x;\n                res.g = color.y;\n                res.b = color.z;\n            `;return B?j(n):`\n            for (${M("i")} = 0; i < ${i}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                }\n                ${u?"\n                    res.a = 0.45;\n                    ":"\n                    res.a = 0.8;\n                    "}\n                return res;\n            }\n\n            ${C("GetHighlightConfig","highlightConfig",[g("index")])} {               \n                if (index > 0) {                  \n                    ${s.declareVariable({name:"res",type:"highlightConfig",custom:!0})};\n                    ${m?`\t\t\t\n                        res.color = ${d("iColors")}[0].rgb;\n                        res.colorIntensity = ${z()}(${d("iColors")}[0].a, ${d("iLineicHaloColors")}[0].a);\n                        res.outlineColor = ${d("iOutlineColors")}[0].rgb;\n                        res.lineicOutlineColor = ${d("iLineicOutlineColors")}[0].rgb;\n                        res.outlineAlpha = ${d("iOutlineColors")}[0].a;\n                        //res.lineicOutlineAlpha = ${d("iLineicOutlineAlphas")}[0];\n                        res.outlineThickness = ${d("iLineicOutlineColors")}[0].a;\n                        `:function(){const n=`\n            \n                res.color = ${d("iColors")}[i].rgb;\n                res.colorIntensity = ${z()}(${d("iColors")}[i].a, ${d("iLineicHaloColors")}[i].a);\n                res.outlineColor = ${d("iOutlineColors")}[i].rgb;\n                res.lineicOutlineColor = ${d("iLineicOutlineColors")}[i].rgb;\n                res.outlineAlpha = ${d("iOutlineColors")}[i].a;\n                //res.lineicOutlineAlpha = ${d("iLineicOutlineAlphas")}[i];\n                res.outlineThickness = ${d("iLineicOutlineColors")}[i].a;\n            `;return B?j(n):`\n            for (${M("i")} = 0; i < ${i}; i++) {\n                if (i + 1 == index) {\n                    ${n}\n                    break;\n                }\n            }\n            `}()}\n                    return res;\n                }\n                return emptyConfig;\n            }\n\n            ${C("GetHighlightConfig","highlightConfig",[h("texR")])} {\n                ${M("id")} = ${X("texR")};\n                return ${P("GetHighlightConfig","highlightConfig",[g("id")])};\n            }\n\n            ${k?`             \n                ${C("DoPoliteLineic","b",[T("center"),S("forceOutlineOn"),S("forceHaloOn"),S("isLineic"),g("id"),y("iUv")])}{\n                    ${N("forceBasePostProOff")}  = false;\n                    ${F("oldCenter")}  = ${c()}center;\n                    ${M("curID")}  = 0;\n                    ${w("curDistance")}  = 1e6;\n                    ${N("curBack")}  = false;\t\n                    ${N("outer")}  = false;\n                    ${N("outerOutline")}  = false;\t\t\t\t\n                    ${N("inner")}  = false;\t\t\t\t\t\n                    ${N("innerOuter")}  = false;\t\t\t\n                    ${N("innerOutline")}  = false;\t\n                    ${z("oneAndHalf")} = ${z()}(1.5, 1.5);\n                    ${z("halfVec")} = ${z()}(0.5, 0.5);\n                    for (${M("i")} = -2; i <= 2 ; i++) {\n                        for (${M("j")} = -2; j <= 2 ; j++) {\n                            ${z("offsetFactor")} = ${z()}(${w()}(i), ${w()}(j));\n                            ${w("dist")} = length(offsetFactor);\n                            ${z("uv")} = iUv + offsetFactor * ${z()}(${d("h")},${d("v")});\n                            ${F("auxCenter")}  = ${L(O,"uv")};\n                            if (${X("auxCenter.w")} == id && auxCenter.b > 0.0) {\t\t\t\t\t\t\n                                ${M("auxID")}  = ${X("auxCenter.r")};\n                                if (dist < curDistance || (abs(dist - curDistance) < 1e-6)) {\n                                    // Front Priority\n                                    if (curID > 0 && auxCenter.b > 0.5 && !curBack) {\n                                        continue;\n                                    }\n                                    ${c()}center = auxCenter;\n                                    curID = auxID;\n                                    curDistance = dist;\n                                    curBack = auxCenter.b > 0.5;\n                                    outer = any(greaterThan(abs(offsetFactor), oneAndHalf));\n                                    outerOutline = outer;\n                                    //outerOutline = any(greaterThan(abs(offsetFactor), oneAndHalf)) && !outer;\n                                    inner = all(lessThan(abs(offsetFactor), oneAndHalf));\n                                    innerOuter = inner;\n                                    //inner && any(greaterThan(abs(offsetFactor), oneAndHalf));\n                                    innerOutline = any(greaterThan(abs(offsetFactor), halfVec));\t\n                                    forceBasePostProOff = true;\t\t\t\t\t\t\t\t\t\t\n                                }\n                            }\n                        }\n                    }\n                    if (curBack && !inner){\n                        ${c()}center = oldCenter;\n                    } else {\n                        ${c()}forceOutlineOn = (curBack && !innerOutline) || (!curBack && !outerOutline && innerOutline);\n                        ${c()}forceHaloOn = (curBack && innerOutline) || (!curBack && outerOutline);\n                        ${c()}isLineic = ${X(`${c()}center.w`)} == id;\n                    }\n                    return forceBasePostProOff;\n                }\n                `:l}\n\n            ${C("CheckIfOutlines","f",[_("center"),y("uv"),f("highlightConfig","config",!0)])} {\n                ${M("curID")} = ${P("GetID","i",[h("center.r")])};\n                ${w("tx")} = config.outlineThickness * ${d("h")};\n                ${w("ty")} = config.outlineThickness * ${d("v")};\n\n                ${w("result")} = 0.0;\n\n\t\t\t\t${M("cardinalSampling")}  = ${W(L(O,`${z()}( uv.x - tx, uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling      = ${W(L(O,`${z()}( uv.x     , uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling  = ${W(L(O,`${z()}( uv.x + tx, uv.y + ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n\t\t\t\tcardinalSampling      = ${W(L(O,`${z()}( uv.x - tx, uv.y)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling       = ${W(L(O,`${z()}( uv.x + tx, uv.y)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n\t\t\t\tcardinalSampling  = ${W(L(O,`${z()}( uv.x - tx, uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling      = ${W(L(O,`${z()}( uv.x     , uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\t\t\t\tcardinalSampling  = ${W(L(O,`${z()}( uv.x + tx, uv.y - ty)`))};\n                if (curID == cardinalSampling) {\n                    result += 1.0;\n                }\n\n                return result;\n            }\n\n            ${C("ComputeHaloColor","v4",[y("uv")])} {\n\n\t\t\t\t${F("haloColor")}  = ${F()}(0.0);\n\t\t\t\t${w("count")}  = 0.0;\n\t\t\t\t${w("tx")}  = fHaloThickness * ${d("h")};\n\t\t\t\t${w("ty")}  = fHaloThickness * ${d("v")};\n\n\t\t\t\t{\n\t\t\t\t\t${w("stx")}  = 1.5 * ${d("h")};\n\t\t\t\t\t${w("sty")}  = 1.5 * ${d("v")};\n\t\t\t\t\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x - stx, uv.y + sty)`)}.r;\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x    , uv.y + sty)`)}.r;\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x + stx, uv.y + sty)`)}.r;\n\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x - stx, uv.y)`)}.r;\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x + stx, uv.y)`)}.r;\n\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x - stx, uv.y - sty)`)}.r;\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x    , uv.y - sty)`)}.r;\n\t\t\t\t\tcount+= ${L(O,`${z()}( uv.x + stx, uv.y - sty)`)}.r;\n\t\t\t\t\tfor (${M("p")} = 0; p < 24; p += 2) {\t\t\t\t\n\t\t\t\t\t\tcount += ${L(O,`${z()}(uv.x + tx * ${d("poisson")}[p], uv.y + ty * ${d("poisson")}[p+1])`)}.r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > 0.0) {\n\t\t\t\t\t${F("aux")} ;\n\t\t\t\t\t${w("hit")}  = 0.0;\n\t\t\t\t\tfor (${M("halo")}  = 1; halo <= haloThickness ; halo++) {\t\t\n\t\t\t\t\t\ttx = ${w()}(halo) * ${d("h")};\n\t\t\t\t\t\tty = ${w()}(halo) * ${d("v")};\t\t\t\t\n\t\t\t\t\t\tfor (${M("p")} = 0; p < 24; p += 2) {\t\n\t\t\t\t\t\t\t${F("tex")}  = ${L(O,`${z()}(uv.x + tx * ${d("poisson")}[p], uv.y + ty * ${d("poisson")}[p+1])`)};\n\t\t\t\t\t\t\taux = ${P("GetHaloData","v4",[g(`${X("tex.r")}`),h("tex.w")])};\n\t\t\t\t\t\t\thaloColor += aux;\n                            if (aux.a > 0.0) {\n                                hit += 1.0;\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thaloColor.a *= 0.08333333333 / fHaloThickness;\n\t\t\t\t\thaloColor.r /= max(hit, 1.0);\n\t\t\t\t\thaloColor.g /= max(hit, 1.0);\n\t\t\t\t\thaloColor.b /= max(hit, 1.0);\n\t\t\t\t}\t\t\t\n\t\t\t\treturn haloColor;\n            }\n\n            ${C("GetLineicAlpha","f",[v("isEdge")])}{\n                ${u?"\n                    return 0.8;\n                    ":"\n                    if (isEdge) return 0.6;\n                    return 0.8;\n                    "}\n            }\n\n            ${C("ComputePoliteColorAlpha","f",[f("highlightConfig","config",!0),v("isMarker"),v("isEdge"),v("back")])}{\n                if (isMarker || isEdge) {\n                    return ${P("GetLineicAlpha","f",[v("isEdge")])};\n                }\n                if (back) {\n                    return config.colorIntensity.y;\n                }\n                return config.colorIntensity.x;\n            }\n\n            ${C("ComputeHaloColorAlpha","f",[f("highlightConfig","config",!0),h("factor")])}{\n                return (0.6 * factor + 0.2) * config.colorIntensity.x;\n            }\n\n            void main() {\n                // varying storage\n                ${z("screenUV")} = ${A("vUv")};\n                ${F("fetched")} = ${F()}(0.0);\n                ${$?`\n                    fetched = ${L("tScene","screenUV")};\n                    `:l}\n                if (${d("empty")} == 0) {\n                    ${H} = fetched;\n                    return;\n                }\n\n                \n\t\t\t\t// init empty config\n\t\t\t\temptyConfig.color = ${V()}(0.0);\n\t\t\t\temptyConfig.colorIntensity = ${z()}(0.0, -1.0);\n\t\t\t\temptyConfig.outlineColor = ${V()}(0.0);\n\t\t\t\temptyConfig.lineicOutlineColor = ${V()}(0.0);\n\t\t\t\t//emptyConfig.lineicOutlineAlpha = 0.0;\n\t\t\t\temptyConfig.outlineAlpha = 0.0;\n\t\t\t\temptyConfig.outlineThickness = 0.0;\n\t\t\t\t//\n\t\t\t\t${F("center")} = ${L(O,"screenUV")};\n\t\t\t\t${V("finalColor")}  = ${V()}(0.0);\n                ${w("finalAlpha")}  = 0.0;\n                ${E?`        \n                ${M("qaAutomationID")}  = ${X("center.r")};\n                if (qaAutomationID > 0) {\n                    ${M("qaAutomationGeomID")} = ${X("center.w")};\n                    finalAlpha = 1.0;\n                    if (qaAutomationGeomID == 0) {\n                        finalColor = ${V()}(0.0,0.61,0.61);\n                    } else if (qaAutomationGeomID < 3) {\n                        if (qaAutomationGeomID == 2) {\n                            finalColor = ${V()}(1.0, 0.0, 0.0);\n                        } else {\n                            finalColor = ${V()}(0.0, 0.78, 0.78);\n                        }\n                    } else {\n                        finalColor = ${V()}(0.0,0.78,0.78);\n                    }\n                }\n            `:`\n                \n\t\t\t\t${N("forceHaloOn")}  = false;\n\t\t\t\t${N("forceOutlineOn")}  = false;\n\t\t\t\t${N("forceBasePostProOff")}  = false;\n\t\t\t\t${N("isMarker")}  = false;\n\t\t\t\t${N("isEdge")}  = false;\n                ${k?`\n\t\t\t\t\tforceBasePostProOff = ${X("center.w")} == 4 || ${X("center.w")} == 2;\n\t\t\t\t\tforceOutlineOn = forceBasePostProOff && center.b > 0.5;\n\t\t\t\t\t// Find point\n\t\t\t\t\tif (!forceBasePostProOff) {\n\t\t\t\t\t\tforceBasePostProOff = ${P("DoPoliteLineic","b",[D("center"),x("forceOutlineOn"),x("forceHaloOn"),x("isMarker"),g("4"),y("screenUV")])};\n\t\t\t\t\t}\n\t\t\t\t\t// Find edge\n\t\t\t\t\tif (!forceBasePostProOff) {\n\t\t\t\t\t\tforceBasePostProOff = ${P("DoPoliteLineic","b",[D("center"),D("forceOutlineOn"),D("forceHaloOn"),D("isEdge"),g("2"),y("screenUV")])};\t\t\t\t\t\t\n\t\t\t\t\t}\n                    `:l}\n                \n                ${s.declareVariable({name:"config",type:"highlightConfig",custom:!0})} = ${P("GetHighlightConfig","highlightConfig",[h("center.r")])};\t\t\t\t\t\t\t\n\t\t\t\t// Outline detection\n\t\t\t\t${w("isOutline")}  = 8.0;\n\t\t\t\tif (config.outlineAlpha > -0.5 && !forceBasePostProOff) {\t\t\t\t\t\t\n\t\t\t\t\tisOutline = ${P("CheckIfOutlines","f",[_("center"),y("screenUV"),f("highlightConfig","config",!0)])};\t\n\t\t\t\t}\n\t\t\t\tif (forceOutlineOn && config.outlineAlpha > -0.5) {\n                    finalColor = config.lineicOutlineColor.rgb;\n                    finalAlpha = ${P("GetLineicAlpha","f",[v("isEdge")])};\n\t\t\t\t} else if (isOutline < outlineCheck) {\n\t\t\t\t\t// outline\n                    finalColor = config.outlineColor.rgb;\n                    finalAlpha = config.outlineAlpha;\n\t\t\t\t} else {\n\t\t\t\t\t//  halo\n\t\t\t\t\tif (center.r == 0.0 && !forceBasePostProOff) {\t\t\t\n                        ${F("haloData")}  = ${P("ComputeHaloColor","v4",[y("screenUV")])};\n\t\t\t\t\t\tfinalColor = haloData.rgb;\n\t\t\t\t\t\tfinalAlpha = haloData.a;\n\t\t\t\t\t} else if (forceHaloOn) {\n                        ${M("index")} = ${X("center.r")};\n\t\t\t\t\t\t${F("lineicHaloData")}  = ${P("GetLineicHaloData","v4",[g("index")])};\n\t\t\t\t\t\tfinalColor = lineicHaloData.rgb;\n\t\t\t\t\t\tfinalAlpha = lineicHaloData.a;\n\t\t\t\t\t} else if (config.colorIntensity.x > 1e-6 || config.colorIntensity.y > 1e-6) {\n\t\t\t\t\t\tif (config.colorIntensity.y > -0.5) {\n                            // polite\n\t\t\t\t\t\t\tfinalAlpha = ${P("ComputePoliteColorAlpha","f",[f("highlightConfig","config",!0),v("isMarker"),v("isEdge"),v("center.b > 0.5")])};\n\t\t\t\t\t\t\tfinalColor = center.g * config.color.rgb;\n\t\t\t\t\t\t} else { \n                            // halo\t\t\n\t\t\t\t\t\t\tfinalAlpha = ${P("ComputeHaloColorAlpha","f",[f("highlightConfig","config",!0),h("center.g")])};\n\t\t\t\t\t\t\tfinalColor = config.color.rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n            `}\n                \n\t\t\t\t// alpha blend\n\t\t\t\tfinalAlpha = min(finalAlpha, 1.0);            \n                ${w("fetchedFactor")} = (1.0 - finalAlpha) * fetched.a;\n\t\t\t\t${w("alpha")}  = finalAlpha + fetchedFactor;\n\t\t\t\t${H} = ${F()}((finalAlpha * finalColor + fetchedFactor * fetched.rgb)/max(alpha,1e-12), alpha);\n            }\n        `}},"Highlight");return{FinalBlending:new r(G,B,O),FinalMobileBlending:new r(G,B,E)}}),define("DS/ShaderBuilders/PostPro/SMAAShaderBuilders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PostPro/PostProUniformHandler","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PostPro/PostProContext","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=i.FunctionHandler,m=n=>a.addUniform(n),$=n=>{var e={uniformName:n};return a.getUniform(e)},c=n=>l.parameterF(n),p=n=>l.parameterV2(n),d=(n,e,t)=>u.declareFunction(n,e,t),f=(n,e,t)=>u.callFunction(n,e,t),h=(n=null,e=0)=>{var t={name:n,size:e};return s.bool(t)},g=(n=null,e=0)=>{var t={name:n,size:e};return s.int(t)},v=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.int(t)},S=(n=null,e=0)=>{var t={name:n,size:e};return s.float(t)},x=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.float(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return s.vec2(t)},_=(n=null,e=0)=>{var t={name:n,size:e,constant:!0};return s.vec2(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)},D=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},C=n=>o.addVarying(n),P=n=>o.getVarying(n,o.ShaderStages.in),N=n=>o.getVarying(n,o.ShaderStages.out),M=(n,e)=>u.sample2DTexture(n,e);class b extends e{constructor(){super(),this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight)}clone(){var n=new b;return n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}class w extends e{constructor(){super(),this.areaTex=null,this.searchTex=null,this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight),e.loadTexture(t,r.areaTex,this.areaTex),e.loadTexture(t,r.searchTex,this.searchTex)}clone(){var n=new w;return n.areaTex=this.areaTex,n.searchTex=this.searchTex,n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}class U extends e{constructor(){super(1),this.screenWidth=800,this.screenHeight=600}loadUniforms(n,e,t,r,a,o,i){super.loadUniforms(n,e,t,r,a,o,i),t.uniform1f(r.screenWidth,this.screenWidth),t.uniform1f(r.screenHeight,this.screenHeight)}clone(){var n=new U;return n.screenHeight=this.screenHeight,n.screenWidth=this.screenWidth,n}}return{EdgeDetection:new r(new t(function(e,t){t.customDefines;let r=`\n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            ${C({varyingName:"offset",varyingType:"v4v",size:3})}\n     \n            ${m({uniformName:"screenHeight",uniformType:"f"})}\n            ${m({uniformName:"screenWidth",uniformType:"f"})}\n\n            void main() {\n                ${y("SMAA_PIXEL_SIZE")} = ${y()}(1.0 / ${$("screenWidth")}, 1.0 / ${$("screenHeight")});\n\n                ${N("vUv")} = uv.xy;\n\n                ${N("offset")}[0] = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${D()}(-1.0, 0.0, 0.0, 1.0);\n                ${N("offset")}[1] = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${D()}( 1.0, 0.0, 0.0, -1.0);\n                ${N("offset")}[2] = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${D()}(-2.0, 0.0, 0.0, -2.0);\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const a=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            ${C({varyingName:"offset",varyingType:"v4v",size:3})}\n\n            \n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput"})}\n\n            ${x("SMAA_THRESHOLD")} = 0.1;\n\n            void main() {\n                // varying storage\n                ${y("SMAA_edges_uv")} = ${P("vUv")};\n                ${D("lumaUVs")} = ${P("offset")}[0];\n                ${D("delta1UVs")} = ${P("offset")}[1];\n                ${D("delta2UVs")} = ${P("offset")}[2];\n\n                // Calculate the threshold:\n                ${y("threshold")} = ${y()}(SMAA_THRESHOLD, SMAA_THRESHOLD);\n\n                // Calculate lumas:\n                ${T("weights")} = ${T()}(0.2126,0.7152,0.0722);\n                ${S("L")} = dot(${M("tScene","SMAA_edges_uv")}.rgb, weights);\n                ${S("Lleft")}  = dot(${M("tScene","lumaUVs.xy")}.rgb, weights);\n                ${S("Ltop")}  = dot(${M("tScene","lumaUVs.zw")}.rgb, weights);\n\n                // We do the usual threshold:\n                ${y("delta1")};\n                delta1  = abs(L - ${y()}(Lleft, Ltop));\n                ${y("edges")}  = step(threshold, delta1);\n                \n                // Calculate right and bottom deltas:\n                ${y("delta2")};\n                ${S("Lright")} = dot(${M("tScene","delta1UVs.xy")}.rgb, weights);\n                ${S("Lbottom")} = dot(${M("tScene","delta1UVs.zw")}.rgb, weights);\n                delta2 = abs(L - ${y()}(Lright, Lbottom));\n\n                // Calculate the maximum delta in the direct neighborhood:\n                ${y("maxDelta")}   = max(delta1, delta2);\n                maxDelta       = max(maxDelta.xx, maxDelta.yy);\n\n                // Calculate left-left and top-top deltas:\n                ${S("Lleftleft")}  = dot(${M("tScene","delta2UVs.xy")}.rgb, weights);\n                ${S("Ltoptop")}    = dot(${M("tScene","delta2UVs.zw")}.rgb, weights);\n                delta2       = abs(${y()}(Lleft, Ltop) - ${y()}(Lleftleft, Ltoptop));\n\n                // Calculate the final maximum delta:\n                maxDelta = max(maxDelta.xy, delta2.xy);\n\n                \n                // Each edge with a delta in luma of less than 50% of the maximum luma\n                // surrounding this pixel is discarded. This allows to eliminate spurious\n                // crossing edges, and is based on the fact that, if there is too much\n                // contrast in a direction, that will hide contrast in the other\n                // neighbors.\n                // This is done after the discard intentionally as this situation doesn't\n                // happen too frequently (but it's important to do as it prevents some\n                // edges from going undetected).\n                 \n\n                edges *= step(0.5 * maxDelta, delta1.xy);\n\n                ${a} = ${D()}(edges.x, edges.y, 0.0, 1.0);\n            }\n        `}},"SMAA_Edge_Detection"),b,{}),BlendingWeights:new r(new t(function(e,t){t.customDefines;let r=`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            ${C({varyingName:"offset",varyingType:"v4"})}\n    \n            ${m({uniformName:"screenHeight",uniformType:"f"})}\n            ${m({uniformName:"screenWidth",uniformType:"f"})}\n\n\n            ${x("SMAA_MAX_SEARCH_STEPS")} = 8.0;\n\n            void main() {\n\n                ${y("SMAA_PIXEL_SIZE")}  = ${y()}(1.0/${$("screenWidth")}, 1.0/${$("screenHeight")});\n\n                ${N("vUv")} = uv.xy;\n\n                // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n                ${N("offset")} = uv.xyxy + SMAA_PIXEL_SIZE.xyxy * ${D()}(-0.25, 0.125,  1.25, 0.125);\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n\n            }\n        `;const a="tEdges",i=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            ${C({varyingName:"vUv",varyingType:"v2"})}\n            ${y("SMAA_weights_uv")};\n            ${C({varyingName:"offset",varyingType:"v4"})}\n\n            \n            ${m({uniformName:"tEdges",uniformType:"t2",locationName:"tInput"})}\n            ${m({uniformName:"searchTex",uniformType:"t2"})}\n            ${m({uniformName:"areaTex",uniformType:"t2"})}  \n            ${m({uniformName:"screenHeight",uniformType:"f"})}\n            ${m({uniformName:"screenWidth",uniformType:"f"})}\n\n            ${y("SMAA_PIXEL_SIZE")} ;\n\n            ${v("SMAA_FORCE_DIAGONAL_DETECTION")}    = 1;\n            ${v("SMAA_FORCE_CORNER_DETECTION")}      = 1;\n            ${v("SMAA_AREATEX_MAX_DISTANCE")}        = 16;\n            ${v("SMAA_AREATEX_MAX_DISTANCE_DIAG")}   = 20;\n            ${x("SMAA_AREATEX_SUBTEX_SIZE")}        = 1.0 / 7.0;\n            ${_("SMAA_AREATEX_PIXEL_SIZE")}         = ${y()}(1.0 / 160.0, 1.0/ 560.0);\n\n            //HIGH SMAA parameters\n            ${x("SMAA_THRESHOLD")}                = 0.1;\n            ${v("SMAA_MAX_SEARCH_STEPS")}          = 16;\n            ${v("SMAA_MAX_SEARCH_STEPS_DIAG")}     = 8;\n            ${v("SMAA_CORNER_ROUNDING")}           = 25;\n\n            ${_("positiveY")} = ${y()}(0.0, 1.0);\n            ${_("positiveX")} = ${y()}(1.0, 0.0);\n            ${_("negativeY")} = ${y()}(0.0, -1.0);\n            ${_("negativeX")} = ${y()}(-1.0, 0.0);\n\n            // Horizontal/Vertical Search Functions\n            \n            // This allows to determine how much length should we add in the last step\n            // of the searches. It takes the bilinearly interpolated edge (see\n            // @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and\n            // crossing edges are active.\n            \n            ${d("SMAASearchLength","f",[p("e"),c("bias"),c("scale")])} {\n                ${y("coord")} = e;\n                coord.r = bias + e.r * scale;\n                coord.g = 1.0 - e.y;\n                return  255.0*${M("searchTex","coord")}.r;\n            }\n\n            \n            // Horizontal/vertical search functions for the 2nd pass.\n            \n            ${d("SMAASearchXLeft","f",[])} {\n\n                ${y("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.25 * negativeX + 0.125 * positiveY);\n\n                ${S("end")} = (SMAA_weights_uv.x - 0.25 * SMAA_PIXEL_SIZE.x) - 2.0 * SMAA_PIXEL_SIZE.x * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${y("e")} = ${y()}(0.0, 1.0);\n\n                for(${g("i")}= 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.x > end) && (e.g > 0.8281) && (e.r == 0.0)){\n                        e = ${M(a,"texcoord")}.rg;\n                        texcoord.x -= 2.0 * SMAA_PIXEL_SIZE.x;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.x += 3.25 * SMAA_PIXEL_SIZE.x;\n                texcoord.x -= SMAA_PIXEL_SIZE.x * ${f("SMAASearchLength","f",[p("e"),c("0.0"),c("0.5")])};\n\n                return texcoord.x  ;\n            }\n\n            ${d("SMAASearchXRight","f",[])} {\n\n                ${y("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (1.25 * positiveX + 0.125 * positiveY);\n\n                ${S("end")}  = (SMAA_weights_uv.x + 1.25 * SMAA_PIXEL_SIZE.x) + 2.0 * SMAA_PIXEL_SIZE.x * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${y("e")} = ${y()}(0.0, 1.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.x < end) && (e.g > 0.8281) && (e.r == 0.0)){\n                        e = ${M(a,"texcoord")}.rg;\n                        texcoord.x += 2.0 * SMAA_PIXEL_SIZE.x;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.x -= 3.25 * SMAA_PIXEL_SIZE.x;\n                texcoord.x += SMAA_PIXEL_SIZE.x * ${f("SMAASearchLength","f",[p("e"),c("0.5"),c("0.5")])};\n                return texcoord.x;\n            }\n\n            ${d("SMAASearchYDown","f",[])} {\n\n                ${y("texcoord")}  = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.125 * negativeX + 1.25 * negativeY);\n\n                ${S("end")}  = (SMAA_weights_uv.y - 1.25 * SMAA_PIXEL_SIZE.y) - 2.0 * SMAA_PIXEL_SIZE.y * ${S()}(SMAA_MAX_SEARCH_STEPS);\n\n                ${y("e")} = ${y()}(1.0, 0.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.y > end) && (e.r > 0.8281) && (e.g == 0.0)){\n                        e = ${M(a,"texcoord")}.rg;\n                        texcoord.y -= 2.0 * SMAA_PIXEL_SIZE.y;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.y += 1.25 * SMAA_PIXEL_SIZE.y;\n                texcoord.y -= SMAA_PIXEL_SIZE.y * ${f("SMAASearchLength","f",[p("e.gr"),c("0.5"),c("0.5")])};\n                return texcoord.y ;\n            }\n\n            ${d("SMAASearchYUp","f",[])} {\n                ${y("texcoord")} = SMAA_weights_uv + SMAA_PIXEL_SIZE * (0.125 * negativeX + 0.25 * positiveY);\n\n                ${S("end")} = (SMAA_weights_uv.y + 0.25 * SMAA_PIXEL_SIZE.y) + 2.0 * SMAA_PIXEL_SIZE.y * ${S()}(SMAA_MAX_SEARCH_STEPS);\n                ${y("e")} = ${y()}(1.0, 0.0);\n\n                for(${g("i")} = 0;i<SMAA_MAX_SEARCH_STEPS;i++){\n                    if((texcoord.y < end) && (e.r > 0.8281) && (e.g == 0.0)){\n                        e = ${M(a,"texcoord")}.rg;\n                        texcoord.y += 2.0 * SMAA_PIXEL_SIZE.y;\n                    }else {\n                        break;\n                    }\n                }\n\n                texcoord.y -= 3.25 * SMAA_PIXEL_SIZE.y;\n                texcoord.y += SMAA_PIXEL_SIZE.y * ${f("SMAASearchLength","f",[p("e.gr"),c("0.0"),c("0.5")])};\n                return texcoord.y ;\n            }\n\n            ${d("_round","v2",[p("inVec")])} {\n                ${y("absBiasInVec")} = abs(inVec) + 0.5;\n               return floor(absBiasInVec) * sign(inVec);\n            }\n\n            \n            // Ok, we have the distance and both crossing edges. So, what are the areas\n            // at each side of current edge?\n            \n            ${d("SMAAArea","v2",[p("dist"),c("e1"),c("e2")])} {\n                ${y("inVec")} = 4.0 * ${y()}(e1, e2);\n                ${y("texcoord")} = ${S()}(SMAA_AREATEX_MAX_DISTANCE) * ${f("_round","v2",[p("inVec")])}  + dist;\n\n                texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\n                texcoord.y = 1.0-texcoord.y;\n                return ${M("areaTex","texcoord")}.rg;\n            }\n\n            // Corner Detection Functions\n            ${d("SMAADetectHorizontalCornerPattern","v2",[p("weights"),p("texcoord"),p("d")])} {\n                ${y("res")} = weights;\n               if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1 ){\n                   ${D("coords")} = ${D()}(d.x, 0.0, d.y, 0.0)*SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;\n                   ${y("e")};\n                   e.r = ${M(a,"coords.xy + negativeY")}.r;\n                   ${h("left")} = abs(d.x) < abs(d.y);\n                   e.g = ${M(a,"coords.xy + 2.0 * positiveY")}.r;\n                   if (left) res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);\n\n                   e.r = ${M(a,"coords.zw + negativeY + positiveX")}.r;\n                   e.g = ${M(a,"coords.zw + 2.0 * positiveY + positiveX")}.r;\n                   if (!left) res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);\n               }\n               return res;\n            }\n\n\n            ${d("SMAADetectVerticalCornerPattern","v2",[p("weights"),p("texcoord"),p("d")])} {\n                ${y("res")} = weights;\n               if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1){\n                   ${D("coords")} = ${D()}(0.0, d.x, 0.0, d.y)*SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;\n                   ${y("e")};\n                   e.r = ${M(a,"coords.xy + positiveX")}.g;\n                   ${h("left")} = abs(d.x) < abs(d.y);\n                   e.g = ${M(a,"coords.xy + 2.0 * negativeX")}.g;\n                   if (left) res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);\n\n                   e.r = ${M(a,"coords.zw + negativeY + positiveX")}.g;\n                   e.g = ${M(a,"coords.zw + 2.0 * negativeX + negativeY")}.g;\n                   if (!left) res *= clamp(${S()}(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);\n            \t}\n                return res;\n            }\n\n            \n            // Similar to SMAAArea, this calculates the area corresponding to a certain\n            // diagonal distance and crossing edges 'e'.\n            \n            ${d("SMAAAreaDiag","v2",[p("dist"),p("e")])} {\n               ${y("texcoord")} = ${S()}(SMAA_AREATEX_MAX_DISTANCE_DIAG) * e + dist;\n\n                // We do a scale and bias for mapping to texel space:\n               texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\n\n                // Diagonal areas are on the second half of the texture:\n               texcoord.x += 0.5;\n               texcoord.y = 1.0 - texcoord.y;\n\n               return ${M("areaTex","texcoord")}.rg;\n            }\n\n            \n            // These functions allows to perform diagonal pattern searches.\n            \n            ${d("SMAASearchDiag1","f",[p("texcoord"),p("dir"),c("c")])} {\n                ${y("coord")} = texcoord;\n                coord += dir * SMAA_PIXEL_SIZE;\n               ${y("e")} = ${y()}(0.0, 0.0);\n               ${g("j")};\n\n               for (${g("i")} = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {\n                   j = i;\n                   e = ${M(a,"coord")}.rg;\n                   if (dot(e, ${y()}(1.0, 1.0)) < 1.9) break;\n                   coord += dir * SMAA_PIXEL_SIZE;\n               }\n\n               return ${S()}(j) + ${S()}(e.g > 0.9) * c;\n            }\n\n            ${d("SMAASearchDiag2","f",[p("texcoord"),p("dir"),c("c")])} {\n                ${y("coord")} = texcoord;\n                coord += dir * SMAA_PIXEL_SIZE;\n               ${y("e")} = ${y()}(0.0, 0.0);\n               ${g("j")};\n\n               for (${g("i")} = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {\n                   j = i;\n                   e.g = ${M(a,"coord")}.g;\n                   e.r = ${M(a,"coord + SMAA_PIXEL_SIZE * positiveX")}.r;\n                   if (dot(e, ${y()}(1.0, 1.0)) < 1.9) break;\n                   coord += dir * SMAA_PIXEL_SIZE;\n               }\n\n               return ${S()}(j) + ${S()}(e.g > 0.9) * c;\n            }\n\n            \n            // This searches for diagonal patterns and returns the corresponding weights.\n            \n            ${d("SMAACalculateDiagWeights","v2",[p("texcoord"),p("e")])} {\n                ${y()} weights = ${y()}(0.0, 0.0);\n\n                ${y()} d;\n                d.x = 0.0;\n                if (e.r > 0.0) {\n                    d.x = ${f("SMAASearchDiag1","f",[p("texcoord"),p(`${y()}(-1.0, -1.0)`),c("1.0")])};\n                }\n                d.y = ${f("SMAASearchDiag1","f",[p("texcoord"),p(`${y()}(1.0, 1.0)`),c("0.0")])};\n\n                if (d.r + d.g > 2.0) {\n                    ${D("coords")} = ${D()}(-d.r, -d.r, d.g, d.g) * SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;\n\n                    ${D("c")};\n\n                    c.x = ${M(a,"coords.xy + negativeX * SMAA_PIXEL_SIZE")}.g;\n                    c.y = ${M(a,"coords.xy")}.r;\n                    c.z = ${M(a,"coords.zw + positiveX * SMAA_PIXEL_SIZE")}.g;\n                    c.w = ${M(a,"coords.zw + (positiveX + positiveY) * SMAA_PIXEL_SIZE")}.r;\n\n                    ${y("e2")} = 2.0 * c.xz + c.yw;\n                    ${S("t")} = ${S()}(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;\n                    e2 *= step(d.rg, ${y()}(t, t));\n\n                    weights += ${f("SMAAAreaDiag","v2",[p("d"),p("e2")])};\n\n                }\n\n                d.x = ${f("SMAASearchDiag2","f",[p("texcoord"),p(`${y()}(-1.0, 1.0)`),c("0.0")])};\n                ${S("right")}  = ${M(a,"texcoord + positiveX * SMAA_PIXEL_SIZE")}.r;\n                d.y = 0.0;\n                if (right > 0.0) {\n                    d.y = ${f("SMAASearchDiag2","f",[p("texcoord"),p(`${y()}(1.0, -1.0)`),c("1.0")])};\n                }\n\n                if (d.r + d.g > 2.0) { \n                    ${D("coords")} = vec4(-d.r, d.r, d.g, -d.g)* SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;\n\n                    ${D("c")};\n                    c.x  = ${M(a,"coords.xy  + negativeX * SMAA_PIXEL_SIZE")}.g;\n                    c.y  = ${M(a,"coords.xy  + positiveY * SMAA_PIXEL_SIZE")}.r;\n                    ${y("zw")} = ${M(a,"coords.zw  + positiveX * SMAA_PIXEL_SIZE")}.gr;\n                    c.z = zw.x;\n                    c.w = zw.y;\n                    ${y("e2")} = 2.0 * c.xz + c.yw;\n                    ${S("t")} = ${S()}(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;\n                    e2 *= step(d.rg, ${y()}(t, t));\n\n                    weights += ${f("SMAAAreaDiag","v2",[p("d"),p("e2")])}.gr;\n                }\n\n                return weights;\n            }\n\n\n            void main() {\n                SMAA_weights_uv = ${P("vUv")};\n                SMAA_PIXEL_SIZE = ${y()}(1.0/${$("screenWidth")}, 1.0/${$("screenHeight")});\n            \n            \t${y("pixcoord")}  = SMAA_weights_uv / SMAA_PIXEL_SIZE;\n\n                ${D("weights")}  = ${D()}(0.0, 0.0, 0.0, 0.0);\n\n                ${y("e")} = ${M(a,"SMAA_weights_uv")}.rg;\n\n                if (e.g > 0.0) { // Edge at north\n                    ${y("weiRG")};\n                    if (SMAA_MAX_SEARCH_STEPS_DIAG > 0 || SMAA_FORCE_DIAGONAL_DETECTION == 1) {\n                        // Diagonals have both north and west edges, so searching for them in\n                        // one of the boundaries is enough.\n                        weiRG = ${f("SMAACalculateDiagWeights","v2",[p("SMAA_weights_uv"),p("e")])};\n                        weights.r = weiRG.r;\n                        weights.g = weiRG.g;\n                    }\n\n                    // We give priority to diagonals, so if we find a diagonal we skip\n                    // horizontal/vertical processing.\n                    if (dot(weights.rg, ${y()}(1.0, 1.0)) == 0.0) {\n\n                        // Find the distance to the left:\n                        ${y("d")};\n                        ${y("coords")} ;\n                        coords.x = ${f("SMAASearchXLeft",null,[])};\n                        coords.y = SMAA_weights_uv.y + 0.25 * SMAA_PIXEL_SIZE.y ;\n                        d.x = coords.x;\n\n                        ${S("e1")}  = ${M(a,"coords")}.r;\n\n                        // Find the distance to the right:\n                        coords.x = ${f("SMAASearchXRight",null,[])};\n                        d.y = coords.x;\n\n                        // We want the distances to be in pixel units (doing this here allow to\n                        // better interleave arithmetic and memory accesses):\n                        d =  (d / SMAA_PIXEL_SIZE.x) - pixcoord.x ;\n\n                        // SMAAArea below needs a sqrt, as the areas texture is compressed quadratically:\n                        ${y("sqrt_d")}  = sqrt(abs(d));\n\n                        // Fetch the right crossing edges:\n                        ${S("e2")} = ${M(a,"coords + positiveX * SMAA_PIXEL_SIZE")}.r;\n\n\n                        // Ok, we know how this pattern looks like, now it is time for getting\n                        // the actual area:\n                        weiRG = ${f("SMAAArea","v2",[p("sqrt_d"),p("e1"),p("e2")])};\n                        weights.r = weiRG.r;\n                        weights.g = weiRG.g;\n\n                        // Fix corners:\n                        ${y("cornerPatternH")} = ${f("SMAADetectHorizontalCornerPattern","v2",[p("weights.rg"),p("SMAA_weights_uv"),p("d")])};\n                        weights.r = cornerPatternH.x;\n                        weights.g = cornerPatternH.y;\n\n                   } else { \n                        // Skip vertical processing.\n                        e.r = 0.0;\n                   }\n\n               }\n\n               // Edge at west\n               if (e.r > 0.0) { \n                   ${y("d")};\n\n                    // Find the distance to the top:\n                   ${y("coords")} ;\n                   coords.y = ${f("SMAASearchYUp",null,[])};\n                   coords.x = ${P("offset")}.x;\n                   d.x = coords.y;\n\n                    // Fetch the top crossing edges:\n                   ${S("e1")}  =  ${M(a,"coords")}.g;\n\n                    // Find the distance to the bottom:\n                   coords.y = ${f("SMAASearchYDown",null,[])};\n                   d.y = coords.y;\n\n                    // We want the distances to be in pixel units:\n                   d = d / SMAA_PIXEL_SIZE.y - pixcoord.y;\n\n                    // SMAAArea below needs a sqrt, as the areas texture is compressed quadratically:\n                   ${y("sqrt_d")}  = sqrt(abs(d));\n\n                    // Fetch the bottom crossing edges:\n                   ${S("e2")} =  ${M(a,"coords + positiveY * SMAA_PIXEL_SIZE")}.g;\n\n                    // Get the area for this direction:\n                    ${y("weiBA")} = ${f("SMAAArea","v2",[p("sqrt_d"),p("e1"),p("e2")])};\n                   weights.b = weiBA.x;\n                   weights.a = weiBA.y;\n\n                    // Fix corners:\n                   ${y("cornerPatternV")} = ${f("SMAADetectVerticalCornerPattern","v2",[p("weights.ba"),p("SMAA_weights_uv"),p("d")])};\n                   weights.b = cornerPatternV.x;\n                   weights.a = cornerPatternV.y;\n\n               }\n               ${i} = weights;\n\n            }\n        `}},"SMAA_Blending_Weights"),w,{}),FinalBlending:new r(new t(function(e,t){t.customDefines;let r=`\n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n            void main() {\n\n                ${N("vUv")} = uv.xy;\n\n                ${n._DefaultShaderChunk.model_view_projection_transformation_vertex(t)}\n            }\n\n        `;const a=o.getShaderOutput("out0");return{vertexShader:r,fragmentShader:`\n            \n            ${C({varyingName:"vUv",varyingType:"v2"})}\n\n     \n            ${m({uniformName:"screenHeight",uniformType:"f"})}\n            ${m({uniformName:"screenWidth",uniformType:"f"})}\n            \n            ${m({uniformName:"tScene",uniformType:"t2",locationName:"tInput0"})}\n            ${m({uniformName:"tWeights",uniformType:"t2",locationName:"tInput1"})}\n\n            \n            ${_("positiveY")} = ${y()}(0.0, 1.0);\n            ${_("positiveX")} = ${y()}(1.0, 0.0);\n            ${_("negativeY")} = ${y()}(0.0, -1.0);\n            ${_("negativeX")} = ${y()}(-1.0, 0.0);\n\n            void main() {\n                ${y("SMAA_PIXEL_SIZE")} = ${y()}(1.0 / ${$("screenWidth")}, 1.0 / ${$("screenHeight")});\n                // varying storage\n                ${y("SMAA_blend_uv")} = ${P("vUv")};\n\n                // Fetch the blending weights for current pixel:\n                ${D("topLeft")}  = ${M("tWeights","SMAA_blend_uv")};\n                ${S("bottom")}  = ${M("tWeights","SMAA_blend_uv.xy + SMAA_PIXEL_SIZE.xy * negativeY")}.g;\n                ${S("right")}  = ${M("tWeights","SMAA_blend_uv.xy + SMAA_PIXEL_SIZE.xy * positiveX")}.a;\n                ${D("a")} = ${D()}(topLeft.r, bottom, topLeft.b, right);\n    \n                // Up to 4 lines can be crossing a pixel (one in each edge). So, we perform\n                // a weighted average, where the weight of each line is 'a' cubed, which\n                // favors blending and works well in practice.\n                ${D("w")} = a * a * a;\n    \n                // There is some blending weight with a value greater than 0.0?\n                ${S("sum")} = dot(w, ${D()}(1.0));\n                ${D("CurrentColor")} = ${M("tScene","SMAA_blend_uv")};\n                if (sum > 0.0) {\n                    ${D("color")}  = ${D()}(0.0);\n    \n                    // Add the contributions of the possible 4 lines that can cross this pixel:\n                    ${D("ColorLeft")} = ${M("tScene","SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * negativeX")};\n                    ${D("ColorTop")} = ${M("tScene","SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * positiveY")};\n                    ${D("ColorRight")} = ${M("tScene","SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * positiveX")};\n                    ${D("ColorBottom")} = ${M("tScene","SMAA_blend_uv + SMAA_PIXEL_SIZE.xy * negativeY")};\n    \n                    color += mix(CurrentColor, ColorTop, a.r) * w.r;\n                    color += mix(CurrentColor, ColorBottom, a.g) * w.g;\n                    color += mix(CurrentColor, ColorLeft, a.b) * w.b;\n                    color += mix(CurrentColor, ColorRight, a.a) * w.a;\n    \n                    // Normalize the resulting color and we are finished!\n                    ${a} = color / sum;\n                } else {\n                    ${a} = CurrentColor;\n                }\n            }\n        `}},"SMAA_Blending"),U,{})}}),define("DS/ShaderBuilders/Commons/DefaultShaders",["DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r){"use strict";const a=n.ParameterUtils,o=n.FunctionHandler,i=()=>r.dereference(),s=(n,e,t=!1)=>a.parameter(n,e,t),l=n=>a.parameterI(n),u=n=>a.parameterV2(n),m=n=>a.parameterV3(n),$=n=>a.parameterInOutV3(n),c=n=>a.parameterRefV3(n),p=n=>a.parameterV4(n),d=n=>a.parameterT2(n),f=(n,e,t)=>o.declareFunction(n,e,t),h=(n,e,t)=>o.callFunction(n,e,t),g=n=>e.addUniform(n),v=n=>{var t={uniformName:n};return e.getUniform(t)},S=n=>{var t={uniformName:n};return e.getObjectUniform(t)},x=n=>t.addVarying(n),y=n=>t.getVarying(n,t.ShaderStages.in),_=n=>t.getVarying(n,t.ShaderStages.out),T=(n=null)=>{var e={name:n};return r.float(e)},D=(n=null)=>{var e={name:n};return r.vec2(e)},C=(n=null)=>{var e={name:n};return r.vec3(e)},P=(n=null)=>{var e={name:n};return r.vec4(e)},N=(n=null)=>{var e={name:n};return r.mat4(e)},M="true"===localStorage.getItem("__WebVisu_LinearFilter_IBL__");function b(n,e){const t=(n,e)=>h("texture2DFromRGBE","v4",[d(n),u(e)]),r=(n,e,t,r)=>h("get2DBilinearFromRGBEwBOXUV","v2",[u(n),u(e),u(t),u(r)]);return`\n            ${f("texture2DFromRGBE","v4",[d("textureSampler"),u("uv")])}{\n\n                ${P("texelRGBE")} = ${o.sample2DTexture("textureSampler","uv")};\n\n                ${T("exponent")} = pow(2.0, 255.0 * texelRGBE.w - 128.0);\n                return ${P()}(texelRGBE.xyz * exponent, 1.0);\n            }\n\n            ${f("texture2DBilinearFromRGBE","v4",[d("textureSampler"),u("uv"),u("textureSize"),u("texelSize")])} {\n\n                ${D("st")} = uv * textureSize - 0.5;\n                ${D("iuv")} = (floor(st) + ${D()}(0.5)) * texelSize;\n\n                ${P("tl")} = ${t("textureSampler","iuv")};\n                ${M?"\n                    return tl;\n                    ":`\n                    ${D("fuv")} = fract(st);\n                    ${P("tr")} = ${t("textureSampler",`iuv + ${D()}(texelSize.x, 0.0)`)};\n                    ${P("bl")} = ${t("textureSampler",`iuv + ${D()}(0.0, texelSize.y)`)};\n                    ${P("br")} = ${t("textureSampler",`iuv + ${D()}(texelSize.x, texelSize.y)`)};\n    \n                    ${P("tA")} = mix(tl, tr, fuv.x);\n                    ${P("tB")} = mix(bl, br, fuv.x);\n    \n                    return mix(tA, tB, fuv.y);\n                    `}\n            }\n\n            ${f("get2DBilinearFromRGBEwBOXUV","v2",[u("iuv"),u("offset"),u("factor"),u("start")])} {\n\n                //float x = mod(iuv.x + offset.x, factor.x) + start.x;\n                ${T("modulo")} = iuv.x + offset.x - factor.x * floor((iuv.x + offset.x)/factor.x);\n                ${T("x")} = modulo + start.x;\n                ${T("y")} = iuv.y + offset.y;\n                return ${D()}(x,y);\n            }\n\n            ${f("texture2DBilinearFromRGBEwBox","v4",[d("textureSampler"),p("uvBox"),u("uv"),u("textureSize"),u("texelSize")])} {\n            \n                ${e?`${D("start")} = uvBox.xy;\n                    ${D("factor")} = uvBox.zw;\n                    ${D("fetchUVToUse")} = factor* uv + start;\n\n                    ${D("st")} = fetchUVToUse * textureSize - 0.5;\n                    ${D("iuv")} = (floor(st) + ${D()}(0.5)) * texelSize;\n\n                    ${P("tl")} = ${t("textureSampler",`${r("iuv",`${D()}(0.0, 0.0)`,"factor","start")}`)};\n\n                    ${M?"\n                        return tl;\n                        ":`\n                        ${D("fuv")} = fract(st);\n                        ${P("tr")} = ${t("textureSampler",`${r("iuv",`${D()}(texelSize.x, 0.0)`,"factor","start")}`)};\n                        ${P("bl")} = ${t("textureSampler",`${r("iuv",`${D()}(0.0, texelSize.y)`,"factor","start")}`)};\n                        ${P("br")} = ${t("textureSampler",`${r("iuv",`${D()}(texelSize.x, texelSize.y)`,"factor","start")}`)};\n\n                        ${P("tA")} = mix(tl, tr, fuv.x);\n                        ${P("tB")} = mix(bl, br, fuv.x);\n    \n                        return mix(tA, tB, fuv.y);\n                        `}\n                    `:`\n                    return ${h("texture2DBilinearFromRGBE","v4",[d("textureSampler"),u("uvBox.xy"),u("textureSize"),u("texelSize")])};\n                    `}\n            }\n        `}var w=function(n){return`\n        ${g({uniformName:"mappingType",uniformType:"i"})}\n        ${g({uniformName:"mappingNormTransformation",uniformType:"m3"})}\n        ${g({uniformName:"mappingObjTransformation",uniformType:"m4"})}\n        ${g({uniformName:"mappingUVTransformation",uniformType:"m3"})}\n        ${g({uniformName:"mappingTransformSemantic",uniformType:"i"})}\n\n        ${f("mappingTranspose","m4",[s("m4","m")])} {\n            ${P("i0")} = m[0];\n            ${P("i1")} = m[1];\n            ${P("i2")} = m[2];\n            ${P("i3")} = m[3];\n            ${N("outMatrix")} = ${N()}(\n                ${P()}(i0.x, i1.x, i2.x, i3.x),\n                ${P()}(i0.y, i1.y, i2.y, i3.y),\n                ${P()}(i0.z, i1.z, i2.z, i3.z),\n                ${P()}(i0.w, i1.w, i2.w, i3.w)\n            );\n            return outMatrix;\n        }\n\n        ${f("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),l("mappType"),$("outTangent"),$("outBinormal")])} {\n        \n            ${D("outUV")} = inUV;\n            ${N("invMappingObjTransformation")} = ${h("mappingTranspose","m4",[s("m4",`${v("mappingObjTransformation")}`)])};\n            ${C("x")} = ${C()}(invMappingObjTransformation[0].xyz);\n            ${C("y")} =  ${C()}(invMappingObjTransformation[1].xyz);\n            ${C("z")} =  ${C()}(invMappingObjTransformation[2].xyz);\n            ${C("localpos")} = (${v("mappingObjTransformation")} * ${P()}(pos, 1.0)).xyz; \n            ${C("localnorm")} = (${v("mappingObjTransformation")} * ${P()}(norm, 0.0)).xyz;; \n\n            if (mappType == 1) {\n\n                outUV = localpos.xy;\n\n                ${i()}outTangent = x;\n                ${i()}outBinormal = y;\n\n            } else if (mappType == 2) {\n\n                ${T("radius3d")} = max(0.000001,length(localpos.xyz));\n                ${T("z_by_radius3d")} = localpos.z / radius3d;\n\n                ${T("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                }\n\n                ${T("phiMapping")} = asin(z_by_radius3d );\n                ${T("u")} =thetaMapping*radius3d;\n                ${T("v")} =phiMapping*radius3d;\n                outUV = ${D()}(u, v);\n\n                ${T("cos_theta")} = cos(thetaMapping);\n                ${T("sin_theta")} = sin(thetaMapping);\n                ${T("cos_phi")} = cos(phiMapping);\n                ${T("sin_phi")} = z_by_radius3d;\n\n                ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                ${i()}outBinormal = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;\n\n\n            } else if (mappType == 6) {\n\n                ${T("radius3d")}  = max(0.000001,length(localpos.xyz));\n                ${T("z_by_radius3d")}  = localpos.z / radius3d;\n\n                ${T("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                }\n\n                ${T("phiMapping")}    = asin(z_by_radius3d );\n                ${T("u")} =thetaMapping/3.14159;\n                ${T("v")} =phiMapping/3.14159;\n                outUV = ${D()}(u, v);\n                \n                ${T("cos_theta")}  = cos(thetaMapping);\n                ${T("sin_theta")}  = sin(thetaMapping);\n                ${T("cos_phi")}  = cos(phiMapping);\n                ${T("sin_phi")}  = z_by_radius3d;\n\n                ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                ${i()}outBinormal = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;\n\n            } else if (mappType == 3) {\n\n                ${C("absolute_normal")}  = abs(localnorm);\n                ${T("maxima_normal")}  = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));\n\t\t\t\t\n\t\t\t\t${n.dspbr?`\n\t\t\t\t\t${C("n")}  = normalize(localnorm);\n\t\t\t\t\tif (dot(localpos, localnorm) < 0.0) {\n\t\t\t\t\t\tn = -n;\n\t\t\t\t\t}\n\t\t\t\t\t`:`${C("n")} = normalize(localpos);`}\n\n                ${C("s")};\n                s.x = -1.0;\n                if (n.x >= -0.0000001) { s.x = 1.0; }\n                s.y = 1.0;\n                if (n.y >= -0.0000001) { s.y = -1.0; }\n                s.z = -1.0;\n                if (n.z >= -0.0000001) { s.z = 1.0; }\n\n                if(maxima_normal == absolute_normal.x){\n                    outUV = ${D()}(s.x * localpos.y, localpos.z );\n                    ${i()}outTangent = s.x * y;\n                    ${i()}outBinormal = z;\n                }\n\n                else if(maxima_normal == absolute_normal.y){\n                    outUV = ${D()}(s.y * localpos.x, localpos.z );\n                    ${i()}outTangent = s.y * x;\n                    ${i()}outBinormal = z;\n                }\n                else{\n                    outUV = ${D()}(s.z * localpos.x, localpos.y );\n                    ${i()}outTangent = s.z * x;\n                    ${i()}outBinormal = y;\n                }\n\n            } else if (mappType == 4) {\n\t\t\t\t${C("n")}  = localnorm;\n\t\t\t\t${n.dspbr?"\n\t\t\t\t\tif (dot(localpos, localnorm) < 0.0) {\n\t\t\t\t\t\tn = -n;\n\t\t\t\t\t}\n\t\t\t\t\t":""}\n                ${T("radius2d")}  = length(localpos.xy);\n                ${C("absolute_normal")}  = abs(n);\n                ${T("maxima_normal")}  = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));\n\n                if(maxima_normal == absolute_normal.z){\n                    ${T("s")}  = -1.0;\n                    if (localpos.z >= 0.0) {\n                        s = 1.0;\n                    }\n                    outUV.x = s * localpos.x;\n                    outUV.y = localpos.y;\n                \n                    ${i()}outTangent = s * x;\n                    ${i()}outBinormal = y;\n                }else{\n                    ${T("thetaMapping")} =0.0;\n                    if (localpos.y!=0.0 || localpos.x!=0.0){\n                        thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                    }\n\n                    ${T("u")} =thetaMapping*radius2d;\n                    outUV = ${D()}(u , localpos.z);\n\n                    ${T("cos_theta")}  = cos(thetaMapping);\n                    ${T("sin_theta")}  = sin(thetaMapping);\n                \n                    ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                    ${i()}outBinormal = z;\n                }\n\n            } else if (mappType == 5) {\n\n                ${T("radius2d")}  = length(localpos.xy);\n                ${T("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                }\n\n                ${T("u")} =thetaMapping*radius2d;\n                outUV = ${D()}(u, localpos.z);\n                \n                ${T("cos_theta")}  = cos(thetaMapping);\n                ${T("sin_theta")}  = sin(thetaMapping);\n            \n                ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                ${i()}outBinormal = z;\n            } else if (mappType == 7) {\n\n                ${T("radius2d")}  = length(localpos.xy);\n                ${T("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                }\n\n                ${T("u")} =thetaMapping/3.14159;\n                outUV = ${D()}(u, localpos.z/(radius2d*3.14159));\n                \n                ${T("cos_theta")}  = cos(thetaMapping);\n                ${T("sin_theta")}  = sin(thetaMapping);\n            \n                ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                ${i()}outBinormal = z;\n\n            } else if (mappType == 8) {\n\n                ${T("thetaMapping")} =0.0;\n                if (localpos.y!=0.0 || localpos.x!=0.0) {\n                    thetaMapping = ${n.WebGPU?"atan2":"atan"}(localpos.y, localpos.x);\n                }\n                ${T("u")} =thetaMapping/3.14159;\n                outUV = ${D()}(u, localpos.z);\n\n                ${T("cos_theta")}  = cos(thetaMapping);\n                ${T("sin_theta")}  = sin(thetaMapping);\n                ${i()}outTangent = -sin_theta*x + cos_theta*y;\n                ${i()}outBinormal = z;\n\n            }\n\n            if(mappType >0){\n                ${i()}outTangent= normalize(cross(${i()}outBinormal,norm));\n                ${i()}outBinormal= normalize(cross(norm,${i()}outTangent));\n            }\n\n            if (${v("mappingTransformSemantic")}==1){\n               return (${v("mappingUVTransformation")} * ${C()}(outUV, 1.0)).xy;\n            }else{\n               return outUV;\n            }\n    }\n\n        ${f("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),$("outTangent"),$("outBinormal")])} {\n            return ${h("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),l(`${v("mappingType")}`),$("outTangent"),$("outBinormal")])};\n        }\n\n        ${f("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),l("mappType")])} {\n            ${C("bogusTangent")};\n            ${C("bogusBinormal")};\n            return ${h("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),l("mappType"),c("bogusTangent"),c("bogusBinormal")])};\n        }\n\n        ${f("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm")])} {\n            ${C("bogusTangent")};\n            ${C("bogusBinormal")};\n            return ${h("applyMappingOperator","v2",[u("inUV"),m("pos"),m("norm"),c("bogusTangent"),c("bogusBinormal")])};\n        }\n\n        ${f("applyMappingOperator","v4",[p("inUV"),m("pos"),m("norm"),l("mappType"),$("outTangent"),$("outBinormal")])} {\n            ${D("outUV")} = inUV.xy;\n            outUV = ${h("applyMappingOperator","v2",[u("outUV"),m("pos"),m("norm"),l("mappType"),$("outTangent"),$("outBinormal")])};\n            return ${P()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${f("applyMappingOperator","v4",[p("inUV"),m("pos"),m("norm"),$("outTangent"),$("outBinormal")])} {\n            ${D("outUV")} = inUV.xy;\n            outUV = ${h("applyMappingOperator","v2",[u("outUV"),m("pos"),m("norm"),l(`${v("mappingType")}`),$("outTangent"),$("outBinormal")])};\n            return ${P()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${f("applyMappingOperator","v4",[p("inUV"),m("pos"),m("norm"),l("mappType")])} {\n            ${C("bogusTangent")};\n            ${C("bogusBinormal")};\n            ${D("outUV")} = inUV.xy;\n            outUV =  ${h("applyMappingOperator","v2",[u("outUV"),m("pos"),m("norm"),l("mappType"),c("bogusTangent"),c("bogusBinormal")])};\n            return ${P()}(outUV,inUV.z,inUV.w);\n        }\n\n        ${f("applyMappingOperator","v4",[p("inUV"),m("pos"),m("norm")])} {\n            ${C("bogusTangent")};\n            ${C("bogusBinormal")};\n            ${D("outUV")} = inUV.xy;\n            outUV =  ${h("applyMappingOperator","v2",[u("outUV"),m("pos"),m("norm"),c("bogusTangent"),c("bogusBinormal")])};\n            return ${P()}(outUV,inUV.z,inUV.w);\n        }\n        `};return{model_view_projection_transformation_vertex:function(n){return`${(n=>t.getBuiltin(n,t.ShaderStages.out))("position")} = ${r="projectionMatrix",a={uniformName:r},e.getGlobalUniform(a)} * ${h("computeModelViewPosition","v4",[m("position_")])};`;var r,a},model_view_transformation_pars:function(n){var e=function(n){let e="";return(n.billboard||n.fixedSize)&&(e=`\n                            ${e}\n                            ${h("setSimpleNodeData",null,[])};\n                        `),n.billboard&&(e=`\n                            ${e}\n                            res = simpleNodeData.billboardMatrix * res;\n                        `),n.fixedSize&&(e=`\n                            ${e}\n                            res.x *= simpleNodeData.fixedSizeScale;\n                            res.y *= simpleNodeData.fixedSizeScale;\n                            res.z *= simpleNodeData.fixedSizeScale;\n                            vec3 fixedSizeCenterOffset = simpleNodeData.fixedSizeScaleCenter * res.w * ${S("fixedSizeCenterRatio")}.xyz;\n                            res.x += fixedSizeCenterOffset.x;\n                            res.y += fixedSizeCenterOffset.y;\n                            res.z += fixedSizeCenterOffset.z;\n                        `),e};return`\n                ${f("getLocalPositionTransformation","v4",[p("iVec4")])} {\n\t\t\t\t\t${P("res")} = iVec4;\n\t\t\t\t\t${e(n)}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n                ${f("getLocalPositionTransformation","v4",[m("iVec3")])}{\n\t\t\t\t\t${P("res")}  = vec4(iVec3, 1.0);\n\t\t\t\t\t${e(n)}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n                ${f("getModelTransformation","v4",[p("iVec4")])}{\n                    ${P("res")}  = ${h("getLocalPositionTransformation","v4",[p("iVec4")])};                     \n                    ${n.defaultInstancing?`res = (multipliedDefaultInstancingMatrix * ${P()}(res.xyz, 1.0));`:""}      \n                    return modelMatrix * res;\n\t\t\t\t}\n                ${f("getModelTransformation","v4",[m("iVec3")])}{       \n                    return ${h("getModelTransformation","v4",[p("vec4(iVec3, 1.0)")])};\n\t\t\t\t}\n\n                ${f("getModelViewTransformation","v4",[p("iVec4")])}{\n                    ${P("res")} = ${h("getLocalPositionTransformation","v4",[p("iVec4")])};            \n                    return ${h("computeModelViewPosition","v4",[m("res.xyz")])};\n                }\n                ${f("getModelViewTransformation","v4",[m("iVec3")])}{        \n                    return ${h("getModelViewTransformation","v4",[p("vec4(iVec3, 1.0)")])};\n                }\n            `},getModelViewTransformationChunk:function(n,e,t){return`${n} = ${h("getModelViewTransformation","v4",[p(e)])};`},model_view_unit_transformation_pars:function(n){let e="";return(n.billboard||n.fixedSize)&&(e=`\n                    ${e}\n                    ${h("setSimpleNodeData",null,[])};\n                `),n.billboard&&(e=`\n                    ${e}\n                    res = (simpleNodeData.billboardMatrix * ${P()}(res, 0.0)).xyz;\n                `),`\n                ${f("getModelViewUnitTransformation","v3",[m("iVec3")])} {\n                    ${C("res")} = iVec3;\n                    ${e}\n                    return ${h("computeModelViewDirection","v4",[m("res")])}.xyz;\n                }\n            `},getModelViewUnitVectorTransformationChunk:function(n,e,t){return`${n} = ${h("getModelViewUnitTransformation","v3",[m(e)])};`},getNormalMatrixUnitVectorTransformationChunk:function(n,e,t){return`${n} = ${(n=>{var e="";return e=n.useNormalMatrix?S("normalMatrix"):"normalMatrix",n.defaultInstancing&&(e=`${e} * ${((n=null)=>{var e={name:n};return r.mat3(e)})()}(multipliedDefaultInstancingMatrix)`),e})(t)} * ${e};`},map_pars_vertex:function(n){if(n.mappingType>-1||n.lightMapMappingType>-1){var e=`${w(n)}`;return!0===n.mappingUseFragment&&(e=`\n                        ${e}\n                        ${x({varyingName:"localPosition",varyingType:"v3"})}\n                        ${x({varyingName:"localNormal",varyingType:"v3"})}\n                    `),e}return""},map_pars_fragment:function(n){if(n.WebGPU)return"";if(n.mappingType>-1||n.lightMapMappingType>-1){var e=`${w(n)}`;return!0===n.mappingUseFragment&&(e=`\n                        ${e}\n                        ${x({varyingName:"localPosition",varyingType:"v3"})}\n                        ${x({varyingName:"localNormal",varyingType:"v3"})}\n                    `),e}return""},rgbe_sample_methods:function(n){return b(0,!1)},rgbe_sample_methods_repeat:function(n){return b(0,!0)},normal_viewposition_pars_vertex:function(n){return n.PDSFX?"":`\n                ${x({varyingName:"vViewPosition",varyingType:"v3"})}\n                ${x({varyingName:"vNormal",varyingType:"v3"})}\n            `},normal_viewposition_vertex:function(n){return n.PDSFX?"transformedNormal = _viewTangentSpace.Normal;":`\n                    ${_("vNormal")} = normalize( transformedNormal );\n                    ${_("vViewPosition")} = -mvPosition.xyz;\n            `},normal_viewposition_pars_fragment:function(n){var e="";return n.PDSFX||(e=`\n                ${x({varyingName:"vViewPosition",varyingType:"v3"})}\n                ${x({varyingName:"vNormal",varyingType:"v3"})}\n                `),e},normal_viewposition_fragment:function(n){const e=n.PDSFX?"INTERNAL_computed_viewPosition":y("vViewPosition");return`\n                ${n.PDSFX?`${C("normal")}  = INTERNAL_computed_viewNormal;`:`${C("normal")}  = normalize( ${y("vNormal")} );`}\n                normal = normal * ( -1.0 + 2.0 * ${T()}( gl_FrontFacing ) );\n                ${C("view")}  = normalize( ${e} );\n                ${C("vPos")}  = ${e};\n            `},getScreenUVs:function(n){return`mod(gl_FragCoord.xy * ${v("invScreenSize")}, ${D()}(1.0))`}}}),define("DS/ShaderBuilders/Commons/ColorShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=n=>o.parameterF(n),l=n=>o.parameterV3(n),u=(n,e,t)=>i.declareFunction(n,e,t),m=(n,e,t)=>i.callFunction(n,e,t),$=n=>e.addUniform(n),c=n=>{var t={uniformName:n};return e.getUniform(t)},p=n=>{var t={uniformName:n};return e.getObjectUniform(t)},d=n=>e.addPostProUniform(n),f=n=>{var t={uniformName:n};return e.getPostProUniform(t)},h=n=>t.addVarying(n),g=n=>t.getVarying(n,t.ShaderStages.out),v=(n=null)=>{var e={name:n};return a.float(e)},S=(n=null)=>{var e={name:n};return a.vec3(e)},x=(n=null)=>{var e={name:n};return a.vec4(e)},y=n=>{var e={name:n,constant:!0};return a.float(e)};let _={postprocess_pars_fragment:function(n){if(n.gammaOutput&&n.inlinedPostProActivated){let e=d({uniformName:"brightness",uniformType:"f"});return 6===n.inlinedPostProTonemapping&&(e=`\n                        ${e}\n                        ${d({uniformName:"crushblacks",uniformType:"f"})} \n                        ${d({uniformName:"burnhighlights",uniformType:"f"})} \n                        ${u("luminance_RGB","f",[l("iColor")])} {\n                            ${S("luminance_weight")} =${S()}(0.176204,0.812985,0.0108109);\n                            return dot(iColor,luminance_weight);\n                        }\n                    `),e}return""},postprocess_fragment:function(n){if(n.gammaOutput&&n.inlinedPostProActivated){let e=`gl_FragColor.xyz *= pow(2.0,${f("brightness")});`;return 6===n.inlinedPostProTonemapping&&(e=`\n                    ${e}\n                    ${v("saturation")} = 1.0;\n                    ${S("colorCorrection")} = ${S()}(1.0);\n                    ${S("c")} = gl_FragColor.xyz * colorCorrection;\n                    c *= (c*${f("burnhighlights")}+1.0)/(c+1.0);\n                    c = mix(${S()}(${m("luminance_RGB","f",[l("c")])}),c,saturation);\n                    ${v("intens")} = ${m("luminance_RGB","f",[l("c")])};\n                    if(intens<1.0){\n                        ${v("_crushblacks")} = 2.0* ${f("crushblacks")} +1.0;\n                        intens = sqrt(intens);\n                        ${v("oms2")} = 1.0 - intens;\n                        c.x = c.x*intens + pow(c.x,_crushblacks)*oms2;\n                        c.y = c.y*intens + pow(c.y,_crushblacks)*oms2;\n                        c.z = c.z*intens + pow(c.z,_crushblacks)*oms2;\n                    }\n                    gl_FragColor.x = c.x;\n                    gl_FragColor.y = c.y;\n                    gl_FragColor.z = c.z;\n                    `),e}return""},linear_to_gamma_fragment:function(n){if(n.gammaOutput){var e=(n=>t.getShaderOutput(n))("out0");return n.simpleGamma?`${e} = ${x()}(sqrt(${e}.xyz), ${e}.a);`:`                     \n                    if (${e}.r < 0.0031308) {\n                        ${e}.r = ${e}.r*12.92;  \n                    } else { \n                        ${e}.r = 1.055*pow(${e}.r,1.0/2.4)-0.055; \n                    }\n                    if (${e}.g < 0.0031308) {\n                        ${e}.g = ${e}.g*12.92;  \n                    } else { \n                        ${e}.g = 1.055*pow(${e}.g,1.0/2.4)-0.055; \n                    }\n                    if (${e}.b < 0.0031308) {\n                        ${e}.b = ${e}.b*12.92;  \n                    } else { \n                        ${e}.b = 1.055*pow(${e}.b,1.0/2.4)-0.055; \n                    }\n                    `}return""},color_pars_fragment:function(n){return n.WebGPU?"":n.vertexColors?h({varyingName:"vColor",varyingType:"v4"}):""},color_fragment:function(n){return n.vertexColors?`gl_FragColor *= ${(n=>t.getVarying(n,t.ShaderStages.in))("vColor")};`:""},color_pars_vertex:function(n){return n.vertexColors?`\n\t\t\t\t${n.objectVertexColors?(n=>e.addObjectUniform(n))({uniformName:"objectColorBufferType",uniformType:"f"}):$({uniformName:"colorBufferType",uniformType:"f"})}\n                ${h({varyingName:"vColor",varyingType:"v4"})}\n\n\t\t\t\t${y("VertexColorsFace")} = 1.0;\n\t\t\t\t${y("VertexColorsRGBA")} = 2.0;\n\t\t\t\t${y("VertexColorsRGB")} = 3.0;\n\t\t\t\t${y("VertexColorsA")} = 4.0;\n\t\t\t\t${y("VertexColorsR")} = 8.0;\n\t\t\t\t${y("VertexColorsG")} = 16.0;\n\t\t\t\t${y("VertexColorsB")} = 32.0;\n\n                ${u("GetVertexColorMult","v3",[l("colorValue")])} {\n                    ${v("colorTypeToUse")};\n\t\t\t\t\t${n.objectVertexColors?`colorTypeToUse = ${p("objectColorBufferType")};`:`colorTypeToUse = ${c("colorBufferType")};`}\n\t\t\t\t\tif (colorTypeToUse <= VertexColorsRGB) {\n\t\t\t\t\t\treturn colorValue.rgb;\n\t\t\t\t\t}\n\t\t\t\t\t${S("res")} = ${S()}(1.0);\n\t\t\t\t\t${v("maskR")} = floor(colorTypeToUse / VertexColorsR);\n\t\t\t\t\tif (mod(maskR, 2.0) > 0.5) {\n\t\t\t\t\t\tres.r = colorValue.r;\n\t\t\t\t\t}\n\t\t\t\t\t${v("maskG")} = floor(colorTypeToUse / VertexColorsG);\n\t\t\t\t\tif (mod(maskR, 2.0) > 0.5) {\n\t\t\t\t\t\tres.g = colorValue.g;\n\t\t\t\t\t}\n\t\t\t\t\t${v("maskB")} = floor(colorTypeToUse / VertexColorsB);\n\t\t\t\t\tif (mod(maskR, 2.0) > 0.5) {\n\t\t\t\t\t\tres.b = colorValue.b;\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n                ${u("GetVertexAlphaMult","f",[s("alphaValue")])} {\n                    ${v("colorTypeToUse")};\n\t\t\t\t\t${n.objectVertexColors?`colorTypeToUse = ${p("objectColorBufferType")};`:`colorTypeToUse = ${c("colorBufferType")};`}\n\t\t\t\t\tif (colorTypeToUse < VertexColorsRGB) {\n\t\t\t\t\t\treturn alphaValue;\n\t\t\t\t\t}\n\t\t\t\t\t${v("maskA")}  = floor(colorTypeToUse / VertexColorsA);\n\t\t\t\t\tif (mod(maskA, 2.0) > 0.5) {\n\t\t\t\t\t\treturn alphaValue;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1.0;\n\t\t\t\t}\n\n\t\t\t`:""},color_vertex:function(n){if(n.vertexColors){var e=`\n                ${g("vColor")} = ${x()}(\n                    ${m("GetVertexColorMult","v3",[l("color.rgb")])}, \n                    ${m("GetVertexAlphaMult","f",[s("color.a")])}\n                );\n            `;return n.gammaInput&&(e=`\n\t\t\t\t\t${e}\n\t\t\t\t\t${g("vColor")} *= ${g("vColor")};\n\t\t\t\t`),e}return""},sRGB_conversion:function(n){return`\n            ${u("convertToLinear","v3",[l("color")])} {\n\n                ${S("res")};\n\n                ${n.simpleGamma?"res = color*color;":"\n                    if (color.r < 0.04045) {\n                        res.r = color.r/12.92;  \n                    } else { \n                        res.r = pow((color.r + 0.055)/1.055, 2.4); \n                    };\n                    if (color.g < 0.04045) {\n                        res.g = color.g/12.92;  \n                    } else { \n                        res.g = pow((color.g + 0.055)/1.055, 2.4); \n                    };\n                    if (color.b < 0.04045) {\n                        res.b = color.b/12.92;  \n                    } else { \n                        res.b = pow((color.b + 0.055)/1.055, 2.4); \n                    };\n                    "}\n                \n                return res;\n            }\n        \n        `},ao_pars_fragment:function(n){return n.useSSAO?`\n        ${$({uniformName:"invScreenSize",uniformType:"v2"})} \n        ${$({uniformName:"aoTexture",uniformType:"t2"})} \n        ${$({uniformName:"aoParams",uniformType:"v2"})} \n        `:""},_ao_fragment:function(e){return`\n        ${v("aoValue")} = ${i.sample2DTexture("aoTexture",n.getScreenUVs(e))}.x;\n        ${v("occ")} = 1.0 - ${c("aoParams")}.x *(1.0 - aoValue);\n        occ = pow(clamp(occ, 0.0, 1.0), ${c("aoParams")}.y);\n        ${e.invisiblePlaneMaterial?"if (smallPlaneSSAO < 0.5) occ = 1.0;":""}\n        gl_FragColor.x *= occ;\n        gl_FragColor.y *= occ;\n        gl_FragColor.z *= occ;\n        `},ao_fragment:function(n){return n.useSSAO?`\n        if (gl_FragColor.a > 1.0 - 1e-3) {\n            ${_._ao_fragment(n)}\n        }\n        `:""}};return _}),define("DS/ShaderBuilders/Commons/ScenegraphShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=e.ParameterUtils,i=(n,e,t=!1)=>o.parameter(n,e,t),s=n=>o.parameterF(n),l=n=>o.parameterV2(n),u=n=>o.parameterV3(n),m=(n,t,r)=>e.FunctionHandler.declareFunction(n,t,r),$=(n,t,r)=>e.FunctionHandler.callFunction(n,t,r),c=n=>t.addObjectUniform(n),p=n=>{var e={uniformName:n};return t.getObjectUniform(e)},d=n=>t.addGlobalUniform(n),f=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},h=(n=null)=>{var e={name:n};return a.float(e)},g=(n=null)=>{var e={name:n};return a.vec2(e)},v=(n=null)=>{var e={name:n};return a.vec3(e)},S=(n=null)=>{var e={name:n};return a.vec4(e)},x=(n=null)=>{var e={name:n};return a.mat4(e)};return{gpu_scenegraph_nodes:function(n){return`\n\t\t\t${n.billboard?`\n                ${c({uniformName:"modelInvRotMatrix",uniformType:"m4"})}\n                ${c({uniformName:"billboardType",uniformType:"i"})}\n                ${c({uniformName:"billboardRotationEnabled",uniformType:"i"})}\n                ${c({uniformName:"billboardRotation",uniformType:"m4"})}\n                ${d({uniformName:"billCameraPos",uniformType:"v3"})}\n                ${d({uniformName:"billCameraLookAt",uniformType:"v3"})}\n                ${d({uniformName:"billCameraUp",uniformType:"v3"})}\n                    ${m("lookAt","m4",[u("eye"),u("target"),u("up")])} {\n\t\t\t\t\t\t${v("z")} = eye - target;\n\t\t\t\t\t\tif (length(z) < 1e-6) {\n\t\t\t\t\t\t\tz.z = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = normalize(z);\n\t\t\t\t\t\t${v("x")} = cross(up, z);\n\t\t\t\t\t\tif (length(x) < 1e-6) {\n\t\t\t\t\t\t\tz.x += 0.001;\n\t\t\t\t\t\t\tx = cross(up, z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = normalize(x);\n\t\t\t\t\t\t${v("y")} = cross(z,x);\n\t\t\t\t\t\treturn ${x()}(${S()}(x, 0.0), ${S()}(y, 0.0), ${S()}(z, 0.0), ${S()}(0.0,0.0,0.0,1.0));\n\t\t\t\t\t}\n                ${c({uniformName:"billboardAxis",uniformType:"v3"})}\n                ${d({uniformName:"invViewMatrix",uniformType:"m4"})}\n                ${d({uniformName:"invProjectionMatrix",uniformType:"m4"})}\n\n                ${m("applyProjection","v3",[u("vector"),i("m4","proj")])} {\n\t\t\t\t\t${S("res")} = proj * ${S()}(vector, 1.0);\n\t\t\t\t\treturn res.xyz / max(abs(res.w),1e-6);\n\t\t\t\t}\n\n                ${m("getBillboardMatrix","m4",[])} {\n                    ${v("cameraPos")}  = ${f("billCameraPos")};\n\t\t\t\t\t${v("cameraTarget")}  = ${f("billCameraLookAt")} + cameraPos;\n\t\t\t\t\t${x("billMat")} ;\n\t\t\t\t\tif (${p("billboardType")} == 1) {\n\t\t\t\t\t\tbillMat = ${$("lookAt","m4",[u("cameraPos"),u("cameraTarget"),u(`${f("billCameraUp")}`)])};\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${v("axis")}  = normalize(${$("computeModelDirection","v4",[(n=>o.parameterV4(n))(`${p("billboardAxis")}`)])}.xyz);\n\t\t\t\t\t\t${v("objToCam")}  = vec3(0.0);\n\t\t\t\t\t\tif (${p("billboardType")} == 3) {\n\t\t\t\t\t\t\t${v("worldPosOrigin")}  = ${$("computeModelPosition","v4",[u(`${v()}(0.0)`)])}.xyz;\n\t\t\t\t\t\t\tobjToCam = worldPosOrigin - cameraPos;\n\t\t\t\t\t\t\t${v("tmp")}  = worldPosOrigin + axis;\n\t\t\t\t\t\t\t${x("proj")}  = ${f("projectionMatrix")} * ${f("viewMatrix")};\n\t\t\t\t\t\t\t${v("projOrig")}  = ${$("applyProjection","v3",[u("worldPosOrigin"),i("m4","proj")])};\n\t\t\t\t\t\t\ttmp = ${$("applyProjection","v3",[u("tmp"),i("m4","proj")])};\n\t\t\t\t\t\t\ttmp.z = projOrig.z;\n                            ${x("projectionToApply")}  = ${f("invViewMatrix")} * ${f("invProjectionMatrix")};\n\t\t\t\t\t\t\ttmp = ${$("applyProjection","v3",[u("tmp"),i("m4","projectionToApply")])};\n\t\t\t\t\t\t\ttmp -= worldPosOrigin;\n\t\t\t\t\t\t\taxis = normalize(tmp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobjToCam = ${f("billCameraLookAt")};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobjToCam = normalize(objToCam);\n\t\t\t\t\t\t${v("crossX")}  = cross(objToCam, axis);\n\t\t\t\t\t\tif (length(crossX) < 1e-6) {\n                            if (abs(objToCam.z) < 0.999) {\n                                crossX = cross(${v()}(0.0,0.0,1.0), objToCam);\n                            } else {\n                                crossX = cross(${v()}(1.0,0.0,0.0), objToCam);\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcrossX = normalize(crossX);\n\t\t\t\t\t\t${v("crossY")}  = normalize(cross(axis, crossX));\n\t\t\t\t\t\tbillMat = mat4(${S()}(crossX, 0.0), ${S()}(crossY, 0.0), ${S()}(axis, 0.0), ${S()}(0.0,0.0,0.0,1.0));\n\t\t\t\t\t}\n\t\t\t\t\tif (${p("billboardRotationEnabled")} == 1) {\n\t\t\t\t\t\treturn ${p("modelInvRotMatrix")} * billMat * ${p("billboardRotation")};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ${p("modelInvRotMatrix")} * billMat;\n\t\t\t\t\t}\n\t\t\t\t}\n                `:""}\n\n\t\t\t${n.fixedSize?`\n                ${c({uniformName:"fixedSizeCenterRatio",uniformType:"v4"})}\n                ${d({uniformName:"pixelToWorldSizeCst",uniformType:"f"})}\n                ${m("getScale","v2",[])} {\n\t\t\t\t\t${v("xAxis")}  = modelMatrix[0].xyz;\n\t\t\t\t\t${v("yAxis")}  = modelMatrix[1].xyz;\n\t\t\t\t\t${v("zAxis")}  = modelMatrix[2].xyz;\n\t\t\t\t\t${h("radius")}  = max(length(xAxis),max(length(yAxis),length(zAxis)));\n                    ${n.defaultInstancing?"\n                        xAxis  = multipliedDefaultInstancingMatrix[0].xyz;\n                        yAxis  = multipliedDefaultInstancingMatrix[1].xyz;\n                        zAxis  = multipliedDefaultInstancingMatrix[2].xyz;\n                        radius *= max(length(xAxis),max(length(yAxis),length(zAxis)));\n                        ":""}\n\t\t\t\t\t${h("screenRadius")}  = 1.0;\n\t\t\t\t\tif (${f("projectionMatrix")}[3][3] > 0.5) {\n\t\t\t\t\t\tscreenRadius = radius;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t${S("aux")}  = ${$("computeModelViewPosition","v4",[u(`${v()}(0.0)`)])};\n\t\t\t\t\t\t${h("constant")}  = abs(aux.z);\n\t\t\t\t\t\tscreenRadius = radius / constant;\n\t\t\t\t\t}\n                    ${h("scaleFactorCenter")}  = 0.0;\n                    if (length(${p("fixedSizeCenterRatio")}.xyz) > 0.0) {\n                        scaleFactorCenter = 1.0 / screenRadius * pixelToWorldSizeCst;\n                        if (${f("projectionMatrix")}[3][3] > 0.5) {\n                            screenRadius = radius;\n                        } else {\n                            ${v("scaleCenter")}  = ${p("fixedSizeCenterRatio")}.xyz * scaleFactorCenter;\n                            ${S("aux2")}  = ${$("computeModelViewPosition","v4",[u("scaleCenter")])};\n                            ${h("constant2")}  = abs(aux2.z);\n                            screenRadius = radius / constant2;\n                        }\n                    }\n                    ${h("scaleFactor")}  = ${p("fixedSizeCenterRatio")}.w / screenRadius * pixelToWorldSizeCst;\n\t\t\t\t\treturn ${g()}(scaleFactor, scaleFactorCenter);\n\t\t\t\t}\n                `:""}\n\n\t\t\t${n.billboard||n.fixedSize?`\n                ${a.createStructure({structName:"SimpleNodeData",attributes:[{type:"m4",name:"billboardMatrix"},{type:"f",name:"fixedSizeScale"},{type:"f",name:"fixedSizeScaleCenter"}]})}\n                ${a.declareStructure({name:"simpleNodeData",structName:"SimpleNodeData",addressSpace:"private"})};\n\t\t\t\t${((n=null)=>{var e={name:n};return a.bool(e)})("simpleSizeDataSet")}  = false;\n                ${m("setSimpleNodeData",null,[])}{\n\t\t\t\t\tif (simpleSizeDataSet) return;\n\t\t\t\t\t${n.billboard?`simpleNodeData.billboardMatrix = ${$("getBillboardMatrix","m4",[])};`:""}\n\t\t\t\t\t${n.fixedSize?`\n\t\t\t\t\t\t${g("fixedSizeData")}  = ${$("getScale","v2",[])};\n\t\t\t\t\t\tsimpleNodeData.fixedSizeScale = fixedSizeData.x;\n\t\t\t\t\t\tsimpleNodeData.fixedSizeScaleCenter = fixedSizeData.y;\n                        `:""}\n\t\t\t\t\tsimpleSizeDataSet = true;\n\t\t\t\t}\n                `:""}\n            `},decompress_normals_pars:function(n){return`\n                //unpacks 1 float representing 2xunorm12 (i.e. 2xint12) into 2 floats between 0.0 and 1.0\n                ${m("unpack_2unorm12_in_2floats","v2",[s("iEncodedNormal")])} {\n                    ${g("res")};\n                    res.x = floor(iEncodedNormal/4096.0)/4095.0;\n                    //res.y = mod(iEncodedNormal, 4096.0)/4095.0;\n                    // OpenGL ref: mod = x - y * floor(x/y)\n                    res.y = (iEncodedNormal - 4096.0 * floor(iEncodedNormal/4096.0))/4095.0;\n                    return res;\n                }\n\n                ${m("signNotZero","f",[s("k")])} {\n                    if (k >= 0.0) { return 1.0; }\n                    return -1.0;\n                }\n\n                ${m("signNotZero","v2",[l("v")])} {\n                    return ${g()}( ${$("signNotZero","f",[s("v.x")])}, ${$("signNotZero","f",[s("v.y")])} );\n                }\n\n                ${m("decodeOct24Normal","v3",[l("iEncodedNormal")])} {\n                    //put in [-1,1]\n                    ${h("x")} = iEncodedNormal.x*2.0 - 1.0;\n                    ${h("y")} = iEncodedNormal.y*2.0 - 1.0;\n                    ${v("v")} = ${v()}(x, y, 1.0 - abs(x) - abs(y));\n                    if (v.z <= 0.0) {\n                        ${g("sgn")} = ${$("signNotZero","v2",[l("v.xy")])};\n                        // "v.xy = (1.0 - abs(v.yx))*signNotZero(v.xy);\n                        //v.xy = - abs(v.yx)*sgn + sgn;\n                        ${g("tmp")} = -abs(v.yx)*sgn + sgn;\n                        v.x = tmp.x;\n                        v.y = tmp.y;\n                    }\n                    return normalize(v);\n                }\n\n                ${m("decodeOct24Normal","v3",[s("iEncodedNormal")])}{\n                    return ${$("decodeOct24Normal","v3",[l(`${$("unpack_2unorm12_in_2floats","v2",[s("iEncodedNormal")])}`)])};\n                }\n\n                ${m("decodeOct22Normal","v3",[l("iEncodedNormal")])} {\n                    ${h("x")} = iEncodedNormal.x/2047.0*2.0 - 1.0;\n                    ${h("y")} = iEncodedNormal.y/2047.0*2.0 - 1.0;\n                    ${v("v")} = ${v()}(x, y, 1.0 - abs(x) - abs(y));\n                    if (v.z <= 0.0) {\n                        ${g("sgn")}  = ${$("signNotZero","v2",[l("v.xy")])};\n                        ${g("auxV")} = ${g()}(v.xy);\n                        v.x = - abs(auxV.y)*sgn.x + sgn.x;\n                        v.y = - abs(auxV.x)*sgn.y + sgn.y;\n                    }\n                    return normalize(v);\n                }\n            `},decompress_vertices_pars:function(n){return`\n            ${m("unpack_3unorm16_in_3floats","v3",[l("iEncodedPosition")])} {\n                ${v("res")};\n                res.x = floor(iEncodedPosition.x/256.0);\n                //res.y = mod(iEncodedPosition.x, 256.0) *256.0 + mod(iEncodedPosition.y, 256.0);\n                // OpenGL ref: mod = x - y * floor(x/y)\n                res.y  = (iEncodedPosition.x - 256.0 * floor(iEncodedPosition.x / 256.0)) * 256.0;\n                res.y += (iEncodedPosition.y - 256.0 * floor(iEncodedPosition.y / 256.0));\n                res.z = floor(iEncodedPosition.y/256.0);\n                return res;\n            }\n\n            ${m("decodePosition","v3",[l("iEncodedPosition"),u("quantized"),u("offset")])} {\n                ${v("res")} = ${$("unpack_3unorm16_in_3floats","v3",[l("iEncodedPosition")])};\n                return quantized * (res + offset);\n            }\n            `},decompress_colors_pars:function(n){return`\n            ${m("unpack_4unorm8_in_4floats","v4",[l("iEncodedColor")])} {\n\n                ${S("res")};\n                res.x = floor(iEncodedColor.x/65536.0);\n                //res.y = mod(floor(iEncodedColor.x/256.0), 256.0);\n                // OpenGL ref: mod = x - y * floor(x/y)\n                res.y = floor(iEncodedColor.x/256.0) - 256.0 * floor(floor(iEncodedColor.x/256.0)/256.0);\n                //res.z = mod(iEncodedColor.x, 256.0);\n                res.z = iEncodedColor.x - 256.0 * floor(iEncodedColor.x/256.0);\n                res.w = iEncodedColor.y;\n                return res;\n            }\n\n            ${m("decodeColor","v4",[l("iEncodedColor")])} {\n\n                ${S("res")} = ${$("unpack_4unorm8_in_4floats","v4",[l("iEncodedColor")])};\n                return res / 255.0;\n            }\n            `},decompress_uvs_pars:function(n){return`\n                ${m("unpack_2unorm16_in_3floats","v3",[l("iEncodedUV")])} {\n                    ${v("res")};\n                    res.x = floor(iEncodedUV.x/256.0);\n                    //res.y = mod(iEncodedUV.x, 256.0) *256.0 + mod(iEncodedUV.y, 256.0);\n                    // OpenGL ref: mod = x - y * floor(x/y)\n                    res.y  = (iEncodedUV.x - 256.0 * floor(iEncodedUV.x / 256.0)) * 256.0;\n                    res.y += (iEncodedUV.y - 256.0 * floor(iEncodedUV.y / 256.0));\n                    res.z = floor(iEncodedUV.y/256.0);\n                    return res;\n                }\n\n                ${m("decodeUV","v3",[l("iEncodedUV")])} {\n                    ${v("res")} = ${$("unpack_2unorm16_in_3floats","v3",[l("iEncodedUV")])};\n                    return res / 65535.0;\n                }\n            `}}}),define("DS/ShaderBuilders/Commons/AlphaShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils"],function(n,e){"use strict";let t;const r=n=>e.getShaderOutput(n,t);return{alphatest_fragment:function(n){t=n;var e="";return n.alphaTest&&(e=`\n                ${e}\n                if ( ${r("out0")}.a < ${n.alphaTest.toFixed(5)} ) { discard; }\n                ${n.discardOrOpaque?`${r("out0")}.a = 1.0;`:""}\n            `),n.skipTranspar&&(e=`\n                ${e}\n                if ( ${r("out0")}.a < 1.0 - 1e-3) {discard; }\n            `),e}}}),define("DS/ShaderBuilders/Commons/EnvMapShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=n=>o.parameterV2(n),l=n=>o.parameterT2(n),u=(n,e,t)=>i.callFunction(n,e,t),m=n=>e.addUniform(n),$=n=>{var t={uniformName:n};return e.getUniform(t)},c=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},p=n=>t.addVarying(n),d=n=>t.getVarying(n,t.ShaderStages.in),f=n=>t.getVarying(n,t.ShaderStages.out),h=(n=null)=>{var e={name:n};return a.float(e)},g=(n=null)=>{var e={name:n};return a.vec2(e)},v=(n=null)=>{var e={name:n};return a.vec3(e)},S=(n=null)=>{var e={name:n};return a.vec4(e)},x=n=>{var e={name:n,constant:!0};return a.float(e)};return{envmap_pars_fragment:function(e){let t="";return(e.mapHDR||e.envMapHDR)&&(t=`\n                ${t}\n                ${m({uniformName:"mapHDRSize",uniformType:"v2"})} \n                ${m({uniformName:"envMapHDRSize",uniformType:"v2"})} \n                ${m({uniformName:"envMapHDRToMipsRatio",uniformType:"f"})} \n                ${n.rgbe_sample_methods(e)}\n            `),e.envMap&&(t=`\n                ${t}\n                ${x("PI")} = 3.1415926535898;\n                ${x("INV_PI")} = 0.31830988618;\n                ${m({uniformName:"reflectivity",uniformType:"f"})} \n                ${m({uniformName:"combine",uniformType:"i"})} \n            `,t=1===e.envMapping||2===e.envMapping?`\n                    ${t}\n                    ${m({uniformName:"envMap",uniformType:"t2"})} \n                    ${m({uniformName:"ambienceMatrix",uniformType:"m4"})} \n                    ${m({uniformName:"envMapExposureSpecular",uniformType:"f"})} \n                    ${m({uniformName:"envMapExposureDiffuse",uniformType:"f"})} \n                `:`\n                    ${t}\n                    ${m({uniformName:"envMap",uniformType:"tc"})} \n                `,t=e.bumpMap||e.normalMap?`\n                    ${t}\n                    ${m({uniformName:"useRefract",uniformType:"b"})} \n                    ${m({uniformName:"refractionRatio",uniformType:"f"})} \n                    ${e.refractionRatioMap?m({uniformName:"refractionRatioMap",uniformType:"t2"}):""}\n                `:`\n                    ${t}\n                    ${p({varyingName:"vReflect",varyingType:"v3"})}\n                `),t},envmap_fragment:function(n){if(!n.envMap)return"";let e=`${v("reflectVec")};`;return e=`\n            ${e=n.bumpMap||n.normalMap?`\n                ${e}\n                ${v("cameraToVertex")}  = normalize( ${d("vWorldPosition")} - ${c("cameraPosition")} );\n                ${v("worldNormal")}  = normalize( ${v()}( ${S()}( normal, 0.0 ) * ${c("viewMatrix")} ) );\n                if ( ${$("useRefract")} ) {\n                    reflectVec = refract( cameraToVertex, worldNormal, ${n.refractionRatioMap?`${i.sample2DTexture("refractionRatioMap","uvToUse")}.r`:`${$("refractionRatio")}`} );\n                } else {\n                    reflectVec = reflect( cameraToVertex, worldNormal );\n                }\n            `:`\n                ${e}\n                reflectVec = ${d("vReflect")};\n            `}\n            ${v("flipReflectVec")} ;\n            ${h("flipNormal")}  = 1.0;\n            flipReflectVec = flipNormal * reflectVec;\n        `,1===n.envMapping||2===n.envMapping?1===n.envMapping?(e=`\n                    ${e}\n                    flipReflectVec = ${v()}(flipReflectVec.y, flipReflectVec.z, flipReflectVec.x);\n                    flipReflectVec = (${$("ambienceMatrix")}*vec4(flipReflectVec,0.0)).xyz;\n                    ${h("probeR")}  = INV_PI * acos( flipReflectVec.z ) / length(flipReflectVec.xy);\n                `,e=n.envMapHDR?`\n                        ${e}\n                        ${g("texelSizeEnvMap")} = ${g()}(1.0 / ${$("envMapHDRSize")});\n                        ${S("cubeColor")}  = ${u("texture2DBilinearFromRGBE","v4",[l("envMap"),s(" 0.5 * (probeR * flipReflectVec.xy + 1.0)"),s(`${$("envMapHDRSize")}`),s("texelSizeEnvMap")])};\n                    `:`\n                        ${e}\n                        ${S("cubeColor")} = ${i.sample2DTexture("envMap","0.5 * (probeR * flipReflectVec.xy + 1.0)")};\n                    `):(e=`\n                    ${e}\n                    flipReflectVec = (${$("ambienceMatrix")}*${S()}(flipReflectVec,0.0)).xyz;\n                    ${h("phi")} = atan(flipReflectVec.y, flipReflectVec.x);\n                    ${h("theta")} = acos(flipReflectVec.z);\n                `,e=n.envMapHDR?`\n                        ${e}\n                        ${g("texelSizeEnvMap")}  = ${g()}(1.0 / ${$("envMapHDRSize")});\n                        ${S("cubeColor")} = ${$("envMapExposureSpecular")} * ${u("texture2DBilinearFromRGBE","v4",[l("envMap"),s(`${g()}(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta)`),s(`${$("envMapHDRSize")}`),s("texelSizeEnvMap")])};\n                    `:`\n                        ${e}\n                        ${S("cubeColor")} = ${$("envMapExposureSpecular")} * ${i.sample2DTexture("envMap",`${g()}(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta)`)};\n                    `):e=`\n                ${e}\n                ${S("cubeColor")} = ${i.sampleCubeTexture("envMap","flipReflectVec")};\n            `,e=`\n            ${e}\n            ${v("finalColor")}  = gl_FragColor.xyz;\n            if ( ${$("combine")} == 1 ) {\n                finalColor = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * ${$("reflectivity")} );\n            } else if ( ${$("combine")} == 2 ) {\n                finalColor += cubeColor.xyz * specularStrength * ${$("reflectivity")};\n            } else {\n                finalColor= mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * ${$("reflectivity")} );\n            }\n            gl_FragColor.x = finalColor.x;\n            gl_FragColor.y = finalColor.y;\n            gl_FragColor.z = finalColor.z;\n        `},envmap_pars_vertex:function(n){let e="";return!n.envMap||n.bumpMap||n.normalMap||(e=`\n                ${e}\n                ${p({varyingName:"vReflect",varyingType:"v3"})}\n                ${m({uniformName:"refractionRatio",uniformType:"f"})}\n                ${m({uniformName:"useRefract",uniformType:"b"})}\n                ${n.refractionRatioMap?m({uniformName:"refractionRatioMap",uniformType:"t2"}):""}\n            `),e},envmap_vertex:function(n){let e="";return!n.envMap||n.bumpMap||n.normalMap||(e=`\n                ${e}\n                ${v("worldNormal")}  = ${u("getModelTransformation","v4",[(n=>o.parameterV4(n))(`${S()}(objectNormal, 0.0)`)])}.xyz;\n                worldNormal = normalize( worldNormal );\n                ${v("cameraToVertex")}  = normalize( worldPosition.xyz - ${c("cameraPosition")} );\n                if ( ${$("useRefract")} ) {\n                    ${f("vReflect")} = refract( cameraToVertex, worldNormal, ${n.refractionRatioMap?`${i.sample2DTexture("refractionRatioMap","uvToUse")}.r`:`${$("refractionRatio")}`});\n                } else {\n                    ${f("vReflect")} = reflect( cameraToVertex, worldNormal );\n                }\n            `),e}}}),define("DS/ShaderBuilders/Commons/MappingShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=n=>o.parameterV2(n),l=n=>o.parameterV3(n),u=(n,e,t)=>i.callFunction(n,e,t),m=n=>e.addUniform(n),$=n=>{var t={uniformName:n};return e.getUniform(t)},c=n=>t.addVarying(n),p=n=>t.getVarying(n,t.ShaderStages.in),d=n=>t.getVarying(n,t.ShaderStages.out),f=(n=null)=>{var e={name:n};return a.vec2(e)},h=(n=null)=>{var e={name:n};return a.vec3(e)},g=(n=null)=>{var e={name:n};return a.vec4(e)};return{map_pars_vertex:function(e){return e.useUV?`\n                ${c({varyingName:"vUv",varyingType:"v4"})}\n                ${m({uniformName:"offsetBumpMap",uniformType:"v2"})}\n                ${m({uniformName:"repeatBumpMap",uniformType:"v2"})}\n                ${n.map_pars_vertex(e)}\n                `:""},map_pars_fragment:function(e){var t="";return e.useUV&&(t=`\n                ${t}\n                ${c({varyingName:"vUv",varyingType:"v4"})}\n                ${n.map_pars_fragment(e)}\n                `),e.map&&(t=`\n                ${t}\n                ${m({uniformName:"map",uniformType:"t2"})}\n                `),t},map_vertex:function(n){return n.useUV?`\n                ${d("vUv")} = uv * ${g()}(${$("repeatBumpMap")},1.0,1.0) + ${g()}(${$("offsetBumpMap")},0.0,0.0);\n                ${n.mappingType>-1?`\n                    ${!1===n.mappingUseFragment?`\n                        ${d("vUv")} = ${u("applyMappingOperator","v4",[(n=>o.parameterV4(n))(`${d("vUv")}`),l("position_"),l("normal")])};\n                        `:`\n                        ${d("localPosition")}=position_;\n                        ${d("localNormal")}=normal;\n                        `}\n                    `:""}\n                `:""},uvmapping_fragment:function(n){return n.useUV?`\n                uvToUse = ${p("vUv")}.xy;\n                ${n.mappingType>-1&&!0===n.mappingUseFragment?`uvToUse = ${u("applyMappingOperator","v2",[s("uvToUse"),l(`${p("localPosition")}`),l(`${p("localNormal")}`)])};`:""}\n                ${n.PDSFX?`_uvToUse = ${g()}(uvToUse.xy, ${p("vUv")}.zw);`:""}\n                `:""},map_fragment:function(n){return n.map||n.pdsfxUseMap?`\n                ${g("texelColor")}  = ${g()}(1.0, 1.0, 1.0, 1.0);\n                ${n.map?`\n                    ${n.envMapHDR&&!n.envMapRGBHDR?`\n                        ${f("texelSizeMap")} = ${f()}(1.0 / ${$("mapHDRSize")});\n                        texelColor = ${u("texture2DBilinearFromRGBE","v4",[(n=>o.parameterT2(n))("map"),s("uvToUse"),s(`${$("mapHDRSize")}`),s("texelSizeMap")])};\n                        `:`\n                        texelColor = ${i.sample2DTexture("map","uvToUse")};\n                        ${n.gammaInput?`\n                            ${h("convertedTexelColor")} = ${u("convertToLinear","v3",[l("texelColor.xyz")])};\n                            texelColor.x = convertedTexelColor.x;\n                            texelColor.y = convertedTexelColor.y;\n                            texelColor.z = convertedTexelColor.z;\n                            `:""}\n                        `}\n                    `:""}\n                ${n.pdsfxUseMap?`\n                    ${g("pdsfxDiffTexel")} = ${u("_ComputeDiffuseTexel","v4",[])};\n                    ${n.gammaInput?`\n                        ${h("convertedPDSFXTexelColor")} = ${u("convertToLinear","v3",[l("pdsfxDiffTexel.xyz")])};\n                        pdsfxDiffTexel.x = convertedPDSFXTexelColor.x;\n                        pdsfxDiffTexel.y = convertedPDSFXTexelColor.y;\n                        pdsfxDiffTexel.z = convertedPDSFXTexelColor.z;\n                        `:""}\n                    texelColor *= pdsfxDiffTexel;\n                    `:""}\n                gl_FragColor = gl_FragColor * texelColor;\n                `:""}}}),define("DS/ShaderBuilders/Commons/VerticeShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=e.ParameterUtils,i=e.FunctionHandler,s=()=>a.dereference(),l=n=>o.parameterF(n),u=n=>o.parameterV3(n),m=n=>o.parameterInOutV3(n),$=n=>o.parameterRefV3(n),c=(n,e,t)=>i.declareFunction(n,e,t),p=(n,e,t)=>i.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=n=>t.addObjectUniform(n),g=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},v=(n=null)=>{var e={name:n};return a.int(e)},S=(n=null)=>{var e={name:n};return a.float(e)},x=(n=null)=>{var e={name:n};return a.vec2(e)},y=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},_=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},T=(n=null)=>{var e={name:n};return a.mat4(e)},D=n=>{var e={name:n,constant:!0};return a.float(e)},C=n=>r.addVarying(n),P=n=>r.getVarying(n,r.ShaderStages.in),N=n=>r.getVarying(n,r.ShaderStages.out),M=n=>r.getBuiltin(n,r.ShaderStages.out);var b=function(n){return n.needTangentBinormal?`\n            ${C({varyingName:"vTangent",varyingType:"v3"})}\n            ${C({varyingName:"vBinormal",varyingType:"v3"})}\n        `:""},w=function(e){return`\n            ${_("mvPosition")} ;\n            ${n.getModelViewTransformationChunk("mvPosition",`${_()}( vertexLocalPosition, 1.0 )`,e)}\n            mvPosition.w = 1.0;\n        `},U=function(n){return`\n        ${p("ProcessViewTangentSpace",null,[((n,e,t=!1)=>o.parameterRef(n,e,t))("TangentSpace","_viewTangentSpace",!0)])};\n        mvPosition.x = _viewTangentSpace.Position.x;\n        mvPosition.y = _viewTangentSpace.Position.y;\n        mvPosition.z = _viewTangentSpace.Position.z;\n        ${n.sizeAttenuation?"INTERNAL_backup_sizeForGLPointSize *= INTERNAL_backup_scale / length( mvPosition.xyz );":""}\n        ${n.needTangentBinormal?`\n            ${N("vTangent")} = _viewTangentSpace.Tangent;\n            ${N("vBinormal")} = _viewTangentSpace.Binormal;\n            `:""}\n        `};return{tangent_Binormal_pars:b,tangent_Binormal_vertex:function(e){return e.needTangentBinormal?e.gpuTangentBinormal&&!e.displacementMap?"":`\n        ${e.skinning?`\n            ${y("objectTangent")}  = ${y()}(skinMatrix * ${_()}( tangent, 0.0 ));\n            ${y("objectBinormal")}  = ${y()}(skinMatrix * ${_()}( binormal, 0.0 ));\n            `:`\n            ${y("objectTangent")}  = tangent;\n            ${y("objectBinormal")}  = binormal;\n            `}\n        ${y("mvTangent")} ;\n        ${y("mvBinormal")} ;\n        if (use_normal_matrix) {\n            ${n.getNormalMatrixUnitVectorTransformationChunk("mvTangent","objectTangent",e)}\n            ${n.getNormalMatrixUnitVectorTransformationChunk("mvBinormal","objectBinormal",e)}\n        } else {\n            ${n.getModelViewUnitVectorTransformationChunk("mvTangent","objectTangent",e)}\n            ${n.getModelViewUnitVectorTransformationChunk("mvBinormal","objectBinormal",e)}\n        }\n\n        ${N("vTangent")} = mvTangent;\n        ${N("vBinormal")} = mvBinormal;\n\n        ${e.PDSFX?`\n            _viewTangentSpace.Tangent = ${N("vTangent")};\n            _viewTangentSpace.Binormal = ${N("vBinormal")};\n            `:""}\n        `:""},needCheckNaNonTangentBinormal:function(n){return n.alphaTest||n.skipTranspar||n.PDSFX||n.isDecal||n.useOIT||n.subsurface},tangent_Binormal_pars_fragment:function(n){var e=`     \n        ${c("getGeomT","v3",[u("N")])} {\n            ${y("normN")}  = normalize(N);\n            ${S("x")} = normN.x;\n            ${S("y")} = normN.y;\n            ${S("z")} = normN.z;\n\n            ${y("T")} = ${y()}(0.0);\n\n            if ( abs(z) > 0.0) {\n                T.y += 0.0;\n                T.x += 1.0;\n                T.z += - x / z;\n                return normalize(T);\n            }\n            if ( abs(y) > 0.0) {\n                T.x += 0.0;\n                T.z += 1.0;\n                T.y += - z / y;\n                return normalize(T);\n            }\n\n            if ( abs(x) > 0.0) {\n                T.z += 0.0;\n                T.y += 1.0;\n                T.x += - y / x;\n                return normalize(T);\n            }\n            return ${y()}(0.0);\n        }\n\n        ${c("getGeomB","v3",[u("N"),u("T")])} {\n            ${y("tmp1")} = normalize(N);\n            ${y("tmp2")} = normalize(T);\n            return normalize(cross(tmp1, tmp2));\n        }\n        `;return n.needTangentBinormal?`\n            ${b(n)}\n\n            ${e}\n\n            ${c("computeGPUTB",null,[u("i_viewPosition"),u("i_normal"),m("io_tangent"),m("io_binormal")])} {\n\n                ${y("p_x")} = ${n.WebGPU?"dpdx":"dFdx"}( -i_viewPosition.xyz );\n                ${y("p_y")} = ${n.WebGPU?"dpdy":"dFdy"}( -i_viewPosition.xyz );\n                ${n.useUV?`\n                    ${x("tc_x")} = ${n.WebGPU?"dpdx":"dFdx"}( uvToUse.xy );\n                    ${x("tc_y")} = ${n.WebGPU?"dpdy":"dFdy"}( uvToUse.xy );\n                    `:`\n                    ${x("tc_x")}  = ${x()}(0.0);\n                    ${x("tc_y")}  = ${x()}(0.0);\n                    `}\n\n                ${S("alphaT")} = step(0.00001, abs(tc_x.y) + abs(tc_y.y));\n                ${S("alphaB")} = step(0.00001, abs(tc_x.x) + abs(tc_y.x));\n                ${S("alphaBT")} = 1.0 - max(alphaB, alphaT);\n\n                tc_x.y = alphaT * tc_x.y - (1.0 - alphaT)*(alphaB * tc_y.x);\n                tc_y.y = alphaT * tc_y.y + (1.0 - alphaT)*(alphaB * tc_x.x) + alphaBT;\n\n                tc_x.x = alphaB * tc_x.x - (1.0 - alphaB)*(alphaT * tc_y.y) + alphaBT;\n                tc_y.x = alphaB * tc_y.x + (1.0 - alphaB)*(alphaT * tc_x.y);\n\n                ${s()}io_tangent = normalize(  p_x * tc_y.y - p_y * tc_x.y );\n                ${s()}io_binormal = normalize(  p_y * tc_x.x - p_x * tc_y.x);\n\n                ${y("x")} = cross(i_normal,${s()}io_tangent);\n                ${s()}io_tangent = normalize(cross(x,i_normal));\n                x = cross(${s()}io_binormal,i_normal);\n                ${s()}io_binormal = normalize(cross(i_normal,x));\n            }\n            ${this.needCheckNaNonTangentBinormal(n)?`${c("isVectorValid","b",[u("vector")])} {\n                    return (( vector.x < 0.0 || 0.0 < vector.x || vector.x == 0.0 ) && ( vector.y < 0.0 || 0.0 < vector.y || vector.y == 0.0 ) && ( vector.z < 0.0 || 0.0 < vector.z || vector.z == 0.0 ) && length(vector)!=0.0);\n                }`:""}\n        `:e},tangent_Binormal_fragment:function(e){return e.needTangentBinormal?`\n        ${y("fragmentTangent")} ;\n        ${y("fragmentBinormal")} ;\n        ${e.PDSFX?`\n            ${y("viewPositionTB")}  = INTERNAL_computed_viewPosition;\n            ${y("normalTB")}  = INTERNAL_computed_viewNormal;\n            `:`\n            ${e.isDecal?`\n                ${y("viewPositionTB")}  = dViewPosition;\n                ${y("normalTB")}  = decalNormal;\n                `:`\n                ${y("viewPositionTB")} = ${P("vViewPosition")};\n                ${y("normalTB")} = ${P("vNormal")};\n                `}\n            `}\n        ${e.gpuTangentBinormal?p("computeGPUTB",null,[u("viewPositionTB"),u("normalTB"),$("fragmentTangent"),$("fragmentBinormal")])+";":`\n            ${e.PDSFX?"\n                fragmentTangent =  INTERNAL_varying_viewTangent ;\n                fragmentBinormal = INTERNAL_varying_viewBinormal ;\n                ":`\n                fragmentTangent = ${P("vTangent")};\n                fragmentBinormal = ${P("vBinormal")};\n                `}\n            `}\n        ${e.mappingType>-1&&!0===e.mappingUseFragment&&!e.isDecal?`\n            if(${f("mappingType")}>0){\n                fragmentTangent = normalize( tangent );\n                fragmentBinormal = normalize( binormal );\n                if (use_normal_matrix){\n                    ${n.getNormalMatrixUnitVectorTransformationChunk("fragmentTangent","fragmentTangent",e)}\n                    ${n.getNormalMatrixUnitVectorTransformationChunk("fragmentBinormal","fragmentBinormal",e)}\n\n                } else {\n\n                    ${n.getModelViewUnitVectorTransformationChunk("fragmentTangent","fragmentTangent",e)}\n                    ${n.getModelViewUnitVectorTransformationChunk("fragmentBinormal","fragmentBinormal",e)}\n                }\n            }\n            `:""}\n        \n        if(${this.needCheckNaNonTangentBinormal(e)?"!isVectorValid(fragmentTangent) || !isVectorValid(fragmentBinormal)":"dot(fragmentTangent,fragmentTangent)<1e-6 || dot(fragmentBinormal,fragmentBinormal)<1e-6"}){\n            fragmentTangent = ${p("getGeomT","v3",[u("normalTB")])};\n            fragmentBinormal = ${p("getGeomB","v3",[u("normalTB"),u("fragmentTangent")])};\n        }\n\n        tangent = normalize(fragmentTangent);\n        binormal = normalize(fragmentBinormal);\n        `:""},_worldpos_vertex:function(n){return`\n            ${_("worldPosition")} = ${_()}( vertexLocalPosition, 1.0 );\n            worldPosition = ${p("getModelTransformation","v4",[(n=>o.parameterV4(n))("worldPosition")])};\n        `},morphtarget_pars_vertex:function(n){return n.morphTargets?n.morphNormals?d({uniformName:"morphTargetInfluences",uniformType:"fv1",size:4}):d({uniformName:"morphTargetInfluences",uniformType:"fv1",size:8}):""},morphtarget_vertex:function(n){if(n.morphTargets){var e=`\n                ${y("morphed")} = ${y()}( 0.0 );\n                morphed += ( morphTarget0 - position_ ) * ${f("morphTargetInfluences")}[ 0 ];\n                morphed += ( morphTarget1 - position_ ) * ${f("morphTargetInfluences")}[ 1 ];\n                morphed += ( morphTarget2 - position_ ) * ${f("morphTargetInfluences")}[ 2 ];\n                morphed += ( morphTarget3 - position_ ) * ${f("morphTargetInfluences")}[ 3 ];\n            `;return n.morphNormals||(e=`\n                    ${e}\n                    morphed += ( morphTarget4 - position_ ) * ${f("morphTargetInfluences")}[ 4 ];\n                    morphed += ( morphTarget5 - position_ ) * ${f("morphTargetInfluences")}[ 5 ];\n                    morphed += ( morphTarget6 - position_ ) * ${f("morphTargetInfluences")}[ 6 ];\n                    morphed += ( morphTarget7 - position_ ) * ${f("morphTargetInfluences")}[ 7 ];\n                `),`\n                ${e}\n                morphed += position_;\n             `}return""},morphnormal_vertex:function(n){return n.morphNormals?`\n                ${y("morphedNormal")}  = ${y()}( 0.0 );\n\n                morphedNormal +=  ( morphNormal0 - normal ) * ${f("morphTargetInfluences")}[ 0 ];\n                morphedNormal +=  ( morphNormal1 - normal ) * ${f("morphTargetInfluences")}[ 1 ];\n                morphedNormal +=  ( morphNormal2 - normal ) * ${f("morphTargetInfluences")}[ 2 ];\n                morphedNormal +=  ( morphNormal3 - normal ) * ${f("morphTargetInfluences")}[ 3 ];\n\n                morphedNormal += normal;\n            `:""},skinning_pars_vertex:function(n){if(n.skinning){var e="";if(n.useEulerAngles&&(e=`\n                    ${e}\n                    ${c("getMatrixFromEulerAngles","m4",[u("angles"),u("offset")])}{\n\t\t\t\t\t\t${S("cosx")}  = cos(angles.y);\n\t\t\t\t\t\t${S("cosy")}  = cos(angles.z);\n\t\t\t\t\t\t${S("cosz")}  = cos(angles.x);\n\t\t\t\t\t\t${S("sinx")}  = sin(angles.y);\n\t\t\t\t\t\t${S("siny")}  = sin(angles.z);\n\t\t\t\t\t\t${S("sinz")}  = sin(angles.x);\n\n\t\t\t\t\t\t${S("cosycosz")}  = cosy*cosz;\n\t\t\t\t\t\t${S("sinxsiny")}  = sinx*siny;\n\t\t\t\t\t\t${S("a11")}  = cosycosz - sinxsiny*sinz;\n\t\t\t\t\t\t${S("a12")}  = -cosx*sinz;\n\t\t\t\t\t\t${S("a13")}  = cosz*siny + cosy*sinx*sinz;\n\t\t\t\t\t\t${S("a21")}  = cosz*sinxsiny + cosy*sinz;\n\t\t\t\t\t\t${S("a22")}  = cosx*cosz;\n\t\t\t\t\t\t${S("a23")}  = siny*sinz - cosycosz*sinx;\n\t\t\t\t\t\t${S("a31")}  = -cosx*siny;\n\t\t\t\t\t\t${S("a32")}  = sinx;\n\t\t\t\t\t\t${S("a33")}  = cosx*cosy;\n\t\t\t\t\t\t${T("bone")}  = ${T()}(\n\t\t\t\t\t\t\t\t\t${_()}(a11, a21, a31, 0.0),\n\t\t\t\t\t\t\t\t\t${_()}(a12, a22, a32, 0.0),\n\t\t\t\t\t\t\t\t\t${_()}(a13, a23, a33, 0.0),\n\t\t\t\t\t\t\t\t\t${_()}(offset, 1.0));\n\t\t\t\t\t\treturn bone;\n\t\t\t\t\t}\n                `),n.isMultiInstanced){const t=n.skinningInstancingMapsInfo.lastTextureSizeX.toFixed(1),r=n.skinningInstancingMapsInfo.lastTextureSizeY.toFixed(1),a=n.skinningInstancingMapsInfo.maxTextureSize.toFixed(1),o=n.skinningInstancingMapsInfo.nbBones.toFixed(1);e=`\n                    ${e}\n                    ${h({uniformName:"skinningInstancingMaps",uniformType:"t2v",size:n.skinningInstancingMapsInfo.nbTextures})} \n\n                    ${c("getBoneMatrix","m4",[l("i")])}{\n\n                        if (i >= 0.0) {\n                            ${S("real_instanceId")}  = instanceId/5.0 -1.0;\n                            ${S("matId")};\n                            ${n.useEulerAngles?`matId = real_instanceId * ${o} * 2.0 + 2.0 * i;`:`matId = real_instanceId * ${o} * 4.0 + 4.0 * i;`}\n                            ${v("texId")}  = ${v()}(floor(matId/(${a}*${a})));\n\n                            ${S("dx")};\n                            ${S("dy")};\n                            ${S("x")};\n                            ${S("y")};\n                            ${S("xyInTex")} = matId - ${S()}(texId) * (${a}*${a});\n                            if (texId == ${n.skinningInstancingMapsInfo.nbTextures} - 1) {\n                                dx = 1.0 / ${t};\n                                dy = 1.0 / ${r};\n                                y = floor(xyInTex/${t});\n                                x = xyInTex - y*${t};\n                            } else {\n                                dx = 1.0 / ${a};\n                                dy = 1.0 / ${a};\n                                y = floor(xyInTex/${a});\n                                x = xyInTex - y*${a};\n                            }\n\n                            ${y("v0")};\n                            ${y("v1")};\n                            ${y("v2")};\n                            ${y("v3")};\n                            v0 = ${i.sample2DTexture("skinningInstancingMaps[texId]",`${x()}(dx * (x + 0.5), dy * (y + 0.5))`)}.xyz;\n                            v1 = ${i.sample2DTexture("skinningInstancingMaps[texId]",`${x()}(dx * (x + 1.5), dy * (y + 0.5))`)}.xyz;\n                            ${n.useEulerAngles?"":`\n                                v2 = ${i.sample2DTexture("skinningInstancingMaps[texId]",`${x()}(dx * (x + 2.5), dy * (y + 0.5))`)}.xyz;\n                                v3 = ${i.sample2DTexture("skinningInstancingMaps[texId]",`${x()}(dx * (x + 3.5), dy * (y + 0.5))`)}.xyz;                      \n                                `}                        \n                            ${n.useEulerAngles?`\n                                ${y("offset")}  = v0;\n                                ${y("angles")}  = v1;\n                                ${T("bone")}  = ${p("getMatrixFromEulerAngles","m4",[u("angles"),u("offset")])};\n                                `:`${T("bone")}  = ${T()}(${_()}(v0, 0.0), ${_()}(v1, 0.0), ${_()}(v2, 0.0), ${_()}(v3, 1.0));`}\n                            return bone;\n                        } else {\n                            return ${T()}(1.0);\n                        }\n                    }\n                `}else{const t=n.skinningMapWidth.toFixed(1),r=n.skinningMapHeight.toFixed(1);e=`\n                    ${e}\n                    ${h({uniformName:"skinningMap",uniformType:"t2"})} \n                    ${c("getBoneMatrix","m4",[l("i")])}{\n                        if (i >= 0.0) {\n                            ${S("j")};\n                            ${n.useEulerAngles?"j = i * 2.0;":"j = i * 4.0;"}\n                            ${S("x")}  = mod( j, ${t} );\n                            ${S("y")}  = floor( j / ${t} );\n\n                            ${D("dx")}  = 1.0 / ${t};\n                            ${D("dy")}  = 1.0 / ${r};\n\n                            y = dy * ( y + 0.5 );\n\n                            ${y("v0")}  = ${i.sample2DTexture("skinningMap",`${x()}( dx * ( x + 0.5 ), y )`)}.xyz;\n                            ${y("v1")}  = ${i.sample2DTexture("skinningMap",`${x()}( dx * ( x + 1.5 ), y )`)}.xyz;\n                            ${n.useEulerAngles?"":`\n                                ${y("v2")}  = ${i.sample2DTexture("skinningMap",`${x()}( dx * ( x + 2.5 ), y )`)}.xyz;\n                                ${y("v3")}  = ${i.sample2DTexture("skinningMap",`${x()}( dx * ( x + 3.5 ), y )`)}.xyz;\n                                `}\n\n                            ${n.useEulerAngles?`\n                                ${y("offset")}  = v0;\n                                ${y("angles")}  = v1;\n                                ${T("bone")} = ${p("getMatrixFromEulerAngles","m4",[u("angles"),u("offset")])};\n                                `:`${T("bone")} = ${T()}(${_()}(v0, 0.0), ${_()}(v1, 0.0), ${_()}(v2, 0.0), ${_()}(v3, 1.0));`}\n                            return bone;\n                        } else {\n                            return ${T()}(1.0);\n                        }\n                    }\n                `}return e}return""},skinbase_vertex:function(n){return n.skinning?`\n                ${T("boneMatX")}  = ${p("getBoneMatrix","m4",[l("skinIndex.x")])};\n                ${T("boneMatY")}  = ${p("getBoneMatrix","m4",[l("skinIndex.y")])};\n                ${T("boneMatZ")}  = ${p("getBoneMatrix","m4",[l("skinIndex.z")])};\n                ${T("boneMatW")}  = ${p("getBoneMatrix","m4",[l("skinIndex.w")])};\n\n                ${T("skinMatrix")}  = skinWeight.x * boneMatX;\n                skinMatrix \t+= skinWeight.y * boneMatY;\n                skinMatrix \t+= skinWeight.z * boneMatZ;\n                skinMatrix \t+= skinWeight.w * boneMatW;\n            `:""},skinning_vertex:function(n){if(n.skinning){var e=`${_("skinned")} = skinMatrix * skinVertex;`;return e=n.morphTargets?`\n                    ${_("skinVertex")}  = ${_()}( morphed, 1.0 );\n                    ${e}\n                `:`\n                    ${_("skinVertex")}  = ${_()}( position_, 1.0 );\n                    ${e}\n                `}return""},skinnormal_vertex:function(n){return n.skinning?n.morphNormals?`${_("skinnedNormal")}  = skinMatrix * ${_()}( morphedNormal, 0.0 );`:`${_("skinnedNormal")}  = skinMatrix * ${_()}( normal, 0.0 );`:""},position_vertex:function(n){var e="\n        ";return n.skinning&&!n.displacementMap&&(e=`\n                ${e}\n                vertexLocalPosition = skinned.xyz;\n            `),n.skinning||!n.morphTargets||n.displacementMap||(e=`\n                ${e}\n                vertexLocalPosition = morphed;\n            `),n.displacementMap&&(e=`\n                ${e}\n                vertexLocalPosition = displacedPosition;\n            `),n.skinning||n.morphTargets||n.displacementMap||(e=`\n                ${e}\n                vertexLocalPosition = position_;\n            `),e},default_vertex:function(n){return`\n        ${w(n)}\n        ${n.PDSFX?`\n            _viewTangentSpace.Position = mvPosition.xyz;      \n            ${U(n)}\n            `:""}\n        ${M("position")} = ${g("projectionMatrix")} * mvPosition;\n        `},default_vertex_with_normal:function(n){return w(n)},defaultnormal_vertex:function(e){const t=p("getModelViewMatrix","m4",[]);return`\n\t\t${y("objectNormal")} ;\n        ${e.skinning&&!e.displacementMap?"objectNormal = skinnedNormal.xyz;":""}\n        \n        ${e.skinning||!e.morphNormals||e.displacementMap?"":"objectNormal = morphedNormal;"}\n\n        ${e.displacementMap?"objectNormal = displacedNormal;":""}\n\n        ${e.skinning||e.morphNormals||e.displacementMap?"":"objectNormal = normal;"}\n        ${e.flipSided?"objectNormal = -objectNormal;":""}\n\n        if (length(objectNormal) < 1e-6) {\n            if (${g("projectionMatrix")}[3][3] > 0.5) {\n                objectNormal = ${y()}(0.0,0.0,1.0);\n            } else {\n                objectNormal = normalize(-mvPosition.xyz);\n            }\n            ${e.billboard||e.fixedSize?`${p("setSimpleNodeData",null,[])};`:""}\n            objectNormal = (${_()}(objectNormal, 0.0) * ${t}).xyz;\n            ${e.billboard?`objectNormal = (${_()}(objectNormal, 0.0) * simpleNodeData.billboardMatrix).xyz;`:""}\n            objectNormal = normalize(objectNormal);\n        }\n\n        ${y("transformedNormal")} ;\n        if (use_normal_matrix) {\n            ${n.getNormalMatrixUnitVectorTransformationChunk("transformedNormal","objectNormal",e)}\n        } else {\n            ${n.getModelViewUnitVectorTransformationChunk("transformedNormal","objectNormal",e)}\n        }\n        transformedNormal = normalize(transformedNormal);\n        ${e.PDSFX?`\n            _viewTangentSpace.Position = mvPosition.xyz;\n            _viewTangentSpace.Normal = transformedNormal;\n            ${U(e)}\n            `:""}\n        ${M("position")} = ${g("projectionMatrix")} * mvPosition;\n        `}}}),define("DS/ShaderBuilders/Commons/DeferrableShaders",["DS/ShaderBuilders/Commons/DefaultShaders","DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=n=>i.parameterF(n),u=n=>i.parameterV2(n),m=n=>i.parameterV3(n),$=n=>i.parameterV4(n),c=(n,e,t)=>s.declareFunction(n,e,t),p=(n,e,t)=>s.callFunction(n,e,t),d=n=>t.addUniform(n),f=n=>{var e={uniformName:n};return t.getUniform(e)},h=n=>t.addGlobalUniform(n),g=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},v=n=>r.addVarying(n),S=n=>r.getVarying(n,r.ShaderStages.in),x=n=>r.getVarying(n,r.ShaderStages.out),y=n=>r.getBuiltin(n,r.ShaderStages.out),_=(n=null)=>{var e={name:n};return o.float(e)},T=(n=null)=>{var e={name:n};return o.vec2(e)},D=(n=null)=>{var e={name:n};return o.vec3(e)},C=(n=null)=>{var e={name:n};return o.vec4(e)},P=n=>{var e={name:n,constant:!0};return o.int(e)},N=n=>{var e={name:n,constant:!0};return o.float(e)};function M(n){return`\n        \n        ${c("shift_right","f",[l("v"),l("amt")])}{\n            ${_("fv")} = floor(v) + 0.5;\n            return floor(fv / exp2(amt));\n          }\n\n          ${c("shift_left","f",[l("v"),l("amt")])} {\n            return floor(v * exp2(amt) + 0.5);\n          }\n\n          ${c("mask_last","f",[l("v"),l("bits")])} {\n            return mod(v, ${p("shift_left","f",[l("1.0"),l("bits")])});\n          }\n\n          ${c("extract_bits","f",[l("num"),l("from"),l("to")])} {\n            ${_("fFrom")} = floor(from + 0.5);\n            ${_("fTo")} = floor(to + 0.5);\n            ${_("shifted")}  = ${p("shift_right","f",[l("num"),l("fFrom")])};\n            return ${p("mask_last","f",[l("shifted"),l("fTo - fFrom")])};\n          }\n  \n          ${c("encode_float","v4",[l("val")])} {\n            if (val == 0.0) {\n              return ${C()}(0, 0, 0, 0);\n            }\n            ${_("sign")} = 1.0;\n            if (val > 0.0) {\n                sign = 0.0;\n            }\n            ${_("aVal")} = abs(val);\n            ${_("exponent")}  = floor(log2(aVal));\n            ${_("biased_exponent")}  = exponent + 127.0;\n            ${_("fraction")}  = ((aVal / exp2(exponent)) - 1.0) * 8388608.0;\n            ${_("t")}  = biased_exponent / 2.0;\n            ${_("last_bit_of_biased_exponent")}  = fract(t) * 2.0;\n            ${_("remaining_bits_of_biased_exponent")}  = floor(t);\n            ${_("byte4")}  = ${p("extract_bits","f",[l("fraction"),l("0.0"),l("8.0")])} / 255.0;\n            ${_("byte3")}  = ${p("extract_bits","f",[l("fraction"),l("8.0"),l("16.0")])} / 255.0;\n            ${_("byte2")}  = (last_bit_of_biased_exponent * 128.0 + ${p("extract_bits","f",[l("fraction"),l("16.0"),l("23.0")])}) / 255.0;\n            ${_("byte1")}  = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n            return  ${C()}(byte4, byte3, byte2, byte1);\n          }\n        `}return{picking_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial&&n.specialPickingInstancing?v({varyingName:"pickingColor",varyingType:"v3"}):""},picking_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial&&n.specialPickingInstancing?`${x("pickingColor")} = specialMeshPicking;`:""},picking_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial?n.specialPickingInstancing?v({varyingName:"pickingColor",varyingType:"v3"}):d({uniformName:"pickingColor",uniformType:"v3"}):""},picking_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterial?n.specialPickingInstancing?`gl_FragColor = ${C()}( ${S("pickingColor")}, 1.0 );`:`gl_FragColor = ${C()}( ${f("pickingColor")}, 1.0 );`:""},picking_instancing_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?v({varyingName:"vInstancePickingColor",varyingType:"v3"}):""},picking_instancing_vertex:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?`\n            if (instanceId > 16777215.0) {\n              ${x("vInstancePickingColor")} = ${D()}(0.0);\n            } else {\n                ${x("vInstancePickingColor")} .r = floor(instanceId / 65536.0);\n                ${x("vInstancePickingColor")} .g = floor((instanceId - ${x("vInstancePickingColor")} .r * 65536.0) / 256.0);\n                ${x("vInstancePickingColor")} .b = floor(instanceId - ${x("vInstancePickingColor")} .r * 65536.0 - ${x("vInstancePickingColor")} .g * 256.0);\n                ${x("vInstancePickingColor")}  /= 255.0;\n            }\n            `:""},picking_instancing_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?v({varyingName:"vInstancePickingColor",varyingType:"v3"}):""},picking_instancing_fragment:function(n){return n.materialToUse===e.MaterialToUse.pickingMaterialInstancing?`gl_FragColor = ${C()}(${S("vInstancePickingColor")} , 1.0);`:""},depth_pars_vertex:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:return n.isDecal?"":v({varyingName:"clipPos_Deferred",varyingType:"v4"});default:return""}},depth_vertex:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:return n.isDecal?"":`${x("clipPos_Deferred")} = ${y("position")};`;default:return""}},depth_pars_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:var t="";return n.isDecal||(t=`\n                    ${t}\n                    ${v({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n                  `),n.materialToUse!==e.MaterialToUse.depthMaterial&&n.materialToUse!==e.MaterialToUse.depthRGBAMaterial||(t=`\n                  ${t}\n\n                  ${M()}\n      \n                  ${c("packRGBAFace","v4",[l("depth")])} {\n                    ${_("depthToUse")} = depth;\n                    ${n.extDerivatives?`\n                      ${_("dx")} = dFdx(depth);\n                      ${_("dy")} = dFdy(depth);\n                      depthToUse += sqrt(dx*dx + dy*dy) + DEPTH_PRECISION;\n                      `:"depthToUse += 2.0 *DEPTH_PRECISION;"}\n                    return ${p("packRGBA","v4",[l("depthToUse")])};\n                  }\n                  `),t;default:return""}},depth_fragment_face:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:var t=n.materialToUse===e.MaterialToUse.depthRGBAMaterial;return`\n                  ${n.isDecal?`\n                    ${t?`${C("encode")} = ${p("packRGBAFace","v4",[l("gl_FragDepthEXT")])};`:`${C("encode")} = ${p("encode_float","v4",[l("gl_FragDepthEXT")])};`}\n                    `:`\n                    ${_("depthValue")} = 0.5 + 0.5 * ${S("clipPos_Deferred")}.z / ${S("clipPos_Deferred")}.w;\n                    ${t?`${C("encode")}  = ${p("packRGBAFace","v4",[l("depthValue")])};`:`${C("encode")}  = ${p("encode_float","v4",[l("depthValue")])};`}\n                    `}\n                  gl_FragColor = encode;\n                `;default:return""}},depth_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.depthMaterial:case e.MaterialToUse.depthRGBAMaterial:var t=n.materialToUse===e.MaterialToUse.depthRGBAMaterial;return`\n                    ${_("depthValue")} = 0.5 + 0.5 * ${S("clipPos_Deferred")}.z / ${S("clipPos_Deferred")}.w;\n                    ${t?`${C("encode")}  = ${p("packRGBA","v4",[l("depthValue")])};`:`${C("encode")}  = ${p("encode_float","v4",[l("depthValue")])};`}\n                  gl_FragColor = encode;\n                `;default:return""}},normal_fragment:function(n){return n.materialToUse===e.MaterialToUse.normalMaterial?"\n                gl_FragColor.x = normal.x * 0.5 + 0.5;\n                gl_FragColor.y = normal.y * 0.5 + 0.5;\n                gl_FragColor.z = normal.z * 0.5 + 0.5;\n            ":""},lineic_normal_fragment:function(n){return n.materialToUse===e.MaterialToUse.normalMaterial?"\n                gl_FragColor.x = 0.5;\n                gl_FragColor.y = 0.5;\n                gl_FragColor.z = 0.5;\n            ":""},decal_normal_depth_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial||n.materialToUse===e.MaterialToUse.normalDepthMaterial&&!n.renderToFloatTexture?`\n            ${n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial?(n=>t.addObjectUniform(n))({uniformName:"decalStencilValue",uniformType:"f"}):""}\n\n            ${c("normalToOct22","v2",[m("normal")])}{\n              ${_("manNorm")}  = abs(normal.x) + abs(normal.y) + abs(normal.z);\n              ${_("oNx")}  = normal.x / manNorm;\n              ${_("oNy")}  = normal.y / manNorm;\n              if (normal.z < 0.0) {           \n                ${_("tmpx")}  = (1.0 - abs(oNy)) * ${p("signNotZero","f",[l("oNx")])};\n                ${_("tmpy")}  = (1.0 - abs(oNx)) * ${p("signNotZero","f",[l("oNy")])};\n                oNx = tmpx;\n                oNy = tmpy;\n              }\n              return floor((2047.0 * (0.5 * ${T()}(oNx, oNy) + 0.5))+0.5);\n            }\n            `:n.materialToUse===e.MaterialToUse.normalDepthIoRRoughnessMaterial?`\n            ${c("normalToOct24","f",[m("normal")])}{\n              ${_("manNorm")}  = abs(normal.x) + abs(normal.y) + abs(normal.z);\n              ${_("oNx")}  = normal.x / manNorm;\n              ${_("oNy")}  = normal.y / manNorm;\n              if (normal.z < 0.0) {              \n                ${_("tmpx")}  = (1.0 - abs(oNy)) * ${p("signNotZero","f",[l("oNx")])};\n                ${_("tmpy")}  = (1.0 - abs(oNx)) * ${p("signNotZero","f",[l("oNy")])};\n                oNx = tmpx;\n                oNy = tmpy;\n              }\n              ${T("compNormal")}  = floor((4095.0 * (0.5 * ${T()}(oNx, oNy) + 0.5))+0.5);\n              return compNormal.x * 4096.0 + compNormal.y;\n            }\n            `:""},normal_depth_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.normalDepthMaterial:case e.MaterialToUse.normalDepthIoRRoughnessMaterial:case e.MaterialToUse.decalNormalStencilDepthMaterial:var r=n.materialToUse===e.MaterialToUse.decalNormalStencilDepthMaterial,a=n.materialToUse===e.MaterialToUse.normalDepthMaterial,o=`            \n                ${n.isDecal?"gl_FragColor.w = gl_FragDepthEXT;":`\n                  ${_("depthValue")} = 0.5 + 0.5 * ${S("clipPos_Deferred")}.z / ${S("clipPos_Deferred")}.w;\n                  gl_FragColor.w = depthValue;\n                  `}\n                `;return r?o=`\n                    ${o}\n                    ${T("compNormal")} =  ${p("normalToOct22","v2",[m("normal")])};\n                    gl_FragColor.x = compNormal.x;\n                    gl_FragColor.y = compNormal.y;\n                    gl_FragColor.z = ${i="decalStencilValue",s={uniformName:i},t.getObjectUniform(s)};\n                  `:a?(o=`\n                    ${o}         \n                    gl_FragColor.xyz = normal * 0.5 + 0.5;\n                  `,n.renderToFloatTexture||(o=`\n                        ${o}\n                        ${T("compNormal")} =  ${p("normalToOct22","v2",[m("normal")])};\n                        gl_FragColor.x = compNormal.x;\n                        gl_FragColor.y = compNormal.y;\n                        ${T("packedForFloat16")} = ${p("packForFloat16","v2",[l("gl_FragColor.w")])};\n                        gl_FragColor.z = packedForFloat16.x;\n                        gl_FragColor.w = packedForFloat16.y;\n                      `)):o=`\n                    ${o}         \n                    gl_FragColor.x = ${p("normalToOct24","f",[m("normal")])};\n                    ${n.dspbr||n.specgloss?`\n                      gl_FragColor.z = materialData.roughness;\n                      gl_FragColor.y = 0.0;\n                      ${n.useTransparency?`\n                        ${n.dspbr?`\n                            ${n.thinWalled?"\n                              if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                gl_FragColor.y = 1.0;\n                              }\n                              ":"\n                              if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                gl_FragColor.y = materialData.adjustedIoR;\n                              }\n                              "}\n                            `:"\n                              if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                                gl_FragColor.y = 1.0;\n                              }\n                            "}\n                        `:""}\n                      \n                      `:"                \n                      gl_FragColor.z = 0.0;\n                      gl_FragColor.y = 0.0;\n                      "}\n                  `,o;default:return""}var i,s},lineic_normal_depth_fragment:function(n){switch(n.materialToUse){case e.MaterialToUse.decalNormalStencilDepthMaterial:return"   \n                    // no normals             \n                    gl_FragColor.x = 0.0;\n                    gl_FragColor.y = 0.0;\n                    // stencil id 0\n                    gl_FragColor.z = 0.0;    \n                    // near plane for depth       \n                    gl_FragColor.w = 0.0;\n                  ";default:return""}},shadowmap_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.shadowMapDepthMaterial?`\n            ${c("pack_depth_esm","v4",[l("depth")])}{\n              ${n.uintESM?`\n                ${_("esmDepth")}= exp(80.0*depth);\n                ${_("exposant")} = ceil(log(esmDepth)/log(10.0));\n                ${_("normDepth")} = esmDepth/pow(10.0,exposant);\n                return ${C()}(${p("packRGB","v3",[l("normDepth")])},exposant/255.0);\n                `:`return ${C()}(exp(80.0*depth),0.0,0.0,1.0);`}\n            }\n\n            ${c("pack_depth","v4",[l("depth")])}{\n              return ${p("packRGBA","v4",[l("depth")])};\n            }\n            `:""},shadowmap_fragment:function(n){return n.materialToUse===e.MaterialToUse.shadowMapDepthMaterial?`\n            ${n.subsurface?"":"\n              if (gl_FragColor.a < 1.0 - 1e-3) {\n                discard;\n              }\n              "}\n            ${C("finalData")} ;\n            ${n.isDecal?`${_("depth")} = gl_FragDepthEXT;`:`${_("depth")} = gl_FragCoord.z;`}\n            ${n.shadowMapType===e.ESMImprovedShadowMap||n.shadowMapType===e.ESMShadowMap?`finalData = ${p("pack_depth_esm","v4",[l("depth")])};`:`finalData = ${p("pack_depth","v4",[l("depth")])};`}\n            \n            ${2===n.WebGLVersion?"outFragColor = finalData;":"gl_FragColor = finalData;"}\n            `:n.materialToUse===e.MaterialToUse.transparentShadowMaterial&&n.subsurface?"discard;":""},highlight_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.highlightMaterial&&n.politeHighlight?`\n                ${v({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n            `:""},highlight_vertex:function(n){return n.materialToUse===e.MaterialToUse.highlightMaterial&&n.politeHighlight?`\n                ${x("clipPos_Deferred")} = ${y("position")};\n            `:""},highlight_pars_fragment:function(n,t){if(n.materialToUse!==e.MaterialToUse.highlightMaterial)return"";var r="";return r=n.mobileHL?`\n              ${r}\n              ${h({uniformName:t?"iHighlightLineicColor":"iHighlightColor",uniformType:"v4"})} \n              ${h({uniformName:"iHighlightIntensity",uniformType:"v2"})} \n            `:`\n              ${r}\n              ${h({uniformName:"highlightID",uniformType:"f"})} \n            `,n.politeHighlight&&(r=`\n              ${r}\n              ${v({varyingName:"clipPos_Deferred",varyingType:"v4"})}\n              ${n.noZObject?`${P("noZ")}  = 1;`:`${P("noZ")} = 0;`}\n              ${h({uniformName:"rgbaDepth",uniformType:"t2"})} \n\n              ${N("highlightBack")} = 0.66;\n              ${N("highlightFront")} = 0.33;\n\n              ${c("depthSampleTest","f",[u("coord"),l("depth")])}{\n                ${C("sampledTexture")}  = ${s.sample2DTexture("rgbaDepth","coord")};\n                ${_("fDepth")}  = ${p("unpackRGBA","f",[$("sampledTexture")])};\n                if ( fDepth  < depth) return highlightBack;\n                return highlightFront;\n              }\n\n              ${c("getDepthTestResult","f",[l("depth"),$("clipPos")])}{\n                ${T("coord")} = 0.5 + 0.5*clipPos.xy/clipPos.w;\n                return ${p("depthSampleTest","f",[u("coord"),l("depth - 2.38418579e-7")])};\n              }\n\n              ${c("getFaceDepthValue","f",[$("clipPos")])}{\n                if (noZ == 1) {\n                  return highlightFront;\n                }\n                ${n.isDecal?`${_("depth")} = gl_FragDepthEXT;`:`${_("depth")} = 0.5 + 0.5 * clipPos.z / clipPos.w;`}\n                ${_("faceDepth")}  = depth;\n                ${n.mobileDevice?"":`\n                    ${n.extDerivatives?`\n                        ${_("dx")}  = dFdx(depth);\n                        ${_("dy")}  = dFdy(depth);\n                        ${n.mobileHL?"faceDepth += 0.5 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);":"faceDepth += 0.9 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);"}\n                        `:"faceDepth += 1.5 *DEPTH_PRECISION;"}\n                    `}\n                return ${p("getDepthTestResult","f",[l("faceDepth"),$("clipPos")])};\n              }\n\n              ${c("getDepthValue","f",[$("clipPos")])}{\n                if (noZ == 1) {\n                  return highlightFront;\n                }\n                ${_("depth")} = 0.5 + 0.5 * clipPos.z / clipPos.w;\n                return ${p("getDepthTestResult","f",[l("depth"),$("clipPos")])};\n              }\n            `),r},highlight_fragment_face:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?"":`\n            ${D("I")} = ${D()}(0.0, 0.0, 1.0);\n            if (!(${g("projectionMatrix")}[3][3] > 0.0)) {\n              I = normalize( vPos.xyz );\n            }\n            ${_("reflectionFactor")}  = abs( dot( I, normal ) );\n            ${n.politeHighlight?`          \n              ${_("depthValue")}  = ${p("getFaceDepthValue","f",[$(S("clipPos_Deferred"))])};\n              if (noZ == 1) {\n                reflectionFactor = 0.8;\n              } else if (depthValue < 0.5) {\n                reflectionFactor = (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141;\n              }\n              ${n.mobileHL?`\n                ${_("colorA")};\n                if (depthValue > 0.5) {\n                    colorA = ${g("iHighlightIntensity")}.y;\n                } else {\n                    colorA = ${g("iHighlightIntensity")}.x;\n                }\n                gl_FragColor = ${C()}( ${g("iHighlightColor")}.xyz * reflectionFactor, colorA);\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n                `:`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, reflectionFactor, depthValue , 0.0 );`}\n              `:`\n              reflectionFactor = 1.0 - reflectionFactor;\n              ${n.mobileHL?`\n                gl_FragColor = ${C()}( ${g("iHighlightColor")}.xyz, (0.6 * reflectionFactor*reflectionFactor + 0.2)* ${g("iHighlightIntensity")}.x );\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n                `:`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, reflectionFactor * reflectionFactor , 0.0, 0.0 );`}\n              `}\n          `},highlight_fragment_edge:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?"":`\n          ${n.politeHighlight?`\n            ${n.mobileHL?`\n\t\t\t  ${n.wideLine?`\n                ${_("colorA")};\n                if (${p("getHalfWidth","f",[])} > 0.5) {\n                    colorA = 0.8;\n                } else {\n                    colorA = 1.0;\n                }\n                gl_FragColor = ${C()}( ${g("iHighlightLineicColor")}.xyz, colorA);\n                `:`gl_FragColor = ${C()}(  ${g("iHighlightLineicColor")}.xyz, 1.0);`}\n          \n              gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              `:`\n              ${_("wValue")}  = 1.0 / 255.0;\n              ${n.primitiveHighlight?"wValue = 2.0 / 255.0;":""}\n              ${n.adjacenceHighlight?`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0, highlightFront , wValue );`:`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0, ${p("getDepthValue","f",[$(S("clipPos_Deferred"))])} , wValue );`}\n              `}\n            `:`\n            ${n.mobileHL?`\n              gl_FragColor = ${C()}(  ${g("iHighlightLineicColor")}.xyz, 0.8 * ${g("iHighlightIntensity")}.x );\n              gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              `:`              \n              ${_("wValue")} = 1.0 / 255.0;\n              gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue );\n              `}\n            `}\n          `},highlight_fragment_point:function(n){return n.materialToUse!==e.MaterialToUse.highlightMaterial?"":`\n            ${n.mobileHL?`\t\t\n              ${n.politeHighlight?`       \n                gl_FragColor = ${C()}(  ${g("iHighlightLineicColor")}.xyz, 0.8);\n                `:`gl_FragColor = ${C()}(  ${g("iHighlightLineicColor")}.xyz, 0.8 * ${g("iHighlightIntensity")}.x );`}\n              gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              `:`\n              ${_("wValue")}= 3.0 / 255.0;\n              ${n.politeHighlight?`\n                ${n.primitiveHighlight?`\t\n                    wValue = 4.0 / 255.0;\n                    gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0 , ${p("getDepthValue","f",[$(S("clipPos_Deferred"))])}, wValue );\n                    `:`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue);`}\n                `:`gl_FragColor = ${C()}( ${g("highlightID")} / 255.0, 1.0 , 0.0, wValue );`}\n              `}\n          `},texcoord_pars_vertex:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n            ${v({varyingName:"vUv_deferred",varyingType:"v2"})}\n            ${v({varyingName:"vUv2_deferred",varyingType:"v2"})}\n            `:""},texcoord_vertex:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n            ${x("vUv_deferred")} = uv.xy;\n            ${x("vUv2_deferred")} = uv2.xy;\n            `:""},texcoord_pars_fragment:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n            ${v({varyingName:"vUv_deferred",varyingType:"v2"})}\n            ${v({varyingName:"vUv2_deferred",varyingType:"v2"})}\n            `:""},texcoord_fragment:function(n){return n.materialToUse===e.MaterialToUse.texCoordMaterial?`\n            gl_FragColor = ${C()}(  ${S("vUv_deferred")}.x,  ${S("vUv_deferred")}.y , ${S("vUv2_deferred")}.x,  ${S("vUv2_deferred")}.y);\n            `:""},_debug_common_face_fragment:function(n){var e="";return n.depthDebugMaterial&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    gl_FragColor.r = gl_FragCoord.z;\n                    gl_FragColor.g = gl_FragCoord.z;\n                    gl_FragColor.b = gl_FragCoord.z;\n                `),n.normalDebugMaterial&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    #ifdef GPU_OUTLINES\n                        gl_FragColor.r = 0.5;\n                        gl_FragColor.g = 0.5;\n                        gl_FragColor.b = 0.5;\n                \t#else\n                    \t${D("transfoNormal")} = 0.5 * normalize((${C()}(normal.xyz, 0.0) * ${g("viewMatrix")}).xyz) + 0.5;\n                        gl_FragColor.r = transfoNormal.x;\n                        gl_FragColor.g = transfoNormal.y;\n                        gl_FragColor.b = transfoNormal.z;\n                \t#endif\n                `),n.shadowMapDebugMaterial&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    ${n.dspbr||n.specgloss?"":"discard;"}\n                `),n.geomUVDebug&&(e=`\n                    ${e}                   \n                    gl_FragColor.a = 1.0;\n                    ${n.useUV?`\n                        ${D("uvResult")} = ${D()}(mod(${S("vUv")}.x, 1.0), mod(${S("vUv")}.y, 1.0), 0.0);\n                        gl_FragColor.r = uvResult.x;\n                        gl_FragColor.g = uvResult.y;\n                        gl_FragColor.b = uvResult.z;\n                        `:"\n                        gl_FragColor.r = 0.0;\n                        gl_FragColor.g = 0.0;\n                        gl_FragColor.b = 0.0;\n                        "}\n                `),n.mappingUVDebug&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    ${n.useUV?`\n                        ${D("uvResult")} = ${D()}(mod(uvToUse.x, 1.0), mod(uvToUse.y, 1.0), 0.0);\n                        gl_FragColor.r = uvResult.x;\n                        gl_FragColor.g = uvResult.y;\n                        gl_FragColor.b = uvResult.z;\n                        `:"\n                        gl_FragColor.r = 0.0;\n                        gl_FragColor.g = 0.0;\n                        gl_FragColor.b = 0.0;\n                        "}\n                `),n.geomUV2Debug&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    ${n.useUV&&(n.dspbr||n.specgloss)?`\n                        ${D("uvResult")} = ${D()}(mod(${S("vUv2")}.x, 1.0), mod(${S("vUv2")}.y, 1.0), 0.0);\n                        gl_FragColor.r = uvResult.x;\n                        gl_FragColor.g = uvResult.y;\n                        gl_FragColor.b = uvResult.z;\n                        `:"\n                        gl_FragColor.r = 0.0;\n                        gl_FragColor.g = 0.0;\n                        gl_FragColor.b = 0.0;\n                        "}\n                `),n.mappingUV2Debug&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;\n                    ${n.useUV&&(n.dspbr||n.specgloss)?`\n                        ${D("uvResult")} = ${D()}(mod(uv2ToUse.x, 1.0), mod(uv2ToUse.y, 1.0), 0.0);\n                        gl_FragColor.r = uvResult.x;\n                        gl_FragColor.g = uvResult.y;\n                        gl_FragColor.b = uvResult.z;\n                        `:"\n                        gl_FragColor.r = 0.0;\n                        gl_FragColor.g = 0.0;\n                        gl_FragColor.b = 0.0;\n                        "}\n                `),e},_debug_common_lineic_fragment:function(n){var e="";return n.depthDebugMaterial&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;               \n                    gl_FragColor.r = gl_FragCoord.z;\n                    gl_FragColor.g = gl_FragCoord.z;\n                    gl_FragColor.b = gl_FragCoord.z;\n                `),n.normalDebugMaterial&&(e=`\n                    ${e}\n                    gl_FragColor.a = 1.0;             \n                    gl_FragColor.r = 0.5;\n                    gl_FragColor.g = 0.5;\n                    gl_FragColor.b = 0.5;\n                `),(n.shadowMapDebugMaterial||n.geomUVDebug||n.mappingUVDebug||n.geomUV2Debug||n.mappingUV2Debug)&&(e=`\n                    ${e}\n                    discard;\n                `),e},oit_pars_vertex:function(n){return n.useOIT?!n.materialToUse===e.MaterialToUse.oitAccumMaterial?"":v({varyingName:"depthOITValue",varyingType:"f"}):""},oit_vertex:function(t){return t.useOIT?!t.materialToUse===e.MaterialToUse.oitAccumMaterial?"":`\n                ${n.getModelViewTransformationChunk(`${C("aux")}`,`${C()}(position_.xyz, 1.0)`,t)}\n                ${x("depthOITValue")} = aux.z;\n                ${_("m22")}  = ${g("projectionMatrix")}[2][2];\n                ${_("m32")}  = ${g("projectionMatrix")}[3][2];\n                ${_("near")}  = m32 / (m22 - 1.0);\n                ${_("far")}  = ((m22 - 1.0)*near)/(m22 + 1.0);\n                ${_("normalizeValue")}  = far + near;\n                ${x("depthOITValue")} /= 0.5*normalizeValue;\n            `:""},oit_vertex_point:function(n){return""},oit_pars_fragment:function(n){return n.useOIT?!n.materialToUse===e.MaterialToUse.oitAccumMaterial?"":`\n                ${v({varyingName:"depthOITValue",varyingType:"f"})}\n                ${c("getOITWeight","f",[l("depthValue")])} {\n                    ${_("distanceTerm")} = 0.3/ (1e-3 + pow(abs(depthValue), 4.0));\n\t\t\t\t\tdistanceTerm = clamp(distanceTerm, 1e-3, 3e3);\n                    return gl_FragColor.a * gl_FragColor.a * distanceTerm;\n                }\n            `:""},oit_fragment:function(n){if(!n.useOIT)return"";let t=n.materialToUse===e.MaterialToUse.oitAccumMaterial,r=n.materialToUse===e.MaterialToUse.oitRevealMaterial,a=n.materialToUse===e.MaterialToUse.originalMaterial||n.materialToUse===e.MaterialToUse._fakeOriginalMaterial;return`\n                ${t||r?"\n                    if (gl_FragColor.a > 1.0 - 1e-2) {\n                        discard;\n                    }\n                    ":`\n                    ${a?"\n                        if (gl_FragColor.a < 1.0 - 1e-2) {\n                            discard;\n                        }\n                        gl_FragColor.a = 1.0;\n                        ":""}\n                    `}\n                ${t?`\n                    gl_FragColor = ${C()}(gl_FragColor.rgb, 1.0)* ${p("getOITWeight","f",[l(S("depthOITValue"))])};\n                    `:`\n                    ${r?"\n                        gl_FragColor.r = gl_FragColor.a;\n                        ":""}\n                    `}\n            `},oit_fragment_point:function(n){if(!n.useOIT)return"";let t=n.materialToUse===e.MaterialToUse.oitAccumMaterial,r=n.materialToUse===e.MaterialToUse.oitRevealMaterial;return t||r?"discard;":""},gpupos_pars_vertex:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?"":v({varyingName:"vPos_deferred",varyingType:"v3"})},gpupos_vertex:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?"":`${x("vPos_deferred")} = ${p("getModelTransformation","v4",[m("position_.xyz")])}.xyz;`},gpupos_pars_fragment:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?"":`\n            ${v({varyingName:"vPos_deferred",varyingType:"v3"})}\n            ${d({uniformName:"positionComponent",uniformType:"v3"})} \n\n            ${M()}\n            `},gpupos_fragment:function(n){return n.materialToUse!==e.MaterialToUse.gpuPositionMaterial?"":n.useMRT?`\n              ${D("deferredPos")} = ${S("vPos_deferred")};\n              gl_FragData[0] = ${p("encode_float","v4",[l("deferredPos.x")])};\n              gl_FragData[1] = ${p("encode_float","v4",[l("deferredPos.y")])};\n              gl_FragData[2] = ${p("encode_float","v4",[l("deferredPos.z")])};\n              `:`\n            ${_("component")} = dot(${S("vPos_deferred")}.xyz,${f("positionComponent")});\n            gl_FragColor = ${p("encode_float","v4",[l("component")])};\n            `}}}),define("DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=n=>o.parameterV3(n),l=(n,e,t)=>i.callFunction(n,e,t),u=n=>e.addUniform(n),m=n=>{var t={uniformName:n};return e.getUniform(t)};let $=function(n,e,t){var r=m(`${n}UvSlot`),i=m(`${n}UvTransform`);return`\n            ${((n=null,e=0)=>{var t={name:n,size:e};return a.vec2(t)})(e)} = uvToUse;\n            if (${r} != 1) {\n                ${e} = uv2ToUse;\n            }\n            ${e} =  ${l("applyUVCombination","v2",[(n=>o.parameterV2(n))(e),((n,e)=>o.parameter(n,e))("m3",`${i}`)])};\n        `},c=function(n,e,t){return`\n            ${u({uniformName:e+"MulCoef",uniformType:n})}\n            ${u({uniformName:e+"AddCoef",uniformType:n})}\n        `},p=function(n,e,t,r){return`\n            ${t?`\n                ${u({uniformName:e+"Map",uniformType:"t2"})}\n                ${u({uniformName:e+"UvTransform",uniformType:"m3"})}\n                ${u({uniformName:e+"UvSlot",uniformType:"i"})}\n                `:u({uniformName:e,uniformType:n,materialType:r})}\n        `},d=function(n,e,t,r,a="f"){return r.PDSFX?{backup:`\n                ${n} = ${e};\n            `,solve:` \n                ${e} = ${l(t,a,[])};\n            `}:{backup:"",solve:""}};return{textureSlotString:$,addVec3MADs:function(n,e){return c("v3",n)},addVec2MADs:function(n,e){return c("v2",n)},addFloatMADs:function(n,e){return c("f",n)},addTexturableVec3Uniform:function(n,e,t){return p("v3",n,e,t)},addTexturableVec2Uniform:function(n,e){return p("v2",n,e)},addTexturableFloatUniform:function(n,e){return p("f",n,e)},addPDSFX:d,addColorPDSFX:function(n,e,t,r,a){if(!a.PDSFX)return{backup:"",solve:""};let o=d(n,e,t,a,"v3");return r&&(o.solve=`\n                ${o.solve}\n                if (!all(equal(${e}, ${n}))) {\t\t\t\n                    ${e} = ${l("convertToLinear","v3",[s(`${e}`)])};\n                }\n            `),o},addFloatParameterResolution:function(n,e,t,r,s,u,c="r",p=null,d=null,f=!0){const h=u.fromGLTF;let g=e+"UV",v=e+"Map",S=m(e+"MulCoef"),x=m(e+"AddCoef"),y=`${n} = ${i.sample2DTexture(v,g)}.${c};`;if(p){let e=`${n} = ${i.sample2DTexture(v,g)}.${p};`;if(d){let t=`${n} = ${i.sample2DTexture(v,g)}.${d};`;y=`\n                    ${h?`                     \n                        ${2===h?t:e}\n                        `:y}\n                `}else y=`\n                    ${h?e:y}\n                `}return`\n            ${s?((n=null)=>{var e={name:n};return a.float(e)})(n)+";":""}\n            ${t?`\n                ${$(e,g)}\n                ${y}\n                `:`\n                ${n} = ${m(e)};\n                `}\n            ${r?`\n                ${f?`\n                    ${n} = ${S} * ${n} + ${x};\n                    `:`\n                    ${n} = ${l("saturate","f",[(n=>o.parameterF(n))(`${S} * ${n} + ${x}`)])};\n                    `}\n                `:""}\n        `},addColorParameterResolution:function(n,e,t,r,o,u,c,p=!0){let d=e+"UV",f=e+"Map",h=m(e+"MulCoef"),g=m(e+"AddCoef"),v=`${n} = ${i.sample2DTexture(f,d)}.rgb;`;return`\n            ${u?((n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)})(n)+";":""}\n            ${t?`\n                ${$(e,d)}\n                ${v}\n                ${o?`${n} = ${l("convertToLinear","v3",[s(`${n}.rgb`)])};`:""}\n                `:`\n                ${n} = ${m(e)};\n                `}\n            ${r?`            \n                ${p?`\n                    ${n} = ${h} * ${n} + ${g};\n                    `:`\n                    ${n} = ${l("saturate","v3",[s(`${h} * ${n} + ${g}`)])};\n                    `}\n                `:""}\n        `},addBorderColorGeneric:function(n,e,t,r,a){return`     \n            ${t?`\n                if (${e}.x < 0.0 || ${e}.x > 1.0) {\n                    ${n} = ${m(a)};\n                }\n                `:""}\n            ${r?`\n                if (${e}.y < 0.0 || ${e}.y > 1.0) {\n                    ${n} = ${m(a)};\n                }\n                `:""}\n            `}}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t),l=[],u={__PDSFXComputeCommonValues_FS:function(n,e){return`\n                ${s("ComputeCommonValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeCommonValues_FS:function(n,e){return""},__PDSFXComputeDiscard_FS:function(n,e){return`\n                ${s("ComputeDiscard","b",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeDiscard_FS:function(n,e){return"return false;"},__PDSFX_ComputeDiffuseTexel_FS:function(n,e){return`\n                ${s("_ComputeDiffuseTexel","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFX_ComputeDiffuseTexel_FS:function(n,e){return`\n                return ${n.variableHandler.vec4()}(1.0);\n            `},__PDSFXComputeViewPosition_FS:function(n,e){return`\n                ${s("ComputeViewPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeViewPosition_FS:function(n,e){return"return INTERNAL_computedvar_viewPosition;"},__PDSFXComputeViewNormal_FS:function(n,e){return`\n                ${s("ComputeViewNormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeViewNormal_FS:function(n,e){return"return normalize(INTERNAL_computedvar_viewNormal);"},__PDSFXProcessFinalColor_FS:function(n,e){return`\n                ${s("ProcessFinalColor",null,[(n=>i.parameterInOutV4(n))("ioFinalColor")])} {\n                    ${e(n,["ioFinalColor"])}\n                }\n            `},PDSFXProcessFinalColor_FS:function(n,e){return""},__PDSFXProcessLinePattern_FS:function(n,e){return`\n                ${s("ProcessLinePattern",null,[(n=>i.parameterInOutF(n))("patternValue"),(n=>i.parameterF(n))("currentPixelDistance")])} {\n                    ${e(n,["ioFinalColor","currentPixelDistance"])}\n                }\n            `},PDSFXProcessLinePattern_FS:function(n,e){return""}};var m=function(n,e,t,r,a=!1){l.push({type:r,name:t,getterName:e}),u["PDSFX"+n+"_FS"]=function(n,e){return`return ${a?"normalize":""}(${t});`},u["__PDSFX"+n+"_FS"]=function(e,t){return`\n                    ${s(n,r,[])} {\n                        ${t(e,[])}\n                    }\n                `}},$=function(n,e,t){m(n,e,t,"f",!1)},c=function(n,e,t,r=!1){m(n,e,t,"v3",r)};return $("ComputeHalfWidth","vGetHalfWidth","INTERNAL_backup_halfWidth"),$("ComputeOpacity","vGetOpacity","_DSopacity_"),$("ComputeTranslucency","vGetTranslucency","INTERNAL_backup_translucency"),$("ComputeThickness","vGetThickness","INTERNAL_backup_thickness"),$("ComputeTransparency","vGetTransparency","INTERNAL_backup_transparency"),$("ComputeRoughness","vGetRoughness","INTERNAL_backup_roughness"),$("ComputeClearcoat","vGetClearcoat","INTERNAL_backup_clearcoat"),$("ComputeClearcoatRoughness","vGetClearcoatRoughness","INTERNAL_backup_clearcoatRoughness"),$("ComputeFlakeCoverage","vGetFlakeCoverage","INTERNAL_backup_flakesCoverage"),$("ComputeFlakeRoughness","vGetFlakeRoughness","INTERNAL_backup_flakesRoughness"),$("ComputeFlakeSize","vGetFlakeSize","INTERNAL_backup_flakesSize"),$("ComputeFlipFlop","vGetFlipFlop","INTERNAL_backup_flipFlop"),$("ComputeSheen","vGetSheen","INTERNAL_backup_sheen"),$("ComputeSheenRoughness","vGetSheenRoughness","INTERNAL_backup_sheenRoughness"),$("ComputeMetallic","vGetMetallic","INTERNAL_backup_metalness"),$("ComputeSpecular","vGetSpecular","INTERNAL_backup_specularContribution"),$("ComputeAnisotropy","vGetAnisotropy","INTERNAL_backup_anisotropy"),$("ComputeAnisotropyRotation","vGetAnisotropyRotation","INTERNAL_backup_anisotropyAngle"),$("ComputeIridescence","vGetIridescence","INTERNAL_backup_iridescence"),$("ComputeIridescenceThickness","vGetIridescenceThickness","INTERNAL_backup_iridescenceThickness"),c("ComputeEmissive","vGetEmissive","INTERNAL_backup_emissive"),c("ComputeSpecularReflectance","vGetSpecularReflectance","INTERNAL_backup_specular"),c("ComputeAlbedo","vGetAlbedo","INTERNAL_backup_diffuse"),c("ComputeClearcoatViewNormal",null,"INTERNAL_backup_clearcoatViewNormal",!0),c("ComputeClearcoatColor","vGetClearcoatColor","INTERNAL_backup_clearcoatColor"),c("ComputeTranslucencyColor","vGetTranslucencyColor","INTERNAL_backup_translucencyColor"),c("ComputeFlakeColor","vGetFlakeColor","INTERNAL_backup_flakesColor"),c("ComputeFlipFlopColor","vGetFlipFlopColor","INTERNAL_backup_flipFlopColor"),c("ComputeSheenColor","vGetSheenColor","INTERNAL_backup_sheenColor"),{PDSFXFragmentEntryPointsShaders:u,__backUpVariablesFragment:l}}),define("DS/ShaderBuilders/PBRUtils/PBRFragmentUniformsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=a.FunctionHandler,l=()=>o.dereference(),u=(n,e,t=!1)=>i.parameter(n,e,t),m=(n,e,t=!1)=>i.parameterInOut(n,e,t),$=(n,e,t=!1)=>i.parameterRef(n,e,t),c=n=>i.parameterF(n),p=n=>i.parameterInOutF(n),d=n=>i.parameterRefF(n),f=n=>i.parameterI(n),h=n=>i.parameterV2(n),g=n=>i.parameterInOutV2(n),v=n=>i.parameterRefV2(n),S=n=>i.parameterV3(n),x=n=>i.parameterInOutV3(n),y=n=>i.parameterRefV3(n),_=n=>i.parameterV4(n),T=(n,e,t)=>s.declareFunction(n,e,t),D=(n,e,t)=>s.callFunction(n,e,t),C=n=>r.getVarying(n,r.ShaderStages.in),P=n=>r.getShaderOutput(n),N=n=>t.addUniform(n),M=n=>{var e={uniformName:n};return t.getUniform(e)},b=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},w=(n=null)=>{var e={name:n};return o.bool(e)},U=(n=null)=>{var e={name:n};return o.int(e)},z=(n=null)=>{var e={name:n};return o.float(e)},V=(n=null,e=0)=>{var t={name:n,size:e};return o.vec2(t)},F=(n=null,e=0)=>{var t={name:n,size:e};return o.vec3(t)},R=(n=null,e=0)=>{var t={name:n,size:e};return o.vec4(t)},A=(n=null)=>{var e={name:n};return o.mat3(e)},I=n=>{var e={name:n,constant:!0};return o.int(e)},L=n=>{var e={name:n,constant:!0};return o.float(e)},B=n=>`max(${n}, 0.0)`,k=n=>D("saturate","f",[c(n)]),E=n=>D("vMax","v3",[S(n)]),O=n=>D("vMax","v4",[_(n)]),G=n=>D("vMin","v4",[_(n)]),H=n=>D("pow2","f",[c(n)]),X=n=>D("pow3","f",[c(n)]),W=n=>D("pow5","f",[c(n)]),j=n=>D("pow6","f",[c(n)]),q=n=>D("vNormalize","v3",[S(n)]),Z=(n,e,t)=>D("affine","f",[c(n),c(e),c(t)]),J=(n,e,t,r,a)=>D("arrayFBMMixer","f",[S(n),c(e),c(t),c(r),c(a)]),Y=n.TextureBlendOperations;let K,Q,nn,en,tn,rn,an,on,sn,ln,un,mn,$n,cn,pn;{let n=function(n){return`\n\n            ${N({uniformName:"diffuse",uniformType:"v3",materialName:"color",materialType:"color"})}   \n            ${n.map?`\n                ${N({uniformName:"map",uniformType:"t2"})}   \n                ${N({uniformName:"diffuseUvTransform",uniformType:"m3"})}\n                ${N({uniformName:"_colorOverride",uniformType:"i"})}\n                ${N({uniformName:"diffuseUvSlot",uniformType:"i"})}\n                ${n.diffuseBorderColorU||n.diffuseBorderColorV?N({uniformName:"diffuseBorderColor",uniformType:"v4",materialName:"map.borderColor",materialType:"position"}):""}\n                `:""}\n            ${n.diffuseMulCoef&&n.diffuseAddCoef?`${e.addVec3MADs("diffuse",n)}`:""}\n        `};K=function(t){const r=e.addColorPDSFX("INTERNAL_backup_diffuse","albedo","ComputeAlbedo",t.dspbr&&t.gammaInput,t);let a=`\n\n                ${F("albedo")} = ${M("diffuse")};\n                ${t.vertexColors?`albedo *= ${C("vColor")}.rgb;`:""}\n                ${t.map?`\n                    ${e.textureSlotString("diffuse","diffuseUV",t)}\n                    ${t.visuBasicForceDiffuseUV?"diffuseUV = VisuBasic_diffuseTexUvToUse;":""}\n                    ${R("texelAlbedo")} = ${s.sample2DTexture("map","diffuseUV")};\n                    ${e.addBorderColorGeneric("texelAlbedo","diffuseUV",t.diffuseBorderColorU,t.diffuseBorderColorV,"diffuseBorderColor")}\n                    ${t.gammaInput&&!t.mapHDR?`texelAlbedo = ${R()}(${D("convertToLinear","v3",[S("texelAlbedo.rgb")])}, texelAlbedo.a);`:""}\n                    if(${M("_colorOverride")} == 1) {\n                        texelAlbedo = ${R()}(albedo, texelAlbedo.a);\n                    }\n                    ${t.textureBlending>=0?`              \n                        ${(()=>{switch(t.textureBlending){case Y.BLEND:return"albedo = mix(albedo, texelAlbedo.rgb, texelAlbedo.w);";case Y.MODULATE:return"albedo *= texelAlbedo.rgb;";case Y.DECAL:return`albedo = mix(albedo, ${F()}(1.0), texelAlbedo.rgb);`;case Y.IGNORE:return"";case Y.REPLACE:default:return"albedo = texelAlbedo.rgb;"}})()}\n                        `:"albedo = texelAlbedo.rgb;"}\n                    `:""}\n\n                ${t.diffuseMulCoef&&t.diffuseAddCoef?`\n                    albedo = albedo * ${M("diffuseMulCoef")} + ${M("diffuseAddCoef")};\n                    albedo = ${(n=>D("saturate","v3",[S(n)]))("albedo")};\n                    `:""}\n                ${r.backup}\n            `,o=`\n               \n                ${r.solve}\n\n                ${t.reflectivityEnvMap?`\n                    ${F("cameraToVertexLegacy")} ;\n                    if (${b("projectionMatrix")}[3][3] > 0.5) {\n                        cameraToVertexLegacy = normalize( ${F()}( ${R()}( 0.0,0.0,-1.0, 0.0 ) * ${b("viewMatrix")} ) );\n                    } else {\t\n                        cameraToVertexLegacy = normalize( ${F()}( ${R()}( -surfaceData.viewPosition, 0.0 ) * ${b("viewMatrix")} ));\n                    }\n                    ${F("reflectVecLegacy")}  = reflect( cameraToVertexLegacy, surfaceData.worldNormal );\n                    albedo = ${D("sampleReflectivityEnvMap","v3",[S("reflectVecLegacy.yzx"),S("albedo")])};\n                    `:""}\n            `;return[n(t),o,a]}}{let n=function(n){return`\n            ${n.normalMap?`\n                ${N({uniformName:"normalMap",uniformType:"t2"})}  \n                ${N({uniformName:"normalUvTransform",uniformType:"m3"})}  \n                ${N({uniformName:"normalUvSlot",uniformType:"i"})}  \n                ${n.specgloss?`\n                    ${N({uniformName:"normalScale",uniformType:"v2"})}  \n                    ${n.normalScaleMap?`     \n                        ${N({uniformName:"normalScaleMap",uniformType:"t2"})}  \n                        ${N({uniformName:"normalScaleUvTransform",uniformType:"m3"})}  \n                        ${N({uniformName:"normalScaleUvSlot",uniformType:"i"})}  \n                        `:""}             \n                    ${n.normalScaleMulCoef&&n.normalScaleAddCoef?`${e.addFloatMADs("normalScale",n)}`:""}    \n                    `:`                   \n                    ${n.normalMulCoef&&n.normalAddCoef?`${e.addVec3MADs("normal",n)}`:""}\n                    `}\n                ${T("perturbNormal3Arb","v3",[S("surf_norm"),S("surf_tgt"),S("surf_binorm"),h("normalUV"),h("scale")])}{\n\n                    ${F("N")} = normalize(surf_norm);\n                    ${F("T")} = normalize(surf_tgt);\n                    T = normalize(T - dot(T, N) * N);\n                    ${F("B")} = normalize(surf_binorm);\n\n                    ${F("mapN")}  = ${s.sample2DTexture("normalMap","normalUV")}.xyz * 2.0 - 1.0;\n\n                    ${n.specgloss?`\n                        mapN = ${F()}(scale * mapN.xy, mapN.z);\n                        ${n.normalMapFlipY?"mapN.y = - mapN.y;":""}\n                        `:`\n                        ${n.normalMulCoef&&n.normalAddCoef?`mapN = mapN * ${M("normalMulCoef")} + ${M("normalAddCoef")};`:""}\n                        mapN.z = abs(mapN.z);\n                        `}\n\n                    ${A("tbn")} = ${A()}(T, B, N);\n                    return normalize(tbn * mapN);\n\n                }\n                `:""}\n\n            ${n.specgloss&&n.bumpMap?`\n                ${N({uniformName:"bumpMap",uniformType:"t2"})}  \n                ${N({uniformName:"bumpUvTransform",uniformType:"m3"})}  \n                ${N({uniformName:"bumpUvSlot",uniformType:"i"})}  \n                ${N({uniformName:"bumpScale",uniformType:"f"})}  \n                ${n.bumpScaleMap?`    \n                    ${N({uniformName:"bumpScaleMap",uniformType:"t2"})}  \n                    ${N({uniformName:"bumpScaleUvTransform",uniformType:"m3"})}  \n                    ${N({uniformName:"bumpScaleUvSlot",uniformType:"i"})}  \n                    `:""}\n                ${n.bumpScaleMulCoef&&n.bumpScaleAddCoef?`${e.addFloatMADs("bumpScale",n)}`:""}\n                \n                ${T("dHdxy_fwd","v2",[h("bumpMapUv"),c("scale")])}{\n\n                    ${V("dSTdx")} = dFdx( bumpMapUv );\n                    ${V("dSTdy")} = dFdy( bumpMapUv );\n\n                    ${z("Hll")} = scale * ${s.sample2DTexture("bumpMap","bumpMapUv")}.x;\n                    ${z("dBx")} = scale * ${s.sample2DTexture("bumpMap","bumpMapUv + dSTdx")}.x - Hll;\n                    ${z("dBy")} = scale * ${s.sample2DTexture("bumpMap","bumpMapUv + dSTdy")}.x - Hll;\n\n                    return ${V()}( dBx, dBy );\n\n                }\n                ${T("perturbNormalArb","v3",[S("surf_pos"),S("surf_norm"),h("dHdxy")])}{\n\n                    ${F("vSigmaX")}  = dFdx( surf_pos );\n                    ${F("vSigmaY")}  = dFdy( surf_pos );\n                    ${F("vN")}  = surf_norm;\n\n                    ${F("R1")}  = cross( vSigmaY, vN );\n                    ${F("R2")}  = cross( vN, vSigmaX );\n\n                    ${z("fDet")}  = dot( vSigmaX, R1 );\n\n                    ${F("vGrad")}  = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n                    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n                }\n                `:""}\n        `},t=function(n,t){return`     \n            ${F("viewNormal")};\n            ${n.PDSFX?"viewNormal = INTERNAL_computed_viewNormal;":` \n                viewNormal = normalize( ${C("vNormal")} );\n                ${n.isDecal?"viewNormal = decalNormal;":""}\n                `}\n\n            viewNormal = viewNormal * ( -1.0 + 2.0 * ${z()}( ${(n=>r.getBuiltin(n,r.ShaderStages.in))("frontFacing")} ) );\n\n            surfaceData.viewNormal = viewNormal;\n\n            ${n.normalMap?`\n                ${e.textureSlotString("normal","normalUv",n)}\n                ${n.specgloss?`\n                    ${n.normalScaleMap?`\n                        ${e.textureSlotString("normalScale","normalScaleUv",n)}\n                        ${V("scale")}  = ${V()}(${s.sample2DTexture("normalScaleMap","normalScaleUv")}.r);\n                        `:`${V("scale")} = ${M("normalScale")};`}\n                    ${n.normalScaleAddCoef&&n.normalScaleMulCoef?`scale = ${M("normalScaleMulCoef")} * scale + ${M("normalScaleAddCoef")};`:""}\n                    `:`${V("scale")} = ${V()}(1.0);`}\n                surfaceData.viewNormal = ${D("perturbNormal3Arb","v3",[S("viewNormal"),S("tangent"),S("binormal"),h("normalUv"),h("scale")])};\n                `:`\n                ${n.specgloss&&n.bumpMap?`      \n                    ${e.textureSlotString("bump","bumpUv",n)}   \n                    ${n.bumpScaleMap?`\n                        ${e.textureSlotString("bumpScale","bumpScaleUv",n)} \n                        ${z("scale")} = ${s.sample2DTexture("bumpScaleMap","bumpScaleUv")}.r;\n                        `:`${z("scale")} = ${M("bumpScale")};`}\n                    ${n.bumpScaleAddCoef&&n.bumpScaleMulCoef?`scale = ${M("bumpScaleMulCoef")} * scale + ${M("bumpScaleAddCoef")};`:""}\n                    ${V("bumpDHD")}  = ${D("dHdxy_fwd","v2",[h("bumpUv"),c("scale")])};\n                    surfaceData.viewNormal = ${D("perturbNormalArb","v3",[S("-surfaceData.viewPosition"),S("viewNormal"),h("bumpDHD")])};\n                    `:""}\n                `}\n\n            ${t&&(n.envMap||n.useIBLColor||n.reflectivityEnvMap||n.specGlossFlakes)||n.thickness||n.subsurface?`             \n                surfaceData.worldNormal = normalize( ${F()}( (${R()}( surfaceData.viewNormal, 0.0 ) * ${b("viewMatrix")}).xyz ) );\n                `:""}\n            ${F("normal")} = surfaceData.viewNormal;\n            ${z("NoV")} = ${B("dot(surfaceData.viewNormal, surfaceData.view)")};\n        `};Q=function(e,r){return[n(e),t(e,r)]}}{let n=function(n){return`         \n            ${e.addTexturableVec3Uniform("emissionColor",n.emissionColorMap,"color")}\n            ${n.emissionColorMulCoef&&n.emissionColorAddCoef?`${e.addVec3MADs("emissionColor",n)}`:""}\n            ${N({uniformName:"emissionValue",uniformType:"f",materialName:"emissionValue"})}\n        `},t=function(n,t){return`\n            ${e.addColorParameterResolution("materialData.emissionColor","emissionColor",n.emissionColorMap,n.emissionColorMulCoef&&n.emissionColorAddCoef,n.gammaInput&&!n.emissionColorMapLinear,!1,n)} \n            ${t.backup}\n            materialData.emissionValue = ${M("emissionValue")};\n        `},r=function(n,e){return`\n            ${e.solve}\n        `};nn=function(a){if(!a.useEmission)return["","",""];const o=e.addColorPDSFX("INTERNAL_backup_emissive","materialData.emissionColor","ComputeEmissive",a.dspbr&&a.gammaInput,a);return[n(a),r(a,o),t(a,o)]}}{let n=function(n){return n.useTransparency?`\n            ${e.addTexturableFloatUniform("transparency",n.transparencyMap,n)}\n            ${n.transparencyAddCoef&&n.transparencyMulCoef?`${e.addFloatMADs("transparency",n)}`:""}\n            ${n.dspbr?`\n                ${T("adjustTransparency","f",[c("transparencyValue"),S("albedo"),c("roughness")])} {\n                    ${z("adjust")}  = sqrt(dot(albedo, luminanceVector));\n                    adjust *= exp(-0.125 * roughness * roughness);\n                    return transparencyValue * adjust;\n                }\n                `:""}\n            \n            //pix: ptr<function, FragmentOutput>\n\t\t\t${T("ApplyTransparency","f",[p("outputAlpha"),p("transparencyValue"),c("metalnessValue"),S("albedo"),c("NoV")])}{\n                ${n.sslrefraction?`\n                    ${n.useLighting?"":`${l()}transparencyValue = 0.0;`}\n                    return 1.0;\n                    `:`\n                    ${F("Ft")}  = ${D("FresnelSchlick","v3",[S("materialData.sr0Color"),S("materialData.sr90Color"),c("NoV")])};\n                    ${n.specgloss?"":`${l()}transparencyValue = ${D("adjustTransparency","f",[c(`${l()}transparencyValue`),S("albedo"),c("materialData.roughness")])};`}\n                    ${z("transToDivide")} = max(1.0 - (1.0 - metalnessValue) * ${l()}transparencyValue * (1.0 - 0.3333*(Ft.x + Ft.y + Ft.z)), 1e-6);\n                    //${P("out0")}.a *= transToDivide;\n                    ${l()}outputAlpha *= transToDivide;\n                    ${n.skipTranspar?`if ( ${l()}outputAlpha < 1.0 - 1e-3 ) { discard; }`:""}\n                    return transToDivide;\n                    `}\n            }\n            `:""},t=function(n,t){return n.useTransparency?`\n            ${e.addFloatParameterResolution("transparencyValue","transparency",n.transparencyMap,n.transparencyAddCoef&&n.transparencyMulCoef,!0,n)}\n            ${t.backup}\n        `:""},r=function(n,e){return n.useTransparency?`\n            ${e.solve}\n            ${z("outputAlpha")} = ${P("out0")}.a;\n \t\t\t${z("transToDivide")} = ${D("ApplyTransparency","f",[d("outputAlpha"),d("transparencyValue"),c("materialData.metalness"),S(n.subsurface?"materialData.scatteringColor * albedo":"albedo"),c("NoV")])};\n            ${P("out0")}.a = outputAlpha;\n            materialData.transparency = transparencyValue;\n        `:"materialData.transparency = 0.0;"};en=function(a){const o=e.addPDSFX("INTERNAL_backup_transparency","transparencyValue","ComputeTransparency",a);return[n(a),r(a,o),t(a,o)]}}{let t=function(n){return`    \n            ${e.addTexturableFloatUniform("opacity",n.opacityMap,n)}\n            ${n.opacityBorderColorU||n.opacityBorderColorV?N({uniformName:"opacityBorderValue",uniformType:"f",materialName:"opacityMap.borderColor"}):""}\n            ${n.opacityMulCoef&&n.opacityAddCoef?`${e.addFloatMADs("opacity",n)}`:""}    \n        `};tn=function(r){const a=e.addPDSFX("_DSopacity_","opacityValue","ComputeOpacity",r);let o=`\n            \n\n                ${r.opacityMap?`\n                    ${e.textureSlotString("opacity","opacityUV",r)}\t\t\n                    ${z("opacityValue")} = ${s.sample2DTexture("opacityMap","opacityUV")}.r;\n                    ${e.addBorderColorGeneric("opacityValue","opacityUV",r.opacityBorderColorU,r.opacityBorderColorV,"opacityBorderValue")}\n                    `:`\n                    ${z("opacityValue")} = ${M("opacity")};\n                    ${r.selectionMaterial?"opacityValue = 1.0;":""}               \n                    ${r.vertexColors?`opacityValue *= ${C("vColor")}.a;`:""}\n                    `}\n                ${r.map&&r.textureBlending===Y.REPLACE&&1021===r.textureFormat?"opacityValue = texelAlbedo.a;":`\n                    ${r.map&&(r.textureBlending===Y.BLEND||r.textureBlending===Y.MODULATE||r.useAlphaFromDiffuseMap)?"opacityValue *= texelAlbedo.a;":""}\n                    `}\n                \n                ${r.opacityMulCoef&&r.opacityAddCoef?`\n                    opacityValue = ${M("opacityMulCoef")} * opacityValue + ${M("opacityAddCoef")};\n                    opacityValue = ${k("opacityValue")};\n                    `:""}\n                ${a.backup}\n            `,i=`\n                ${a.solve}\n                ${P("out0")}.a = opacityValue;\n                ${n._ShaderChunk.alphatest_fragment(r)}\n            `;return[t(r),i,o]}}{let n=function(n){return`\n            ${e.addTexturableFloatUniform("specularContrib",n.specularContribMap,n)}\n            ${n.specularContribAddCoef&&n.specularContribMulCoef?`${e.addFloatMADs("specularContrib",n)}`:""}\n            ${e.addTexturableVec3Uniform("specular",n.specularMap,"color")}\n            ${n.specularAddCoef&&n.specularMulCoef?`${e.addVec3MADs("specular",n)}`:""}\n        `};rn=function(t){const r=e.addPDSFX("INTERNAL_backup_specularContribution","materialData.specularContribution","ComputeSpecular",t),a=e.addColorPDSFX("INTERNAL_backup_specular","materialData.specularTint","ComputeSpecularReflectance",t.dspbr&&t.gammaInput,t);let o=`\n                ${e.addFloatParameterResolution("materialData.specularContribution","specularContrib",t.specularContribMap,t.specularContribMulCoef&&t.specularContribAddCoef,!1,t,"r","a")}\n                ${r.backup}\n                ${e.addColorParameterResolution("materialData.specularTint","specular",t.specularMap,t.specularAddCoef&&t.specularMulCoef,t.gammaInput&&!t.specularMapLinear,!1,t,!!t.noSaturatedSpecularTint)}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                ${a.solve}\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${n.roughnessMap?N({uniformName:"roughnessMap",uniformType:"t2"}):N({uniformName:"roughness",uniformType:"f"})}\n            ${n.glossinessMap?N({uniformName:"glossinessMap",uniformType:"t2"}):""}\n            ${n.glossinessMap||n.roughnessMap?`\n                ${N({uniformName:"roughnessUvTransform",uniformType:"m3"})}\n                ${N({uniformName:"roughnessUvSlot",uniformType:"i"})}\n                `:""}\n\n            ${n.roughnessMulCoef&&n.roughnessAddCoef?`\n                ${e.addFloatMADs("roughness",n)}\n                `:""}\n            ${n.glossinessMulCoef&&n.glossinessAddCoef?`\n                ${e.addFloatMADs("glossiness",n)}\n                `:""}\n            ${e.addTexturableFloatUniform("metalness",n.metalnessMap,n)}\n            ${n.metalnessMulCoef&&n.metalnessAddCoef?`\n                ${e.addFloatMADs("metalness",n)}\n                `:""}       \n        `};an=function(t){const r=e.addPDSFX("INTERNAL_backup_roughness","materialData.roughness","ComputeRoughness",t),a=e.addPDSFX("INTERNAL_backup_metalness","materialData.metalness","ComputeMetallic",t);let o=`\n            \n                ${e.addFloatParameterResolution("materialData.roughness","roughness",t.roughnessMap,t.roughnessMulCoef&&t.roughnessAddCoef,!1,t,"r","g","a")}\n                ${t.glossinessMap?`\n                    ${e.textureSlotString("roughness","glossinessUV",t)}\n                    ${z("glossinessTex")}  = ${s.sample2DTexture("glossinessMap","glossinessUV")}.r;\n                    materialData.roughness = 1.0-glossinessTex;\n                    `:""}\n                ${t.glossinessMulCoef&&t.glossinessAddCoef?`\n                    materialData.roughness = ${M("glossinessMulCoef")} * (1.0 - materialData.roughness) + ${M("glossinessAddCoef")};\n                    materialData.roughness = 1.0 - ${k("materialData.roughness")};\n                    `:""}\n                ${r.backup}\n\n                ${e.addFloatParameterResolution("materialData.metalness","metalness",t.metalnessMap,t.metalnessMulCoef&&t.metalnessAddCoef,!1,t,"r","b")}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                materialData.roughness = clamp(materialData.roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n                \n                ${a.solve}\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${e.addTexturableFloatUniform("anisotropy",n.anisotropyMap,n)}\n            ${n.anisotropyAddCoef&&n.anisotropyMulCoef?`\n                ${e.addFloatMADs("anisotropy",n)}\n                `:""}\n            ${e.addTexturableFloatUniform("anisotropyAngle",n.anisotropyAngleMap,n)}\n            ${n.anisotropyAngleAddCoef&&n.anisotropyAngleMulCoef?`\n                ${e.addFloatMADs("anisotropyAngle",n)}\n                `:""}\n        `};on=function(t){if(!t.anisotropy)return["","",""];const r=e.addPDSFX("INTERNAL_backup_anisotropy","materialData.anisotropy","ComputeAnisotropy",t),a=e.addPDSFX("INTERNAL_backup_anisotropyAngle","materialData.anisotropyAngle","ComputeAnisotropyRotation",t);let o=`\n                ${e.addFloatParameterResolution("materialData.anisotropy","anisotropy",t.anisotropyMap,t.anisotropyMulCoef&&t.anisotropyAddCoef,!1,t)}\n                ${r.backup}\n\n                ${e.addFloatParameterResolution("materialData.anisotropyAngle","anisotropyAngle",t.anisotropyAngleMap,t.anisotropyAngleMulCoef&&t.anisotropyAngleAddCoef,!1,t)}\n                ${a.backup}\n            `,i=`\n                ${r.solve}\n                materialData.anisotropy = min(materialData.anisotropy, 0.975);\n\n                ${a.solve}\n\n                surfaceData.binormal = binormal;\n                surfaceData.tangent = tangent;\t\n            `;return[n(t),i,o]}}{let n=function(n){return`\n            ${n.dspbrWithNoSheenValue?"":`\n                ${e.addTexturableFloatUniform("sheen",n.sheenMap,n)}\n                ${n.sheenMulCoef&&n.sheenAddCoef?`\n                    ${e.addFloatMADs("sheen",n)}\n                    `:""}\n                `}\n            ${n.dspbrWithSheenColorRoughness?`\n                ${e.addTexturableFloatUniform("sheenRoughness",n.sheenRoughnessMap,n)}\n                ${n.sheenRoughnessMulCoef&&n.sheenRoughnessAddCoef?`\n                    ${e.addFloatMADs("sheenRoughness",n)}\n                    `:""}\n                ${e.addTexturableVec3Uniform("sheenColor",n.sheenColorMap,n)}\n                ${n.sheenColorMulCoef&&n.sheenColorAddCoef?`\n                    ${e.addVec3MADs("sheenColor",n)}\n                    `:""}\n                `:""}\n        `};sn=function(t){if(!t.sheen)return["","",""];const r=e.addPDSFX("INTERNAL_backup_sheen","materialData.sheen","ComputeSheen",t),a=e.addPDSFX("INTERNAL_backup_sheenRoughness","materialData.sheenRoughness","ComputeSheenRoughness",t),o=e.addColorPDSFX("INTERNAL_backup_sheenColor","materialData.sheenColor","ComputeSheenColor",t.dspbr&&t.gammaInput,t);let i=`\n                ${t.dspbrWithNoSheenValue?"materialData.sheen = 1.0;":`\n                    ${e.addFloatParameterResolution("materialData.sheen","sheen",t.sheenMap,t.sheenAddCoef&&t.sheenMulCoef,!1,t)}\n                    ${r.backup}\n                    `}\n                ${t.dspbrWithSheenColorRoughness?`\n                    ${e.addFloatParameterResolution("materialData.sheenRoughness","sheenRoughness",t.sheenRoughnessMap,t.sheenRoughnessMulCoef&&t.sheenRoughnessAddCoef,!1,t,"r","a")}\n                    ${a.backup}\n                    ${e.addColorParameterResolution("materialData.sheenColor","sheenColor",t.sheenColorMap,t.sheenColorMulCoef&&t.sheenColorAddCoef,t.gammaInput&&!t.sheenColorMapLinear,!1,t)} \n                    ${o.backup}\n                    `:""}\n            `,s=`     \n                ${t.dspbrWithNoSheenValue?"":`\n                    ${r.solve}\n                    `}\n                ${t.dspbrWithSheenColorRoughness?`\n                    ${a.solve}\n                    materialData.sheenRoughness = clamp(materialData.sheenRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n                    ${t.useSoftVelvet&&!t.dspbrWithSquaredEstevezKullaRoughness?"materialData.sheenRoughness = max(materialData.sheenRoughness, 0.07);":""}\n                    ${o.solve}\n                    materialData.sheenEnergyConservationConstant = materialData.sheen * ${E("materialData.sheenColor")} * ${D("DirectionalSheenAlbedo","f",[c("NoV"),c("materialData.sheenRoughness")])};        \n                    `:""}\n            `;return[n(t),s,i]}}{let n=function(n){return`\n            ${n.dspbrWithTranslucency?`\n                ${e.addTexturableFloatUniform("translucency",n.translucencyMap,n)}\n                ${n.translucencyAddCoef&&n.translucencyMulCoef?`\n                    ${e.addFloatMADs("translucency",n)}\n                    `:""}\n                `:""}\n            ${n.dspbrWithTranslucencyColor?`\n                ${e.addTexturableVec3Uniform("translucencyColor",n.translucencyColorMap,n)}\n                ${n.translucencyColorMulCoef&&n.translucencyColorAddCoef?`\n                    ${e.addVec3MADs("translucencyColor",n)}\n                    `:""}\n                `:""}\n        `},t=function(n,t,r){return`    \n                ${n.dspbrWithTranslucency?`\n                    ${e.addFloatParameterResolution("materialData.translucency","translucency",n.translucencyMap,n.translucencyMulCoef&&n.translucencyAddCoef,!1,n)}\n                    ${t.backup}\n                    `:""}\n                ${n.dspbrWithTranslucencyColor?`\n                    ${e.addColorParameterResolution("materialData.translucencyColor","translucencyColor",n.translucencyColorMap,n.translucencyColorMulCoef&&n.translucencyColorAddCoef,n.gammaInput&&!n.translucencyColorMapLinear,!1,n)}\n                    ${r.backup}\n                    `:""}\n            `},r=function(n,e,t){return`    \n            ${n.dspbrWithTranslucency?`\n                ${e.solve}\n                `:""}\n            ${n.dspbrWithTranslucencyColor?`\n                ${t.solve}\n                `:""}\n        `},a=function(n){return`              \n            ${n.sssLUT?`\n                ${N({uniformName:"maxTranslucencyDepth",uniformType:"v3"})}\n                ${N({uniformName:"sssLUT",uniformType:"t2"})}\n\n                ${z("maxSSSRadiusR")}  = 0.5 * ${M("maxTranslucencyDepth")}.x;\n                ${z("minSSSRadiusR")}  = maxSSSRadiusR / 15.0;\n\n                ${z("maxSSSRadiusG")}  = 0.5 * ${M("maxTranslucencyDepth")}.y;\n                ${z("minSSSRadiusG")}  = maxSSSRadiusG / 15.0;\n\n                ${z("maxSSSRadiusB")}  = 0.5 * ${M("maxTranslucencyDepth")}.z;\n                ${z("minSSSRadiusB")}  = maxSSSRadiusB / 15.0;\n\n                ${L("E_64_OVER_74")}  = 0.86486486486;\n                ${L("E_66_OVER_74")}  = 0.89189189189;\n                ${L("E_69_OVER_74")}  = 0.93243243243;\n                ${L("E_71_OVER_74")}  = 0.95945945945;\n                ${L("E_74_OVER_74")}  = 1.0;\n                \n                ${L("SINGLE_LINE_SAMPLING_LINEAR")}  = 0.5;\n                \n                ${R("SSSLUT")}  = ${R()}(1.0,E_64_OVER_74, 0.0, 0.0);\n                ${R("SSSIBLLUT")}  = ${R()}(1.0,E_69_OVER_74 - E_66_OVER_74, 0.0, E_66_OVER_74);\n                ${R("SSSTranslucencyLUT")}  = ${R()}(1.0,E_74_OVER_74 - E_71_OVER_74, 0.0, E_71_OVER_74);\n\n                ${T("sampleSSSLUTGeneric","v3",[h("coord"),_("factor")])} {\n                    return ${s.sample2DTexture("sssLUT","factor.xy * coord + factor.zw")}.xyz;\n                }\n            \n                ${T("sampleSSSLUT","v3",[h("coord")])} {\n                    return ${D("sampleSSSLUTGeneric","v3",[h("coord"),_("SSSLUT")])};\n                }\n\n                ${T("sampleSSSIBLLUT","v3",[h("coord")])} {\n                    return ${D("sampleSSSLUTGeneric","v3",[h("coord"),_("SSSIBLLUT")])};\n                }\n            \n                ${T("sampleSSSTranslucencyLUT","v3",[h("coord")])} {\n                    return ${D("sampleSSSLUTGeneric","v3",[h("coord"),_("SSSTranslucencyLUT")])};\n                }\n                `:N({uniformName:"absorptionCoefficients",uniformType:"v3"})}\n\n            ${n.useTransmittance?`\n                ${T("_clipToEyePers","f",[c("iNearPlane"),c("iFarPlane"),c("iZClipSpace")])} {\n                    return (2.0 * iNearPlane * iFarPlane) / (iFarPlane + iNearPlane - iZClipSpace * (iFarPlane - iNearPlane));\n                }\n\n                ${T("_clipToEyeOrtho","f",[c("iNearPlane"),c("iFarPlane"),c("iZClipSpace")])} {\n                    return 0.5 * ((iFarPlane - iNearPlane) * iZClipSpace + iFarPlane + iNearPlane);\n                }\n            \n                ${T("clipToEye","f",[c("z"),h("lightInfo"),u("b","ortho")])} {\n                    if (ortho) {\n                        return ${D("_clipToEyeOrtho","f",[c("lightInfo.x"),c("lightInfo.y"),c("z")])};\n                    }\n                    return ${D("_clipToEyePers","f",[c("lightInfo.x"),c("lightInfo.y"),c("z")])};\n                }\n\n                ${I("TRANS_SAMPLE")} = 25;\n\n                ${V("poisson25",25)};\n\n                ${T("initDisk",null,[])} {\n                    poisson25[0] = ${V()}(-0.978698, -0.0884121);\n                    poisson25[1] = ${V()}(-0.841121, 0.521165);\n                    poisson25[2] = ${V()}(-0.71746, -0.50322);\n                    poisson25[3] = ${V()}(-0.702933, 0.903134);\n                    poisson25[4] = ${V()}(-0.663198, 0.15482);\n                    poisson25[5] = ${V()}(-0.495102, -0.232887);\n                    poisson25[6] = ${V()}(-0.364238, -0.961791);\n                    poisson25[7] = ${V()}(-0.345866, -0.564379);\n                    poisson25[8] = ${V()}(-0.325663, 0.64037);\n                    poisson25[9] = ${V()}(-0.182714, 0.321329);\n                    poisson25[10] = ${V()}(-0.142613, -0.0227363);\n                    poisson25[11] = ${V()}(-0.0564287, -0.36729);\n                    poisson25[12] = ${V()}(-0.0185858, 0.918882);\n                    poisson25[13] = ${V()}(0.0381787, -0.728996);\n                    poisson25[14] = ${V()}(0.16599, 0.093112);\n                    poisson25[15] = ${V()}(0.253639, 0.719535);\n                    poisson25[16] = ${V()}(0.369549, -0.655019);\n                    poisson25[17] = ${V()}(0.423627, 0.429975);\n                    poisson25[18] = ${V()}(0.530747, -0.364971);\n                    poisson25[19] = ${V()}(0.566027, -0.940489);\n                    poisson25[20] = ${V()}(0.639332, 0.0284127);\n                    poisson25[21] = ${V()}(0.652089, 0.669668);\n                    poisson25[22] = ${V()}(0.773797, 0.345012);\n                    poisson25[23] = ${V()}(0.968871, 0.840449);\n                    poisson25[24] = ${V()}(0.991882, -0.657338);\n                }\n                \n                ${n.useESMTransmittance?`${L("ONEOVER80")} = 0.0125;`:""}\n                `:""}          \n\n            ${T("getScattering","v3",[c("NoL"),c("c")])} {\n                ${n.sssLUT?`\n                    ${z("cNoL")}  = ${Z("NoL","0.5","1.0")};\n                    ${z("rr")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusR"),c("maxSSSRadiusR")])};\n                    ${z("rg")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusG"),c("maxSSSRadiusG")])};\n                    ${z("rb")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusB"),c("maxSSSRadiusB")])};\n                    ${V("coordR")}  = ${V()}(cNoL,rr);\n                    ${V("coordG")}  = ${V()}(cNoL,rg);\n                    ${V("coordB")}  = ${V()}(cNoL,rb);\n                    return ${F()}(\n                        ${D("sampleSSSLUT","v3",[h("coordR")])}.r,\n                        ${D("sampleSSSLUT","v3",[h("coordG")])}.g,\n                        ${D("sampleSSSLUT","v3",[h("coordB")])}.b\n                    );\n                    `:`return ${F()}(${B("NoL")});`}\n            }\n\n            ${T("SssLUTSampling","v3",[c("c")])} {\n                ${n.sssLUT?`\n                    ${z("rr")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusR"),c("maxSSSRadiusR")])};\n                    ${z("rg")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusG"),c("maxSSSRadiusG")])};\n                    ${z("rb")}  = ${D("toTexCoord","f",[c("1.0/c"),c("minSSSRadiusB"),c("maxSSSRadiusB")])};\n                    ${V("coordR")}  = ${V()}(rr,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${V("coordG")}  = ${V()}(rg,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${V("coordB")}  = ${V()}(rb,SINGLE_LINE_SAMPLING_LINEAR);\n                    return ${F()}(                 \n                        ${D("sampleSSSIBLLUT","v3",[h("coordR")])}.r,\n                        ${D("sampleSSSIBLLUT","v3",[h("coordG")])}.g,\n                        ${D("sampleSSSIBLLUT","v3",[h("coordB")])}.b\n                    );\n                    `:`return ${F()}(1.0);`}\n            }\n\n            ${T("GetTransmittance","v3",[c("s")])} {\n                ${n.sssLUT?`\n                    ${z("rr")}  = ${D("toTexCoord","f",[c("s"),c("0.0"),c("maxTranslucencyDepth.x")])};\n                    ${z("rg")}  = ${D("toTexCoord","f",[c("s"),c("0.0"),c("maxTranslucencyDepth.y")])};\n                    ${z("rb")}  = ${D("toTexCoord","f",[c("s"),c("0.0"),c("maxTranslucencyDepth.z")])};\n                    ${V("coordR")}  = ${V()}(rr,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${V("coordG")}  = ${V()}(rg,SINGLE_LINE_SAMPLING_LINEAR);\n                    ${V("coordB")}  = ${V()}(rb,SINGLE_LINE_SAMPLING_LINEAR);\n                    return ${F()}(\n                        ${D("sampleSSSTranslucencyLUT","v3",[h("coordR")])}.r,\n                        ${D("sampleSSSTranslucencyLUT","v3",[h("coordG")])}.g,\n                        ${D("sampleSSSTranslucencyLUT","v3",[h("coordB")])}.b\n                    );\n                    `:`return exp(-${M("absorptionCoefficients")} * s);`}\n            }\n        `},o=function(n){return`\n            surfaceData.curvature = length(fwidth(surfaceData.worldNormal)) / length(fwidth(surfaceData.worldPosition));              \n            materialData.scatteringColor = ${D("SssLUTSampling","v3",[c("surfaceData.curvature")])};\n            ${n.useTransmittance?`\n                ${n.depthBasedTransmittance?`${D("initDisk",null,[])};`:""}\n                ${n.thicknessBasedTransmittance?`\n                    materialData.transmittanceColor = ${D("GetTransmittance","v3",[c("surfaceData.thickness")])};\n                    `:""}\n                `:""}\n        `};ln=function(i){const s=e.addPDSFX("INTERNAL_backup_translucency","materialData.translucency","ComputeTranslucency",i),l=e.addColorPDSFX("INTERNAL_backup_translucencyColor","materialData.translucencyColor","ComputeTranslucencyColor",i.dspbr&&i.gammaInput,i);return i.subsurface?[`\n                    ${n(i)}\n                    ${a(i)}\n                `,`\n                    ${r(i,s,l)}\n                    ${o(i)}\n                `,t(i,s,l)]:[n(i),r(i,s,l),t(i,s,l)]}}{let n=function(n){return`  \n            ${e.addTexturableFloatUniform("clearCoat",n.clearCoatMap,n)}\n            ${n.clearCoatAddCoef&&n.clearCoatMulCoef?`\n                ${e.addFloatMADs("clearCoat",n)}\n                `:""}\n            ${n.specgloss?`\n                ${e.addTexturableVec3Uniform("clearCoatColor",n.clearCoatColorMap,n)}\n                ${n.clearCoatColorAddCoef&&n.clearCoatColorMulCoef?`\n                    ${e.addVec3MADs("clearCoatColor",n)}\n                    `:""}\n                `:""}\n            ${n.clearCoatRoughnessMap?N({uniformName:"clearCoatRoughnessMap",uniformType:"t2"}):N({uniformName:"clearCoatRoughness",uniformType:"f"})}\n            ${n.clearCoatRoughnessMulCoef&&n.clearCoatRoughnessAddCoef?`\n                ${e.addFloatMADs("clearCoatRoughness",n)}\n                `:""}\n            ${n.coatingGlossinessMap?N({uniformName:"coatingGlossinessMap",uniformType:"t2"}):""}\n            ${n.coatingGlossinessMulCoef&&n.coatingGlossinessAddCoef?`\n                ${e.addFloatMADs("coatingGlossiness",n)}\n                `:""}\n            ${n.coatingGlossinessMap||n.clearCoatRoughnessMap?`\n                ${N({uniformName:"clearCoatRoughnessUvTransform",uniformType:"m3"})}\n                ${N({uniformName:"clearCoatRoughnessUvSlot",uniformType:"i"})}\n                `:""}\n            ${n.specgloss?N({uniformName:"clearCoatNormalScale",uniformType:"f"}):""}\n            ${n.dspbr&&(n.clearCoatNormalMap||n.orangePeel)?`\n                ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`\n                    ${e.addVec3MADs("clearCoatNormal",n)}\n                    `:""}\n                `:""}\n            ${n.clearCoatNormalMap?`\n                ${N({uniformName:"clearCoatNormalMap",uniformType:"t2"})}\n                ${N({uniformName:"clearCoatNormalUvTransform",uniformType:"m3"})}\n                ${N({uniformName:"clearCoatNormalUvSlot",uniformType:"i"})}\n\n                ${T("perturbNormal3ArbCoat","v3",[S("surf_norm"),S("surf_tgt"),S("surf_binorm"),h("uv")])} {\n\n                    ${F("N")}  = normalize(surf_norm);\n                    ${F("T")}  = normalize(surf_tgt);\n                    T = normalize(T - dot(T, N) * N);\n                    ${F("B")}  = normalize(surf_binorm);\n\n                    ${F("mapN")}  = ${s.sample2DTexture("clearCoatNormalMap","uv")}.xyz * 2.0 - 1.0;\n\n                    ${n.dspbr?`\n                        ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`mapN = mapN * ${M("clearCoatNormalMulCoef")} + ${M("clearCoatNormalAddCoef")};`:""}\n                        mapN.z = abs(mapN.z);\n                        `:`\n                        ${n.clearCoatNormalMapFlipY?"mapN.y = - mapN.y;":""}\n                        mapN.x = ${M("clearCoatNormalScale")} * mapN.x;\n                        mapN.y = ${M("clearCoatNormalScale")} * mapN.y;\n                        `}\n                    ${A("tbn")}  = ${A()}(T, B, N);\n                    return normalize(tbn * mapN);\n                }\n                `:""}\n        `},t=function(n){return`\n            ${N({uniformName:"orangePeelScale",uniformType:"f"})}\n\n            ${T("orangePeelVisibility",null,[p("peelMask"),c("scaling")])} {\n                ${n.defaultInstancing?`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix * multipliedDefaultInstancingMatrix)`)])};\n                    `:`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix)`)])};\n                    `}      \n                ${F("worldScaling")}  = 1.0/${F()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${z("dist")}  = length(worldScaling * surfaceData.viewPosition);\n                ${z("NdotV")}   = dot(surfaceData.viewNormal, surfaceData.view);\n                if (NdotV <= 0.0) {\n                    ${l()}peelMask = 0.0;\n                    return;\n                }\n                ${z("normDist")}   = ${k("scaling * dist * 0.00125")};\n                ${z("shortDist")}   = ${k("1.0 - normDist")};\n                ${l()}peelMask = shortDist;\n            }\n\n            ${T("doOrangePeel",null,[x("orangePeelWorldNormal")])} {\n                ${z("peelMask")}   = 0.0;\n                ${z("peelScaling")}   = 0.01/max(${M("orangePeelScale")},1e-3);\n                ${D("orangePeelVisibility",null,[d("peelMask"),c("peelScaling")])};\n                ${n.dspbr?`\n                    ${z("ccNScale")}   = 1.0;\n                    ${n.clearCoatNormalAddCoef&&n.clearCoatNormalMulCoef?`\n                        ccNScale = ${k(`${E(`${M("clearCoatNormalMulCoef")}`)}`)};\n                        `:""}\n                    `:`${z("ccNScale")}   = clearCoatNormalScale;`}\n                if (ccNScale < kEpsilon || peelMask < kEpsilon) {\n                    return;\n                }\n                ${F("tex")}  = peelScaling * surfaceData.objectSpacePosition;\n                tex.y = -abs(tex.y);\n                tex.x = -abs(tex.x);\n                ${z("noise")}   = ${D("FBM","f",[S("tex")])};\n                ${F("peelNormal")}  = ${F()}(noise);\n                ${l()}orangePeelWorldNormal = normalize(${l()}orangePeelWorldNormal + 0.05 *ccNScale *peelMask* peelNormal);\n            }\n        `};un=function(r){if(!r.clearCoat)return["","",""];let a=n(r);r.orangePeel&&(a=`\n                    ${a}\n                    ${t(r)}\n                `);const o=e.addPDSFX("INTERNAL_backup_clearcoat","materialData.clearCoat","ComputeClearcoat",r),i=e.addColorPDSFX("INTERNAL_backup_clearcoatColor","materialData.clearCoatSR0Color","ComputeClearcoatColor",r.dspbr&&r.gammaInput,r),l=e.addPDSFX("INTERNAL_backup_clearcoatRoughness","materialData.clearCoatRoughness","ComputeClearcoatRoughness",r);let u=`\n            \n                ${e.addFloatParameterResolution("materialData.clearCoat","clearCoat",r.clearCoatMap,r.clearCoatAddCoef&&r.clearCoatMulCoef,!1,r)}  \n                ${o.backup}\n                ${r.specgloss?`\n                    ${e.addColorParameterResolution("materialData.clearCoatSR0Color","clearCoatColor",r.clearCoatColorMap,r.clearCoatColorAddCoef&&r.clearCoatColorMulCoef,r.gammaInput&&!r.clearCoatColorMapLinear,!1,r)}\n                    ${i.backup}\n                    `:`materialData.clearCoatSR0Color = ${F()}(0.04);`}\n                materialData.clearCoatSR90Color = ${F()}(1.0);\n                ${e.addFloatParameterResolution("materialData.clearCoatRoughness","clearCoatRoughness",r.clearCoatRoughnessMap,r.clearCoatRoughnessAddCoef&&r.clearCoatRoughnessMulCoef,!1,r,"r","g")}\n                ${r.coatingGlossinessMap?`\n                    ${e.textureSlotString("clearCoatRoughness","ccglossinessUV",r)}\n                    ${z("ccGlossiness")}  = ${s.sample2DTexture("coatingGlossinessMap","ccglossinessUV")}.r;\n                    materialData.clearCoatRoughness = 1.0 - ccGlossiness;\n                    `:""}\n                ${r.coatingGlossinessMulCoef&&r.coatingGlossinessAddCoef?`\n                    materialData.clearCoatRoughness = ${M("coatingGlossinessMulCoef")} * (1.0 - materialData.clearCoatRoughness) + ${M("coatingGlossinessAddCoef")};\n                    materialData.clearCoatRoughness = 1.0 - ${k("materialData.clearCoatRoughness")};\n                    `:""}\n                ${l.backup}\n            `;const m=e.addPDSFX("INTERNAL_backup_clearcoatViewNormal","surfaceData.clearCoatNormal","ComputeClearcoatViewNormal",r,"v3");return[a,`                 \n                ${o.solve}\n                ${r.clearCoatNormalMap?`\n                    ${e.textureSlotString("clearCoatNormal","ccnormalUv",r)}\n                    surfaceData.clearCoatNormal = ${D("perturbNormal3ArbCoat","v3",[S("viewNormal"),S("tangent"),S("binormal"),h("ccnormalUv")])};\n                    `:"surfaceData.clearCoatNormal = viewNormal;"}\n                ${m.backup}\n                ${m.solve}\n                surfaceData.clearCoatWorldNormal = normalize( ${F()}( ${R()}( surfaceData.clearCoatNormal, 0.0 ) * ${b("viewMatrix")} ) );\n                ${r.orangePeel?`\n                    ${D("doOrangePeel","v3",[y("surfaceData.clearCoatWorldNormal")])};\n                    surfaceData.clearCoatNormal = normalize( (${b("viewMatrix")} * ${R()}( surfaceData.clearCoatWorldNormal , 0.0)).xyz);\n                    `:""}\n                ${r.specgloss?`\n                    ${i.solve}\n                    `:""}\n                ${l.solve}\n                materialData.clearCoatRoughness =  clamp(materialData.clearCoatRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);\n            `,u]}}{let n=function(n){const e=[{type:"f",name:"flakesRoughness"},{type:"f",name:"flakesCoverage"},{type:"v3",name:"flakesColor"},{type:"f",name:"flakesCosConeAngle"},{type:"f",name:"flakesConeSolidAngle"},{type:"v3",name:"closeupFlakesReflect"},{type:"v3",name:"closeupFlakesNormal"},{type:"f",name:"baseWeight"},{type:"f",name:"smoothWeight"},{type:"v3",name:"smoothFlakesColor"},{type:"f",name:"closeupWeight"},{type:"v3",name:"closeupFlakesColor"},{type:"f",name:"stochasticWeight"},{type:"v2",name:"footprintPos"},{type:"v2",name:"footprintDx"},{type:"v2",name:"footprintDy"},{type:"f",name:"footprintArea"},{type:"f",name:"cellsInFootPrint"},{type:"f",name:"expectedFlakes"},{type:"f",name:"invDet"},{type:"f",name:"seedRes"}];return n.dspbrWithFlipFlopColor&&(e.push({type:"v3",name:"flipFlopColor"}),e.push({type:"f",name:"flipFlop"})),n.dspbrHemiFlakes&&(e.push({type:"v3",name:"stochasticHemisphereFlakesNormal"}),e.push({type:"v3",name:"stochasticHemisphereFlakesReflect"}),e.push({type:"v3",name:"stochasticHemisphereFlakesColor"})),`\n            ${n.dspbrFlakesFullGrid?`\t\n                ${L("HALF_MAXF_GRID_SIZE")}  = 2.0;\n                ${I("FLAKES_PER_CELL")} = 4;\n                `:`\t\n                ${L("HALF_MAXF_GRID_SIZE")}  = 1.0;\n                ${I("FLAKES_PER_CELL")} = 2;\n                `}\n            ${L("DSPBRFLAKES_STO_SMOOTH_TRANSITION")}  = 256.0;\n            ${L("DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION")}  = 4.0;\n            ${L("DSPBRFLAKES_CLOSE_STO_TRANSITION")}  = 0.25;\n\n            \n            ${o.createStructure({structName:"rstGridData",attributes:[{type:"f",name:"minX"},{type:"f",name:"minY"},{type:"f",name:"maxX"},{type:"f",name:"maxY"},{type:"f",name:"deltaDDx"},{type:"f",name:"deltaDDy"},{type:"f",name:"dyLeftBound"},{type:"f",name:"dxLeftBound"},{type:"f",name:"dyRightBound"},{type:"f",name:"dxRightBound"}]})}\n            ${o.declareStructure({name:"rasterizedGridData",structName:"rstGridData",addressSpace:"private"})};\n            ${o.declareStructure({name:"rasterizedGridDataClose",structName:"rstGridData",addressSpace:"private"})};\n\n            ${o.createStructure({structName:"flData",attributes:e})}\n            ${o.declareStructure({name:"flakesData",structName:"flData",addressSpace:"private"})};\n          \n            ${T("reorientParallelogram",null,[h("pos"),h("dx"),h("dy"),g("nPos"),g("nDx"),g("nDy")])}{\n                ${V("newPosition")} = ${V()}(pos);\n                ${V("newDx")};\n                ${V("newDy")};\n                if ((dy.x * dx.y - dy.y * dx.x) > 0.0) { \n                    newDx = ${V()}(dy); \n                    newDy = ${V()}(dx); \n                } else {\n                    newDx = ${V()}(dx);\n                    newDy = ${V()}(dy);\n                }\n                if (newDy.y < 0.0) {\n                    newPosition = newPosition + newDy;\n                    ${V("aux")}  = ${V()}(newDy);\n                    newDy = newDx;\n                    newDx = - aux;\n                }\n                if (newDy.y < 0.0) {\n                    newPosition = newPosition + newDy;\n                    ${V("aux")} = ${V()}(newDy);\n                    newDy = newDx;\n                    newDx = - aux;\n                }\n                if (newDx.y <= 0.0) {\n                    newPosition = newPosition + newDx;\n                    ${V("aux")} = ${V()}(newDx);\n                    newDx = newDy;\n                    newDy = - aux;\n                }\n                if (newDx.y <= 0.0) {\n                    newPosition = newPosition + newDx;\n                    ${V("aux")} = ${V()}(newDx);\n                    newDx = newDy;\n                    newDy = - aux;\n                }\n                ${l()}nPos = newPosition;\n                ${l()}nDx = newDx;\n                ${l()}nDy = newDy;\n            }\n\n            ${T("parallelogramBBox","v4",[h("pos"),h("dx"),h("dy")])} {\n                ${V("corner1")}  = pos;\n                ${V("corner2")}  = pos + dx;\n                ${V("corner3")}  = pos + dy;\n                ${V("corner4")}  = pos + dx + dy;\n\n                ${V("minBBox")}  = ${V()}(${G(`${R()}(corner1.x,corner2.x,corner3.x,corner4.x)`)}, ${G(`${R()}(corner1.y,corner2.y,corner3.y,corner4.y)`)});\n                ${V("maxBBox")}  = ${V()}(${O(`${R()}(corner1.x,corner2.x,corner3.x,corner4.x)`)}, ${O(`${R()}(corner1.y,corner2.y,corner3.y,corner4.y)`)});\n                return ${R()}(minBBox, maxBBox);\n            }\n\n            ${T("prepareFlakesGrid",null,[m("rstGridData","gridData",!0),u("b","close")])}{ \n                ${V("pos")} ;\n                ${V("dx")} ;\n                ${V("dy")} ;\n                if (close) {\n                    ${z("nodeSize")}  = 1.25 / flakesData.seedRes;\n                    pos = flakesData.footprintPos - nodeSize;\n                    dx = ${V()}(2.0 * nodeSize, 0.0);\n                    dy = ${V()}(0.0, 2.0 * nodeSize);\n                } else {\t\t\n                    pos = flakesData.footprintPos;\n                    dx = flakesData.footprintDx;\n                    dy = flakesData.footprintDy;\n                }\n                ${R("bbox")}  = ${D("parallelogramBBox","v4",[h("pos"),h("dx"),h("dy")])};\n                ${V("gridMin")}  = floor(flakesData.seedRes * bbox.xy);\n                ${V("gridMax")}  = ceil(flakesData.seedRes * bbox.zw);\n\n                ${V("footPrintCenter")}  = flakesData.seedRes * (pos + 0.5 * (dx + dy));\n\n                gridMin = clamp(gridMin, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);\n                gridMin = clamp(gridMin,  footPrintCenter - ${V()}(flakesData.seedRes), footPrintCenter + ${V()}(flakesData.seedRes));\n                gridMax = clamp(gridMax, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);\n                gridMax = clamp(gridMax,  footPrintCenter - ${V()}(flakesData.seedRes), footPrintCenter + ${V()}(flakesData.seedRes));\n                gridMax += ${V()}(1.0);\n                {\n                    ${V("opos")}  = pos * flakesData.seedRes;\n                    ${V("odx")}  = dx * flakesData.seedRes;\n                    ${V("ody")}  = dy * flakesData.seedRes;\t\n                    ${D("reorientParallelogram",null,[h("opos"),h("odx"),h("ody"),v("pos"),v("dx"),v("dy")])};\n                }\n                ${z("deltaDDx")}  = dx.x / abs(dx.y);\n                ${z("deltaDDy")}  = dy.x / abs(dy.y);\n                ${V("sum")}  = dx + dy;\n                ${z("minX")}  = max(min(pos.x, min(pos.x + dy.x, pos.x + sum.x)),gridMin.x);\n                ${z("maxX")}  = min(max(pos.x, max(pos.x + dx.x, pos.x + sum.x)),gridMax.x);\n                ${z("minY")}  = floor(max(gridMin.y, pos.y));\n                ${z("maxY")}  = ceil(min(gridMax.y, pos.y + sum.y));\n\n                \n                ${z("dyLeftBound")}  =  pos.x +\t(minY - pos.y) * deltaDDy;\n                if (dy.x < 0.0) {\n                    dyLeftBound += deltaDDy;\n                }\n                ${z("dxLeftBound")}  =  pos.x + dy.x + (minY - pos.y - dy.y) * deltaDDx;\n                if (dx.x < 0.0) {\n                    dxLeftBound += deltaDDx;\n                }\n                ${z("dyRightBound")}  = pos.x + dx.x +\t(minY - pos.y - dx.y) * deltaDDy;\n                if (dy.x > 0.0) {\n                    dyRightBound += deltaDDy;\n                }\n                ${z("dxRightBound")}  = pos.x +\t(minY - pos.y) * deltaDDx;\n                if (dx.x > 0.0) {\n                    dxRightBound += deltaDDx;\n                }\n\n                ${l()}gridData.minX = minX;\n                ${l()}gridData.maxX = maxX;\n                ${l()}gridData.minY = minY;\n                ${l()}gridData.maxY = maxY;\n                ${l()}gridData.dyLeftBound = dyLeftBound;\n                ${l()}gridData.dxLeftBound = dxLeftBound;\n                ${l()}gridData.dyRightBound = dyRightBound;\n                ${l()}gridData.dxRightBound = dxRightBound;\n                ${l()}gridData.deltaDDx = deltaDDx;\n                ${l()}gridData.deltaDDy = deltaDDy;\n            }\n            \n            ${T("triplanarMapping","v2",[S("p"),S("n"),c("scale")])}{ \n                ${V("uv")} ;\n                if (abs(n.x) >= abs(n.y) && abs(n.x) >= abs(n.z)) {\n                    uv = ${V()}(-p.z,-p.y);\n                } else if (abs(n.y) >= abs(n.z)) {\n                    uv = ${V()}( p.x, p.z);\n                } else {\n                    uv = ${V()}( p.x,-p.y);\n                }\n                return uv * scale;\n            }\n\n            ${T("computeFlakesRoughness",null,[c("flakesRoughness")])} {\n                ${z("targetConeAngle")}  = 0.122173;\n                ${z("targetConeSolidAngle")}  = 2.0 * PI * (1.0 - cos(targetConeAngle));\n                ${z("targetConeRoughness2")}  = targetConeSolidAngle / (4.0 * PI - targetConeSolidAngle);\n\n                ${z("totalFlakeRoughness2")}  = ${H("flakesRoughness")};\n                ${z("flakeConeRoughness2")}  = min(targetConeRoughness2, 0.5 * totalFlakeRoughness2);\n                flakesData.flakesCosConeAngle = clamp(1.0 - 2.0 * flakeConeRoughness2 / (1.0 + flakeConeRoughness2), 0.0, 0.99984769502);\n                flakesData.flakesConeSolidAngle = 2.0 * PI * (1.0 - flakesData.flakesCosConeAngle);\n\n                flakesData.flakesRoughness = sqrt(totalFlakeRoughness2 - flakeConeRoughness2);\n            }\n\n        ${n.dspbrWithFlipFlopColor?`${T("initFlakesData",null,[S("p"),S("N"),c("flakesSize"),c("flakesCoverage"),S("flakesColor"),c("flakesRoughness"),c("flipFlop"),S("flipFlopColor")])} {`:`${T("initFlakesData",null,[S("p"),S("N"),c("flakesSize"),c("flakesCoverage"),S("flakesColor"),c("flakesRoughness")])} {`}\n                ${n.defaultInstancing?`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix * multipliedDefaultInstancingMatrix)`)])};\n                    `:`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix)`)])};\n                    `}   \n                ${F("worldScaling")}  = ${F()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${F("scaledP")}  = p * worldScaling;\n\n                flakesData.flakesColor = flakesColor;\n                flakesData.flakesCoverage = flakesCoverage;\n                ${n.dspbrWithFlipFlopColor?`\n                    flakesData.flipFlopColor = flipFlopColor;\n                    flakesData.flipFlop = ${H("1.0 / max(flipFlop, 1e-6)")};\n                    `:""}\n\n                ${D("computeFlakesRoughness",null,[c("flakesRoughness")])};\n\n                ${F("x")} =  dFdx(scaledP);\n                ${F("y")}  =  dFdy(scaledP);\n                flakesData.footprintPos =  ${D("triplanarMapping","v2",[S("scaledP"),S("N"),c("1e-3")])};\n                flakesData.footprintDx =  ${D("triplanarMapping","v2",[S("x"),S("N"),c("1e-3")])};\n                flakesData.footprintDy =  ${D("triplanarMapping","v2",[S("y"),S("N"),c("1e-3")])};\n                flakesData.footprintArea = flakesData.footprintDx.x * flakesData.footprintDy.y - flakesData.footprintDx.y * flakesData.footprintDy.x;\n                flakesData.invDet = 1.0 / flakesData.footprintArea;\n\n                ${z("cellsPerArea")}  = 1.5396e6 / ${H("flakesSize")};\n                flakesData.cellsInFootPrint = abs(flakesData.footprintArea) * cellsPerArea;\n                ${z("flakesPerArea")}  = flakesCoverage * cellsPerArea;\n                flakesData.expectedFlakes = abs(flakesData.footprintArea) * flakesPerArea;\n                flakesData.seedRes = max(${z()}(FLAKES_PER_CELL), ${D("vRound","f",[c(`sqrt(cellsPerArea/${z()}(FLAKES_PER_CELL)))`)])};\n\n                ${D("prepareFlakesGrid",null,[$("rstGridData","rasterizedGridData",!0),u("b","false")])};\n                ${D("prepareFlakesGrid",null,[$("rstGridData","rasterizedGridDataClose",!0),u("b","true")])};\n            }\n        `},t=function(n){return`\n    \n            ${T("ImportanceSampleGGX","v3",[h("Xi"),c("roughness")])}{\n    \n                ${F("H")} ;\n                ${z("Phi")}  = 2.0 * PI * Xi.x;\n                ${z("a")}  = roughness * roughness;\n                ${z("a2")}  = a * a;\n    \n                ${z("CosTheta")}  = clamp(sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)),0.0,1.0);\n                ${z("SinTheta")}  = sqrt(1.0 - CosTheta * CosTheta);\n    \n                H.x = SinTheta * cos(Phi);\n                H.y = SinTheta * sin(Phi);\n                H.z = CosTheta;\n                return H;\n            }\n            \n            ${T("rnGenerator","v2",[m("i","seed")])} {\n                ${U("s")} = ${l()}seed;\n                ${U("rn")} = ${D("modI","i",[f("1140671485 * s + 12820163"),f("16777216")])};\n                s = ${D("modI","i",[f("1140671485 * rn + 12820163"),f("16777216")])};\n                ${l()}seed = s;\n                return ${V()}(${z()}(rn) /16777216.0 ,${z()}(s) / 16777216.0);\n            }\n\n            ${T("generateFlakes",null,[m("i","seed"),S("V"),S("N"),g("pos"),x("refl"),m("b","opaque")])} {\n                ${l()}pos = ${D("rnGenerator","v2",[m("i","seed")])};\n                ${V("uvs")}  = ${D("rnGenerator","v2",[m("i","seed")])};\t\n                ${F("H")} = ${D("ImportanceSampleGGX","v3",[h("uvs.xy"),c("flakesData.flakesRoughness")])};\n                ${l()}refl = ${D("TangentToWorldGeom","v3",[S("H"),S("N")])};\n                ${l()}refl = 2.0 * dot(V,${l()}refl) * ${l()}refl - V;\n                ${l()}opaque = ${D("rnGenerator","v2",[m("i","seed")])}.x < flakesData.flakesCoverage;\n            }\n\n            ${T("getSeed","i",[c("i"),c("j")])} {\t\n                ${z("iF")}  = i;\n                ${z("jF")}  = j;\n                return ${U()}(length(${V()}(iF,jF)* 16892.0));\n            }\n\n            ${T("midFlakeInFootPrint","b",[h("center")])} {\n                if (abs(flakesData.footprintArea) < 1e-10) {\n                    return false;\n                } else {\n                    ${V("pp")}  = center - flakesData.footprintPos;\n                    ${V("uv")}  = flakesData.invDet * ${V()}(dot(${V()}(-pp.y,pp.x),flakesData.footprintDy), dot(${V()}(pp.y,-pp.x),flakesData.footprintDx));\n                    return 0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0;\n                }\n            }\n        `},r=function(n){return`\n\n            ${T("contributingStochasticFlakes","v2",[S("V"),S("L"),S("N"),c("limit")])} {\n                ${z("contributing")}  = 0.0;\n                ${z("flakesInFootPrint")}  = 0.0;\n\n                ${z("deltaDDx")}  = rasterizedGridData.deltaDDx;\n                ${z("deltaDDy")}  = rasterizedGridData.deltaDDy;\n\n                ${z("minX")}  = rasterizedGridData.minX;\n                ${z("maxX")}  = rasterizedGridData.maxX;\n                ${z("minY")}  = rasterizedGridData.minY;\n                ${z("maxY")}  = rasterizedGridData.maxY;\n\n                ${z("dyLeftBound")}  =  rasterizedGridData.dyLeftBound;\n                ${z("dxLeftBound")}  =  rasterizedGridData.dxLeftBound;\t\t\t\n                ${z("dyRightBound")}  = rasterizedGridData.dyRightBound;\n                ${z("dxRightBound")}  = rasterizedGridData.dxRightBound;\n\n                ${z("i")}  = 0.0;\n                ${z("maxI")}  = -1.0;\n                ${z("j")}  = minY;\n                ${z("jEnd")}  = maxY;\n                \n                ${z("nodeSize")}  = 1.0 / flakesData.seedRes;\n                ${n.dspbrWithFlipFlopColor?`${F("totalRefl")}  = ${F()}(0.0);`:""}\n                for (${U("loop")} = 0; loop < 150; loop++) {\t\t\t\n                    if (i >= maxI) {\n                        ${z("boundaryLeft")}  = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${z("boundaryRight")}  = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    ${U("seed")} = ${D("getSeed","i",[c("i"),c("j")])};\n                    for (${U("cell")}  = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${V("fPos")} ;\n                        ${F("fRefl")} ;\n                        ${w("fOpaque")} ;\n                        ${D("generateFlakes",null,[$("i","seed"),S("V"),S("N"),v("fPos"),y("fRefl"),$("b","fOpaque")])};\n                        if (fOpaque) {\n                            ${V("flakeUV")}  = nodeSize * (${V()}(i, j) + fPos);\n                            if (${D("midFlakeInFootPrint","b",[h("flakeUV")])}) {\n                                ${z("val")}  = step(0.0, dot(fRefl,L) - limit);\n                                flakesInFootPrint++;\n                                ${n.dspbrWithFlipFlopColor?"totalRefl += val * fRefl;":""}\n                                contributing += val;\n                            }\n                        }\n                    }\n\n                    i++;\n                    if (i >= maxI) { \n                        j++;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n                ${z("coeff")}  = contributing / max(1.0,flakesInFootPrint);\n\n                ${n.dspbrWithFlipFlopColor?`                \n                    ${F("flakesN")}  = normalize(${q("totalRefl")} + V);    \n                    return ${V()}(coeff, dot(V, flakesN));\n                    `:`return ${V()}(coeff, 0.0);`}\n            }\n        `},a=function(n){return`\n\n            ${T("contributingStochasticHemisphereFlakes","v3",[S("V"),S("N")])} {\n                ${F("stochasticFlakesOrientation")}  = ${F()}(0.0);\n                ${z("deltaDDx")}  = rasterizedGridData.deltaDDx;\n                ${z("deltaDDy")}  = rasterizedGridData.deltaDDy;\n                ${z("minX")}  = rasterizedGridData.minX;\n                ${z("maxX")}  = rasterizedGridData.maxX;\n                ${z("minY")}  = rasterizedGridData.minY;\n                ${z("maxY")}  = rasterizedGridData.maxY;\n                ${z("dyLeftBound")}  =  rasterizedGridData.dyLeftBound;\n                ${z("dxLeftBound")}  =  rasterizedGridData.dxLeftBound;\t\t\t\n                ${z("dyRightBound")}  = rasterizedGridData.dyRightBound;\n                ${z("dxRightBound")}  = rasterizedGridData.dxRightBound;\n\n                ${z("i")}  = 0.0;\n                ${z("maxI")}  = -1.0;\n                ${z("j")}  = minY;\n                ${z("jEnd")}  = maxY;\n                \n                ${z("nodeSize")}  = 1.0 / flakesData.seedRes;\n                for (${U("loop")} = 0; loop < 150; loop++) {\t\t\t\n                    if (i >= maxI) {\n                        ${z("boundaryLeft")}  = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${z("boundaryRight")}  = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    ${U("seed")}= ${D("getSeed","i",[c("i"),c("j")])};\n                    for (${U("cell")} = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${V("fPos")};\n                        ${F("fRefl")};\n                        ${w("fOpaque")};\n                        ${D("generateFlakes",null,[$("i","seed"),S("V"),S("N"),v("fPos"),y("fRefl"),$("b","fOpaque")])};\n                        ${z("val")}  = dot(fRefl,N);\n                        stochasticFlakesOrientation += step(0.1, val) * fRefl;\n                    }\n\n                    i++;\n                    if (i >= maxI) { \n                        j++;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n                ${z("len")}  = length(stochasticFlakesOrientation);\n                if (len > 1e-6) {\n                    return stochasticFlakesOrientation / len;\n                }\n                return reflect(V , N);\n            }\n        `},i=function(n){return`\n            ${T("contributingCloseFlakes","v3",[S("V"),S("N")])} {\n                ${z("deltaDDx")}  = rasterizedGridDataClose.deltaDDx;\n                ${z("deltaDDy")}   = rasterizedGridDataClose.deltaDDy;\n                ${z("minX")}   = rasterizedGridDataClose.minX;\n                ${z("maxX")}   = rasterizedGridDataClose.maxX;\n                ${z("minY")}   = rasterizedGridDataClose.minY;\n                ${z("maxY")}   = rasterizedGridDataClose.maxY;\n                ${z("dyLeftBound")}   =  rasterizedGridDataClose.dyLeftBound;\n                ${z("dxLeftBound")}   =  rasterizedGridDataClose.dxLeftBound;\t\t\t\n                ${z("dyRightBound")}   = rasterizedGridDataClose.dyRightBound;\n                ${z("dxRightBound")}   = rasterizedGridDataClose.dxRightBound;\n\n                ${z("i")}   = 0.0;\n                ${z("maxI")}   = -1.0;\n                ${z("j")}   = minY;\n                ${z("jEnd")}   = maxY;\n                \n                ${z("nodeSize")}   = 1.0 / flakesData.seedRes;\n                ${z("bestDistance")}   = 1e10;\n                ${F("res")}  = ${F()}(0.0);\n                for (${U("loop")}= 0; loop < 150; loop++) {\t\t\n                    if (i >= maxI) {\n                        ${z("boundaryLeft")}   = max(minX, max(dyLeftBound, dxLeftBound));\n                        i = floor(boundaryLeft);\n\n                        ${z("boundaryRight")}   = min(maxX, min(dyRightBound, dxRightBound));\n                        maxI = ceil(boundaryRight);\n                        \n                        dyLeftBound += deltaDDy;\n                        dxLeftBound += deltaDDx;\n                        dyRightBound += deltaDDy;\n                        dxRightBound += deltaDDx;\n                    }\n\n                    int seed = ${D("getSeed","i",[c("i"),c("j")])};\n                    for (${U("cell")} = 0; cell < FLAKES_PER_CELL; cell++) {\n                        ${V("fPos")};\n                        ${F("fRefl")};\n                        ${w("fOpaque")};\n                        ${D("generateFlakes",null,[$("i","seed"),S("V"),S("N"),v("fPos"),y("fRefl"),$("b","fOpaque")])};\n                        ${V("flakeUV")}  = nodeSize * (${V()}(i, j)  + fPos);\n                        \n                        ${V("prel")}  = flakesData.footprintPos + 0.5* (flakesData.footprintDx + flakesData.footprintDy) - flakeUV;\n                        ${z("curDistance")}   = dot(prel, prel);\n                        if (curDistance < bestDistance) {\n                            bestDistance = curDistance;\n                            if (fOpaque) {\n                                res = fRefl;\n                            } else {\n                                res = ${F()}(0.0);\n                            }\n                        }\n                    }\n\n                    i++;\n                    if (i >= maxI) { \n                        j++;\n                    }\n                    if (j >= jEnd) {\n                        break;\n                    }\n                }\n\n                return ${q("res")};\n            }\n        `},s=function(n){return`   \n            ${n.dspbrWithFlipFlopColor?`\n                ${T("computeFlakesTint","v3",[c("NoV")])} {\n                    ${z("coeff")}  = pow(${B("NoV")}, flakesData.flipFlop);\n                    return mix(flakesData.flakesColor, flakesData.flipFlopColor, coeff);\n                }\n\n                ${T("computeFlakesTint","v3",[S("V"),S("N")])} {\n                    return ${D("computeFlakesTint","v3",[c("dot(N,V)")])};\n                }\n                `:`\n                ${T("computeFlakesTint","v3",[])} {\n                    return flakesData.flakesColor;\n                }\n                `}\n\n            ${T("initFlakesWeights",null,[S("V"),S("N")])} {\n                flakesData.closeupFlakesReflect = ${F()}(0.0);\n                ${z("flakesHit")}  = 0.0;\n                \n                ${n.dspbrFlakesThreeLayers?`\t\t\n                    ${z("closeupStochasticTransition")}  = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);\n                    ${z("closeupSmoothTransition")}  = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);\n                    ${z("stochasticSmoothTransition")}  = log(DSPBRFLAKES_STO_SMOOTH_TRANSITION);\n\n                    ${z("logCellsInFootPrint")}  = log(flakesData.cellsInFootPrint);\n                    if (logCellsInFootPrint < closeupSmoothTransition) {\t\t\n                        flakesData.closeupFlakesReflect = ${D("contributingCloseFlakes","v3",[S("V"),S("N")])};\n                        if (dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0 ) {\n                            flakesHit = 1.0;\n                        }\n                        if (logCellsInFootPrint < closeupStochasticTransition) {\n                            flakesData.closeupWeight = flakesHit;\n                            flakesData.stochasticWeight = 0.0;\n                            flakesData.baseWeight = 1.0 - flakesHit;\n                        } else {\n                            flakesData.stochasticWeight = smoothstep(closeupStochasticTransition, closeupSmoothTransition, logCellsInFootPrint);\n                            flakesData.closeupWeight = flakesHit * (1.0 - flakesData.stochasticWeight);\n                            flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.stochasticWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.stochasticWeight;\n                        }\n                        flakesData.smoothWeight = 0.0;\n                    } else {\n                        flakesData.closeupWeight = 0.0;\n                        if (logCellsInFootPrint < stochasticSmoothTransition) {\n                            flakesData.smoothWeight = smoothstep(closeupSmoothTransition, stochasticSmoothTransition, logCellsInFootPrint);\n                            flakesData.stochasticWeight = 1.0 - flakesData.smoothWeight;\n                        } else {\n                            flakesData.smoothWeight = 1.0;\n                            flakesData.stochasticWeight = 0.0;\n                        }\n                        flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;\n                    }\t\t\n                    `:""}\n\n                ${n.dspbrFlakesTwoLayers?`\t\n                    flakesData.stochasticWeight = 0.0;\n\n                    ${z("fullCloseUp")}  = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);\n                    ${z("fullSmooth")}  = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);\n\n                    ${z("logCellsInFootPrint")}  = log(flakesData.cellsInFootPrint);\n                    flakesData.smoothWeight = smoothstep(fullCloseUp,fullSmooth, logCellsInFootPrint);\t\n                    flakesData.closeupWeight = 0.0;\n                    flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;\n                    if (logCellsInFootPrint < fullSmooth) {\t\t\n                        flakesData.closeupFlakesReflect = ${D("contributingCloseFlakes","v3",[S("V"),S("N")])};\n                        if (dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0) {\n                            flakesHit = 1.0;\n                        }\n                        if (logCellsInFootPrint < fullCloseUp) {\n                            flakesData.closeupWeight = flakesHit;\n                            flakesData.baseWeight = 1.0 - flakesHit;\n                        } else {\n                            flakesData.closeupWeight = flakesHit * (1.0 - flakesData.smoothWeight);\n                            flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.smoothWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.smoothWeight;\n                        }\t\n                    }\t\t\t\n                    `:""}\n\n\n                ${n.dspbrFlakesOneLayer?"\n                    flakesData.stochasticWeight = 0.0;\n                    flakesData.closeupWeight = 0.0;\t\n                    flakesData.smoothWeight = 1.0;\n                    flakesData.baseWeight = (1.0 - flakesData.flakesCoverage);\n                    ":""}\n\n                ${n.dspbrHemiFlakes?`\n                    flakesData.stochasticHemisphereFlakesNormal = N;\n                    flakesData.stochasticHemisphereFlakesReflect = reflect(V, N);\n                    ${n.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            flakesData.stochasticHemisphereFlakesReflect = ${D("contributingStochasticHemisphereFlakes","v3",[S("V"),S("N")])};\n                            flakesData.stochasticHemisphereFlakesNormal = normalize(V + flakesData.stochasticHemisphereFlakesReflect);\n                        }                \n                        `:""}\n                    \n                    `:""}\n                if (dot(flakesData.closeupFlakesReflect, N) < 0.0) {\n                    flakesData.closeupFlakesReflect = flakesData.closeupFlakesReflect - 2.0 * dot(flakesData.closeupFlakesReflect, N) * N;\n                }\n                flakesData.closeupFlakesNormal = normalize(V + flakesData.closeupFlakesReflect);\n\n                flakesData.stochasticWeight *= flakesData.flakesCoverage;\n                flakesData.smoothWeight *= flakesData.flakesCoverage;\n\n                ${n.dspbrWithFlipFlopColor?`\n                    flakesData.smoothFlakesColor = flakesData.smoothWeight * ${D("computeFlakesTint","v3",[S("V"),S("N")])};\n                    ${n.dspbrFlakesOneLayer?"":`\n                        flakesData.closeupFlakesColor = flakesData.closeupWeight * ${D("computeFlakesTint","v3",[S("V"),S("flakesData.closeupFlakesNormal")])};    \n                        `}\n                                       \n                    ${n.dspbrHemiFlakes&&n.dspbrFlakesThreeLayers?`flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * ${D("computeFlakesTint","v3",[S("V"),S("flakesData.stochasticHemisphereFlakesNormal")])};`:""}\n                    `:`\n                    flakesData.smoothFlakesColor = flakesData.smoothWeight * ${D("computeFlakesTint","v3",[])};\n                    ${n.dspbrFlakesOneLayer?"":`\n                        flakesData.closeupFlakesColor = flakesData.closeupWeight * ${D("computeFlakesTint","v3",[])};    \n                        `}                  \n                    ${n.dspbrHemiFlakes&&n.dspbrFlakesThreeLayers?`flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * ${D("computeFlakesTint","v3",[])};`:""}\n                    `}\n            }\n        `},p=function(o){return`\n            ${e.addTexturableVec3Uniform("flakesColor",o.flakesColorMap,o)}\n            ${o.flakesColorAddCoef&&o.flakesColorMulCoef?`\n                ${e.addVec3MADs("flakesColor",o)}\n                `:""}\n            ${e.addTexturableFloatUniform("flakesCoverage",o.flakesCoverageMap,o)}\n            ${o.flakesCoverageAddCoef&&o.flakesCoverageMulCoef?`\n                ${e.addFloatMADs("flakesCoverage",o)}\n                `:""}\n            ${e.addTexturableFloatUniform("flakesRoughness",o.flakesRoughnessMap,o)}\n            ${o.flakesRoughnessAddCoef&&o.flakesRoughnessMulCoef?`\n                ${e.addFloatMADs("flakesRoughness",o)}\n                `:""}\n            ${e.addTexturableFloatUniform("flakesSize",o.flakesSizeMap,o)}\n            ${o.flakesSizeAddCoef&&o.flakesSizeMulCoef?`\n                ${e.addFloatMADs("flakesSize",o)}\n                `:""}\n            ${o.dspbrWithFlipFlopColor?`\n                ${e.addTexturableVec3Uniform("flipFlopColor",o.flipFlopColorMap,o)}\n                ${o.flipFlopColorAddCoef&&o.flipFlopColorMulCoef?`\n                    ${e.addVec3MADs("flipFlopColor",o)}\n                    `:""}\n                ${e.addTexturableFloatUniform("flipFlop",o.flipFlopMap,o)}\n                ${o.flipFlopAddCoef&&o.flipFlopMulCoef?`\n                    ${e.addFloatMADs("flipFlop",o)}\n                    `:""}\n                `:""}\n            \n            ${n(o)}\n            ${t(o)}\n            ${r(o)}\n            ${i(o)}\n            ${o.dspbrHemiFlakes?a(o):""}\n            ${s(o)}\n        `};mn=function(n){if(!n.dspbrFlakes)return["","",""];const t=e.addPDSFX("INTERNAL_backup_flakesCoverage","flakesCoverageV","ComputeFlakeCoverage",n),r=e.addColorPDSFX("INTERNAL_backup_flakesColor","flakesColorV","ComputeFlakeColor",n.dspbr&&n.gammaInput,n),a=e.addPDSFX("INTERNAL_backup_flakesRoughness","flakesRoughnessV","ComputeFlakeRoughness",n),o=e.addPDSFX("INTERNAL_backup_flakesSize","flakesSizeV","ComputeFlakeSize",n),i=e.addPDSFX("INTERNAL_backup_flipFlop","flipFlopV","ComputeFlipFlop",n),s=e.addColorPDSFX("INTERNAL_backup_flipFlopColor","flipFlopColorV","ComputeFlipFlopColor",n.dspbr&&n.gammaInput,n);let l=`\n                ${e.addFloatParameterResolution("flakesCoverageV","flakesCoverage",n.flakesCoverageMap,n.flakesCoverageAddCoef&&n.flakesCoverageMulCoef,!0,n)} \n                ${t.backup}\n                ${e.addColorParameterResolution("flakesColorV","flakesColor",n.flakesColorMap,n.flakesColorAddCoef&&n.flakesColorMulCoef,n.gammaInput&&!n.flakesColorMapLinear,!0,n)} \n                ${r.backup}\n                ${e.addFloatParameterResolution("flakesRoughnessV","flakesRoughness",n.flakesRoughnessMap,n.flakesRoughnessAddCoef&&n.flakesRoughnessMulCoef,!0,n)}\n                ${a.backup}\n                ${e.addFloatParameterResolution("flakesSizeV","flakesSize",n.flakesSizeMap,n.flakesSizeMulCoef&&n.flakesSizeAddCoef,!0,n)}\n                ${o.backup}\n                ${n.dspbrWithFlipFlopColor?`\n                    ${e.addColorParameterResolution("flipFlopColorV","flipFlopColor",n.flipFlopColorMap,n.flipFlopColorAddCoef&&n.flipFlopColorMulCoef,n.gammaInput&&!n.flipFlopColorMapLinear,!0,n)} \n                    ${s.backup}\n                    ${e.addFloatParameterResolution("flipFlopV","flipFlop",n.flipFlopMap,n.flipFlopAddCoef&&n.flipFlopMulCoef,!0,n)}\n                    ${i.backup}\n                    `:""}            \n            `,u=`\n                ${t.solve}\n                ${r.solve}\n                ${a.solve}\n                flakesRoughnessV = clamp(flakesRoughnessV, 0.036, 0.986);\n                ${o.solve}\n                ${n.dspbrWithFlipFlopColor?`\n                    ${s.solve}\n                    ${i.solve}\n                    flipFlopV = max(flipFlopV, 1e-12);\n                    ${D("initFlakesData",null,[S("surfaceData.objectSpacePosition"),S("normalize(surfaceData.objectSpaceNormal)"),c("flakesSizeV"),c("flakesCoverageV"),S("flakesColorV"),c("flakesRoughnessV"),c("flipFlopV"),S("flipFlopColorV")])};                \n                    `:`\n                    ${D("initFlakesData",null,[S("surfaceData.objectSpacePosition"),S("normalize(surfaceData.objectSpaceNormal)"),c("flakesSizeV"),c("flakesCoverageV"),S("flakesColorV"),c("flakesRoughnessV")])};                \n                    `}\n                ${D("initFlakesWeights",null,[S("surfaceData.view"),S("surfaceData.viewNormal")])};\n            \n            `;return[p(n),u,l]}}{let n=function(n){return`\n\n\n            ${T("Rotate3DForFlakes","v3",[S("iVec"),c("iAngle"),S("iAxe")])}{\n                ${z("s")} = sin(iAngle);\n                ${z("c")} = cos(iAngle);\n                ${z("x")} = iAxe.x;\n                ${z("y")} = iAxe.y;\n                ${z("z")} = iAxe.z;\n    \n                ${A("rot")} = ${A()}(${D("pow2","f",[c("x")])} * (1.0 - c) + c, x * y * (1.0 - c) - z * s, x * z * (1.0 - c) + y * s,\n                                                 x * y * (1.0 - c) + z * s, ${D("pow2","f",[c("y")])} * (1.0 - c) + c, y * z * (1.0 - c) - x * s,\n                                                 x * z * (1.0 - c) - y * s, y * z * (1.0 - c) + x * s, ${D("pow2","f",[c("z")])} * (1.0 - c) + c);\n    \n                return rot * iVec;\n            }   \n\n            ${T("computeMetallicFlakes",null,[p("metallicFlakesPresence"),x("metallicFlakesBaseColor"),c("presenceNoise"),c("presenceNoise2"),c("noisePositive"),c("noiseNegative"),S("T"),S("B")])} {\n                if (length(${M("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${z("mfp")} = ${l()}metallicFlakesPresence;\n                mfp = ${W("presenceNoise")};\n                ${z("aux")} = ${W("presenceNoise2")};\n                mfp += mix( - aux, aux, ${M("flakesDensity")});\n\n                mfp *= 5.0;\n                mfp = ${k("mfp")};\n\n                ${l()}metallicFlakesPresence = mfp;\n                ${l()}metallicFlakesBaseColor = mix(2.0 * ${M("flakesColor")}, ${F()}(0.0), ${Z("noiseNegative","0.5","1.0")});\n                \n                ${z("theta")}  = mfp * noisePositive* PI * 0.125;\n                ${z("phi")}  =  mfp * noiseNegative * PI * 0.125;\n                metalFlakes.flakesWorldNormal =  ${D("Rotate3DForFlakes","v3",[S("metalFlakes.flakesWorldNormal"),c("theta"),S("B")])};\n                metalFlakes.flakesWorldNormal =  ${D("Rotate3DForFlakes","v3",[S("metalFlakes.flakesWorldNormal"),c("phi"),S("T")])};\n            }\n\n            ${T("blendMetalFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("metallicFlakesBlending"),c("metallicFlakesPresence"),S("metallicFlakesBaseColor")])}{\n                if (length(${M("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${z("metallicFlakesStrength")}  = flakesMask * metallicFlakesPresence;\n\n                ${n.flakesNormalPerturbation?`${z("metalPerturbateNormal")}  = 0.1 * ${M("flakesBump")};`:`${z("metalPerturbateNormal")}  = 0.0;`}\n\n                metalFlakes.flakesRoughness = 1.0 - mix(0.75,0.55,${M("flakesRoughness")});\n                metal.flakesRoughness = metalFlakes.flakesRoughness + metalPerturbateNormal;\n\n                metal.flakesSR0Color = ${M("flakesColorMulCoef")} * metallicFlakesBlending * ${M("flakesColor")};\n                metalFlakes.flakesSR0Color = ${M("flakesColorMulCoef")} * metallicFlakesBaseColor * metallicFlakesStrength;\n\n                metalPerturbateNormal *= 10.0 * flakesMask;\n                metalFlakes.flakesWorldNormal = normalize(currentWorldNormal + metalPerturbateNormal * metalFlakes.flakesWorldNormal);\n\n            }\n        `},e=function(n){return`\n            ${T("computePearlFlakes",null,[p("pearlFlakesPresence"),x("pearlFlakesBaseColor"),c("presenceNoise"),c("presenceNoise2"),c("noisePositive"),c("noiseNegative"),S("T"),S("B")])} {\n                if (length(${M("pearlFlakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${z("pfp")} = ${l()}pearlFlakesPresence;\n                pfp = ${X(`${j("presenceNoise2")}`)};\n                ${z("aux")}  = ${X(`${j("presenceNoise")}`)};\n                pfp += mix( - aux, aux, ${M("pearlFlakesDensity")});\n\n                pfp *= 6.0;\n                pfp = ${k("pfp")};\n\n                ${l()}pearlFlakesPresence = pfp;\n                ${l()}pearlFlakesBaseColor = mix(2.0 * ${M("pearlFlakesColor")}, ${F()}(0.0), ${Z("noisePositive","0.5","1.0")});\n                \n                ${z("theta")}  = pfp * noisePositive * PI * 0.25;\n                ${z("phi")}  =  pfp * noiseNegative * PI * 0.25;\n                pearlFlakes.flakesWorldNormal =  ${D("Rotate3DForFlakes","v3",[S("pearlFlakes.flakesWorldNormal"),c("theta"),S("B")])};\n                pearlFlakes.flakesWorldNormal =  ${D("Rotate3DForFlakes","v3",[S("pearlFlakes.flakesWorldNormal"),c("phi"),S("T")])};\n            }\n\n            ${T("blendPearlFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("pearlFlakesPresence"),S("pearlFlakesBaseColor")])}{\n                if (length(${M("pearlFlakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n                ${z("pearlFlakesStrength")}  = flakesMask * pearlFlakesPresence;\n                ${n.flakesNormalPerturbation?`${z("pearlPerturbateNormal")}  = 0.05 * ${M("pearlFlakesBump")};`:`${z("pearlPerturbateNormal")} = 0.0;`}\n\n                pearlFlakes.flakesRoughness = 0.25;\n\n                pearlFlakes.flakesSR0Color = ${M("pearlFlakesColorMulCoef")} * pearlFlakesBaseColor * pearlFlakesStrength;\n\n                pearlPerturbateNormal *= 10.0 * sqrt(flakesMask);\n                pearlFlakes.flakesWorldNormal = normalize(currentWorldNormal + pearlPerturbateNormal * pearlFlakes.flakesWorldNormal);\n            }\n        `},t=function(n){return`\n            ${T("flakesVisibility",null,[p("flakesLODLevel"),p("metallicFlakesBlending"),p("flakesMask"),c("scaling")])}{\n                ${n.defaultInstancing?`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix * multipliedDefaultInstancingMatrix)`)])};\n                    `:`\n                    ${A("mat")}  = ${D("transposeMatrix","m3",[u("m3",`${A()}(modelMatrix)`)])};\n                    `}   \n                ${F("worldScaling")}  = 1.0/${F()}(length(mat[0]),length(mat[1]),length(mat[2]));\n                ${z("dist")}  = length(worldScaling * surfaceData.viewPosition);\n                ${z("NdotV")}  = dot(surfaceData.viewNormal, surfaceData.view);\n                if (NdotV <= 0.0) {\n                    ${l()}flakesLODLevel = 0.0;\n                    ${l()}metallicFlakesBlending = 0.0;\n                    ${l()}flakesMask = 0.0;\n                    return;\n                }\n                ${z("normDist")}  = ${k("scaling * dist * 0.00125")};\n                ${z("shortDist")}  = 1.0 - normDist;\n                ${l()}flakesLODLevel = scaling * dist;\n                ${n.advancedFlakesBlending?`${l()}metallicFlakesBlending = normDist * (0.5 * ${M("flakesDensity")} + 0.25);`:`${l()}metallicFlakesBlending = normDist * 0.5;`}\n                ${l()}flakesMask = shortDist;\n            }\n        \n            ${T("doFlakes",null,[])}{\n                ${F("currentWorldNormal")}  = surfaceData.worldNormal;\n                ${z("flakesMask")}  = 0.0;\n                ${z("flakesLODLevel")}  = 0.0;\n                ${z("scaling")}  = mix(0.0, 0.9, atan(PI*${M("flakesScale")})*2.0*INV_PI);\n                ${F("T")}  = ${D("getGeomT","v3",[S("currentWorldNormal")])};\n                ${F("B")}  = ${D("getGeomB","v3",[S("currentWorldNormal"),S("T")])};\n\n                ${z("metallicFlakesBlending")}  = 0.0;\n                ${z("metallicFlakesPresence")}  = 0.0;\n                ${F("metallicFlakesBaseColor")}  = ${F()}(0.0);\n\n                metal.flakesRoughness = 0.0;\n                metal.flakesSR0Color = ${F()}(0.0);\n                metal.flakesWorldNormal = currentWorldNormal;\n\n                metalFlakes.flakesRoughness = 0.0;\n                metalFlakes.flakesSR0Color = ${F()}(0.0);\n                metalFlakes.flakesWorldNormal = currentWorldNormal;\n\n                ${z("pearlFlakesPresence")}  = 0.0;\n                ${F("pearlFlakesBaseColor")}  = ${F()}(0.0);\n\n                ${n.pearlFlakesActivated?`\n                    pearlFlakes.flakesRoughness = 0.0;\n                    pearlFlakes.flakesSR0Color = ${F()}(0.0);\n                    pearlFlakes.flakesWorldNormal = currentWorldNormal;\n                    `:""}\n\n                ${D("flakesVisibility",null,[d("flakesLODLevel"),d("metallicFlakesBlending"),d("flakesMask"),c("scaling")])};\n\n                if (length(${M("pearlFlakesColorMulCoef")}) < kEpsilon && length(${M("flakesColorMulCoef")}) < kEpsilon) {\n                    return;\n                }\n\n                if (flakesMask < kEpsilon) {\n                    ${D("blendMetalFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("metallicFlakesBlending"),c("metallicFlakesPresence"),S("metallicFlakesBaseColor")])};\n                    ${n.pearlFlakesActivated?`\n                        ${D("blendPearlFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("pearlFlakesPresence"),S("pearlFlakesBaseColor")])};\n                        `:""}\n                    return;\n                }\n\n                ${F("tex")}  = scaling * surfaceData.objectSpacePosition;\n                tex.y = -abs(tex.y);\n                tex.x = -abs(tex.x);\n\n                ${n.flakesNormalPerturbation?`\n                    float noisePositive = ${J("0.85 * tex","flakesLODLevel","FLAKES_FREQUENCY","1.0","2.0")};\n                    float noiseNegative = ${J("0.85 * tex.yxz","flakesLODLevel","FLAKES_FREQUENCY","1.0","2.0")};\n                    `:"\n                    float noisePositive = 0.0;\n                    float noiseNegative = 0.0;\n                    "}\n                ${z("fbm1")}  = ${J("tex","flakesLODLevel","FLAKES_FREQUENCY","1.0","3.0")};\n                ${z("presenceNoise")}  = ${Z("fbm1","0.5","1.0")};\n\n                ${n.advancedPresenceNoise?`\n                    ${z("fbm2")}  = ${J("tex.yxz","flakesLODLevel","FLAKES_FREQUENCY","1.0","3.0")};\n                    ${z("presenceNoise2")}  = ${Z("fbm2","0.5","1.0")};\n                    `:`${z("presenceNoise2")}  = 0.0;`}\n\n                ${D("computeMetallicFlakes",null,[d("metallicFlakesPresence"),y("metallicFlakesBaseColor"),c("presenceNoise"),c("presenceNoise2"),c("noisePositive"),c("noiseNegative"),S("T"),S("B")])};\n                ${D("blendMetalFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("metallicFlakesBlending"),c("metallicFlakesPresence"),S("metallicFlakesBaseColor")])};\n                ${n.pearlFlakesActivated?`\n                    ${D("computePearlFlakes",null,[d("pearlFlakesPresence"),y("pearlFlakesBaseColor"),c("presenceNoise"),c("presenceNoise2"),c("noisePositive"),c("noiseNegative"),S("T"),S("B")])};\n                    ${D("blendPearlFlakes",null,[S("currentWorldNormal"),c("flakesMask"),c("pearlFlakesPresence"),S("pearlFlakesBaseColor")])};\n                    `:""}\n            }\n        `},r=function(r){return`\n            ${N({uniformName:"flakesColor",uniformType:"v3"})}\n            ${N({uniformName:"flakesDensity",uniformType:"f"})}\n            ${N({uniformName:"flakesBump",uniformType:"f"})}\n            ${N({uniformName:"flakesColorMulCoef",uniformType:"v3"})}\n            ${N({uniformName:"flakesColorAddCoef",uniformType:"v3"})}\n            ${N({uniformName:"pearlFlakesColor",uniformType:"v3"})}\n            ${N({uniformName:"pearlFlakesDensity",uniformType:"f"})}\n            ${N({uniformName:"pearlFlakesBump",uniformType:"f"})}\n            ${N({uniformName:"pearlFlakesColorMulCoef",uniformType:"v3"})}\n            ${N({uniformName:"pearlFlakesColorAddCoef",uniformType:"v3"})}\n            ${N({uniformName:"flakesRoughness",uniformType:"f"})}\n            ${N({uniformName:"flakesScale",uniformType:"f"})}\n         \n            ${L("FLAKES_FREQUENCY")} = 0.6;\n\n            \n            ${o.createStructure({structName:"flakes",attributes:[{type:"f",name:"flakesRoughness"},{type:"v3",name:"flakesSR0Color"},{type:"v3",name:"flakesWorldNormal"},{type:"v3",name:"flakesNormal"}]})}\n            ${o.declareStructure({name:"metal",structName:"flakes",addressSpace:"private"})};\n            ${o.declareStructure({name:"metalFlakes",structName:"flakes",addressSpace:"private"})};\n            ${o.declareStructure({name:"pearlFlakes",structName:"flakes",addressSpace:"private"})};\n            \n            ${n(r)}\n            ${e(r)}\n            ${t(r)}\n        `},a=function(n){return`      \n            ${D("doFlakes",null,[])};\n            metalFlakes.flakesNormal = normalize((${b("viewMatrix")}* (${R()}(metalFlakes.flakesWorldNormal, 0.0))).xyz);\n            metal.flakesNormal = surfaceData.viewNormal;\n            ${n.pearlFlakesActivated?`pearlFlakes.flakesNormal = normalize((${b("viewMatrix")} * (${R()}(pearlFlakes.flakesWorldNormal, 0.0))).xyz);`:""}\n        `};$n=function(n){return n.specGlossFlakes?[r(n),a(n),""]:["","",""]}}return cn=function(n){if(!n.thickness)return["","",""];const t=`\n                ${e.addTexturableFloatUniform("thickness",n.thicknessMap,n)}\n                ${n.thicknessAddCoef&&n.thicknessMulCoef?e.addFloatMADs("thickness",n):""}\n            `,r=e.addPDSFX("INTERNAL_backup_thickness","surfaceData.thickness","ComputeThickness",n),a=`\n                ${e.addFloatParameterResolution("surfaceData.thickness","thickness",n.thicknessMap,n.thicknessAddCoef&&n.thicknessMulCoef,!1,n)}   \n                ${r.backup}\n            `;return[t,`\n                ${r.solve}\n                if (materialData.ior <= 1.0 + 1e-6 || surfaceData.thickness <= 1e-6) {\n                    materialData.adjustedIoR = 1.0;\n                } else {\n                    ${F("dummyT")}  = ${D("getGeomT","v3",[S("surfaceData.worldNormal")])};\n                    ${F("dummyB")}  = ${D("getGeomB","v3",[S("surfaceData.worldNormal"),S("dummyT")])};\n                    ${F("dummyVector")}  = normalize(surfaceData.worldNormal + dummyB + dummyT);\n                    ${F("refractVec")}  = refract(-dummyVector, surfaceData.worldNormal, 1.0/materialData.ior);\n                    ${z("sin1")}  = sqrt(1.0 - ${H("dot(-dummyVector, surfaceData.worldNormal)")});\n                    refractVec = normalize(-dummyVector + (refractVec * surfaceData.thickness));\n                    ${z("sin2")}  = sqrt(1.0 - ${H("dot(refractVec, surfaceData.worldNormal)")});\n                    materialData.adjustedIoR = max(abs(sin1), 1e-12) / max(abs(sin2), 1e-12);\n                }\n            `,a]},pn=function(n){if(!n.iridescence)return["","",""];const t=`\n                ${N({uniformName:"iridescenceIoR",uniformType:"f"})}\n                ${e.addTexturableFloatUniform("iridescence",n.iridescenceMap,n)}\n                ${n.iridescenceAddCoef&&n.iridescenceMulCoef?e.addFloatMADs("iridescence",n):""}\n                ${e.addTexturableFloatUniform("iridescenceThickness",n.iridescenceThicknessMap,n)}\n                ${n.iridescenceThicknessAddCoef&&n.iridescenceThicknessMulCoef?e.addFloatMADs("iridescenceThickness",n):""}\n            `,r=e.addPDSFX("INTERNAL_backup_iridescence","surfaceData.iridescence","ComputeIridescence",n),a=e.addPDSFX("INTERNAL_backup_iridescenceThickness","surfaceData.iridescenceThickness","ComputeIridescenceThickness",n),o=`\n                materialData.iridescenceIoR = ${M("iridescenceIoR")};\n                ${e.addFloatParameterResolution("materialData.iridescence","iridescence",n.iridescenceMap,n.iridescenceAddCoef&&n.iridescenceMulCoef,!1,n)}\n                ${r.backup}\n                ${e.addFloatParameterResolution("materialData.iridescenceThickness","iridescenceThickness",n.iridescenceThicknessMap,n.iridescenceThicknessAddCoef&&n.iridescenceThicknessMulCoef,!1,n)}\n                ${a.backup}\n            `;return[t,`\n                ${r.solve}\n                ${a.solve}\n                if (materialData.iridescenceThickness < 1e-12) {\n                    materialData.iridescence = 0.0;\n                }\n                materialData.iridescenceSR0Color = materialData.sr0Color;\n                ${z("iridescenceEnergyCorrection")} = 0.0;\n                if (materialData.iridescence > 0.0) {\n                    // multiply materialData.iridescenceSR0Color by specFactor to make thin film depend on specular\n                    //${z("specFactor")} = mix(materialData.specularContribution, 1.0, materialData.metalness);\n                    // We omit the coloration, to add back color, use materialData.specularBlendingSR0 as baseSr0Color\n                    ${F("baseSr0Color")} = ${F()}(1.0) * mix(materialData.F0, dot(albedo, luminanceVector), materialData.metalness);\n                    ${F("baseSr90Color")} = ${F()}(1.0);\n                    ${R("fresnelIridescence")}  = ${D("ComputeIridescenceFresnel","v4",[c("1.0"),c("materialData.iridescenceIoR"),S("baseSr0Color"),c("materialData.iridescenceThickness * 1e3"),c("NoV")])};\n                    materialData.iridescenceSR0Color =  ${D("F0FromFresnelSchlick","v3",[S("fresnelIridescence.xyz"),S("baseSr90Color"),c("NoV")])};\n                    // Blending\n                    materialData.sr0Color = mix(materialData.sr0Color, materialData.iridescenceSR0Color, materialData.iridescence);\n                    materialData.sr90Color = mix(materialData.sr90Color, baseSr90Color, materialData.iridescence);\n                    materialData.specularBlendingSR0 = mix(materialData.specularBlendingSR0, materialData.iridescenceSR0Color, materialData.iridescence);\n                    // Energy\n                    ${z("iridescenceF0")} = ${H("(materialData.iridescenceIoR - 1.0)/(materialData.iridescenceIoR + 1.0)")};\n                    iridescenceEnergyCorrection = 1.0 - mix(fresnelIridescence.w, ${D("AverageMultipleFresnel","f",[c("iridescenceF0")])}, 1.0 - ${W("1.0 - materialData.roughness * materialData.roughness")});\n                    iridescenceEnergyCorrection *= (1.0 - ${k("materialData.iridescenceIoR - 1.5")} * 0.15);\n                }\n            `,o]},{getUniformShaders:function(n,e){let t=K(e),r=Q(e,n),a=en(e),o=tn(e),i=rn(e),s=an(e),l=on(e),m=sn(e),$=ln(e),p=un(e),d=mn(e),f=$n(e),h=cn(e),g=pn(e),v=nn(e),x=`\n                ${r[0]}\n                ${t[0]}\n                ${o[0]}\n                ${i[0]}\n                ${v[0]}\n                ${s[0]} \n                ${l[0]}   \n                ${m[0]}   \n                ${a[0]}  \n                ${$[0]}\n                ${p[0]}\n                ${d[0]}\n                ${f[0]}\n                ${h[0]}\n                ${g[0]}\n                ${N({uniformName:"ior",uniformType:"f"})}\n            `,y="";e.dspbr&&n&&(y=e.vrDevice?`\n                    materialData.specularEnergyConservationConstant =  ${F()}(0.0);\n                    materialData.diffuseEnergyConservationConstant = 1.0;    \n                    `:`\n                    // Specular\n                    ${z("averageDirectionalMultipleAlbedo")} = ${D("AverageDirectionalMultipleAlbedo","f",[c("materialData.roughness")])};\n                    ${F("averageMultipleFresnel")} = ${D("AverageMultipleFresnel","v3",[S("materialData.sr0Color"),S("materialData.sr90Color")])};\n                    ${z("multipleScatteringGGX")} = ${H(`1.0 - ${D("DirectionalMultipleAlbedo","f",[c("NoV"),c("materialData.roughness")])}`)}/max(1.0 - averageDirectionalMultipleAlbedo, 1e-6);\n                    ${F("multipleScatteringFresnel")} = (averageMultipleFresnel * averageMultipleFresnel * averageDirectionalMultipleAlbedo)/max(1.0 - averageMultipleFresnel * (1.0 - averageDirectionalMultipleAlbedo), ${F()}(1e-6));\n                    materialData.specularEnergyConservationConstant =  multipleScatteringGGX * multipleScatteringFresnel;\n                    // Diffuse\n                    ${z("directionalAlbedo")} = ${D("DirectionalAlbedo","f",[c("materialData.F0"),S("materialData.specularTint"),c("NoV"),c("materialData.roughness")])};\n                    ${z("averageDirectionalAlbedo")} = ${D("AverageDirectionalAlbedo","f",[c("materialData.F0"),S("materialData.specularTint"),c("materialData.roughness")])};\n                    materialData.diffuseEnergyConservationConstant = ${H("1.0 - directionalAlbedo")} / max(1.0 - averageDirectionalAlbedo, 1e-6);   \n                    materialData.diffuseEnergyConservationConstant = mix(1.0, materialData.diffuseEnergyConservationConstant, materialData.specularContribution); \n                    ${e.iridescence?`\n                        //${z("directionalIridescenceAlbedo")} = ${D("DirectionalAlbedo","f",[S("materialData.iridescenceSR0Color"),c("NoV"),c("materialData.roughness")])};\n                        //${z("averageDirectionalIridescenceAlbedo")} = ${D("AverageDirectionalAlbedo","f",[S("materialData.iridescenceSR0Color"),c("materialData.roughness")])};\n                        //materialData.diffuseEnergyConservationConstant = mix(materialData.diffuseEnergyConservationConstant, ${H("1.0 - directionalIridescenceAlbedo")} / max(1.0 - averageDirectionalIridescenceAlbedo, 1e-6), materialData.iridescence);\n                        materialData.diffuseEnergyConservationConstant = mix(materialData.diffuseEnergyConservationConstant, iridescenceEnergyCorrection, materialData.iridescence); \n                        `:""}\n                    // Use this one if thin film must depend on specular\n                    //materialData.diffuseEnergyConservationConstant = mix(1.0, materialData.diffuseEnergyConservationConstant, materialData.specularContribution);\n                 `);const _=e.PDSFX?"INTERNAL_computed_viewPosition":C("vViewPosition");let T=`\n                materialData.ior = ${M("ior")};\n                materialData.adjustedIoR = materialData.ior;\n                ${h[2]}\n                ${$[2]}\n                ${t[2]}\n                ${o[2]}\n                ${i[2]}\n                ${v[2]}\n                ${s[2]} \n                ${l[2]}   \n                ${m[2]}   \n                ${p[2]}\n                ${d[2]}\n                ${f[2]}\n                ${g[2]}\n                ${a[2]}\n            `;return[x,`\n                \n                if (${b("projectionMatrix")}[3][3] > 0.5) {\n                    surfaceData.view = ${F()}(0.0,0.0,1.0);\n                } else {\n                    ${e.isDecal?"surfaceData.view = normalize( dViewPosition);":`surfaceData.view = normalize( ${_} );`}\n                }\n\n                ${e.isDecal?"\n                    surfaceData.worldPosition = dWorldPosition;\n                    surfaceData.viewPosition = dViewPosition;\n                    ":`\n                    surfaceData.viewPosition = ${_};\n                    surfaceData.worldPosition = ${C("vWorldPosition")};\n                    `}\n                ${F("vPos")}  = surfaceData.viewPosition;\n\n                ${e.needObjectSpaceData?`\n                    surfaceData.objectSpacePosition = ${C("vObjectSpacePosition")};\n                    surfaceData.objectSpaceNormal = ${C("vObjectSpaceNormal")} ;\n                    ${e.isDecal?"\n                        surfaceData.objectSpacePosition = dObjectSpacePosition;\n                        surfaceData.objectSpaceNormal = dObjectNormal;\n                        ":""}\n                    `:""}\n\n                ${r[1]}\n                ${h[1]}\n                ${$[1]}\n                ${t[1]}\n                ${o[1]}\n                ${i[1]}\n                ${v[1]}\n                ${s[1]}\n                ${l[1]}\n                ${m[1]}\n                ${p[1]}\n                ${d[1]}\n                ${f[1]}\n                ${e.useSpecularAA?`             \n                    surfaceData.TForSpecularAA = ${D("getGeomT","v3",[S("surfaceData.viewNormal")])};\n                    surfaceData.BForSpecularAA = ${D("getGeomB","v3",[S("surfaceData.viewNormal"),S("surfaceData.TForSpecularAA")])};\n                    surfaceData.TBNMatrixForSpecularAA = ${D("transposeMatrix","m3",[u("m3",`${A()}(surfaceData.TForSpecularAA, surfaceData.BForSpecularAA, surfaceData.viewNormal)`)])};\n                    `:""}\n\n                ${e.shadowMapDebugMaterial?`\n\t\t\t\t\talbedo = ${F()}(1.0);\n\t\t\t\t\tmaterialData.specularContribution = 0.0;\n\t\t\t\t\tmaterialData.metalness = 0.0;\n\t\t\t\t\t`:""}\n  \n                ${e.specgloss?`\n                    materialData.F0 = 1.0;\n                    materialData.specularBlendingSR0 = materialData.specularTint;\n                    materialData.sr0Color = materialData.specularBlendingSR0;\n                    materialData.sr90Color = ${F()}(1.0);\n                    `:`\n                    materialData.F0 = ${H("(materialData.ior - 1.0)/(materialData.ior + 1.0)")};\n                    materialData.specularBlendingSR0 = materialData.F0 * materialData.specularTint;\n                    materialData.sr0Color = mix(materialData.specularBlendingSR0 * materialData.specularContribution, albedo, materialData.metalness);\n                    materialData.sr90Color = ${F()}(1.0) * ((1.0-materialData.metalness)*materialData.specularContribution + materialData.metalness);\n                    `}\n                ${g[1]}\n                ${a[1]}           \n                ${e.specgloss?"\n                    materialData.diffuseColor = albedo;\n                    materialData.transparentColor = albedo;\n                    ":"\n                    materialData.diffuseColor = albedo * (1.0 - materialData.metalness) * (1.0 - materialData.transparency);\t\n                    materialData.transparentColor = albedo * (1.0 - materialData.metalness) * materialData.transparency;\n                    "}\n                ${e.dspbrWithTranslucency?e.dspbrWithTranslucencyColor?"materialData.translucencyColor *= (1.0 - materialData.metalness) * (1.0 - materialData.transparency);":"materialData.translucencyColor = materialData.diffuseColor;":""}\n\n                ${y}\n            `,T]}}}),define("DS/ShaderBuilders/LineUtils/LineBasicVertexShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=(n,e,t=!1)=>o.parameter(n,e,t),s=n=>o.parameterF(n),l=n=>o.parameter("b",n),u=n=>o.parameterV2(n),m=n=>o.parameterV3(n),$=n=>o.parameterV4(n),c=(n,e,t)=>r.FunctionHandler.declareFunction(n,e,t),p=(n,e,t)=>r.FunctionHandler.callFunction(n,e,t),d=n=>p("isNull","b",[s(n)]),f=n=>p("vNormalize","v3",[m(n)]),h=n=>p("vNormalize","v2",[u(n)]),g=n=>{var t={uniformName:n};return e.getUniform(t)},v=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},S=(n=null)=>{var e={name:n};return a.bool(e)},x=(n=null)=>{var e={name:n};return a.float(e)},y=(n=null)=>{var e={name:n};return a.vec2(e)},_=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},T=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},D=(n=null)=>{var e={name:n};return a.mat4(e)},C=n=>t.addVarying(n),P=n=>t.getVarying(n,t.ShaderStages.out),N=n=>t.getBuiltin(n,t.ShaderStages.out),M=(n,e,t)=>p("getViewSpaceConvertedPosition","v3",[u(n),u(e),s(t)]);return function(t,r){let a=n._ShaderChunk,o=`\n            ${r}\n        `,b="";return(t.wideLine||t.dashedLine)&&(o=`\n                ${o}\n                ${(n=>e.addUniform(n))({uniformName:"pixelSize",uniformType:"v2"})}\n\n                ${c("computeWorldSizeToPixel","f",[$("pos")])} {\n                    return abs(${v("projectionMatrix")}[0][0]/pos.w)/${g("pixelSize")}.x;\n                }\n            `,b=`\n                ${x("worldSizeToPixelCurr")}  = ${p("computeWorldSizeToPixel","f",[$(N("position"))])};\n            `,t.dashedLine&&(o=`\n                    ${o}\n                    ${C({varyingName:"vLineDistance",varyingType:"v2"})}\n                `,b=t.cpuPattern?`\n                        ${b}\n                        ${P("vLineDistance")} = lineDistance;\n                    `:`\n                        ${b}\n                        ${x("modelMatrixScaleX")}  = length(modelMatrix[0]);\n                        ${t.defaultInstancing?"\n                            modelMatrixScaleX *= length(multipliedDefaultInstancingMatrix[0]);\n                            ":""}\n                        ${t.fixedSize?"modelMatrixScaleX *= simpleNodeData.fixedSizeScale;":""}\n                        ${t.worldSizePattern?`${P("vLineDistance")} = modelMatrixScaleX * lineDistance;`:`${P("vLineDistance")} = worldSizeToPixelCurr * modelMatrixScaleX * lineDistance;`}\n                    `,t.worldSizePattern?(o=`\n                        ${o}\n                        ${C({varyingName:"vPointCurr",varyingType:"v3"})}\n                        ${t.worldSizePattern2?C({varyingName:"vPatternStartEnd",varyingType:"v2"}):""}\n                    `,b=`\n                        ${b}\n                        ${P("vPointCurr")} = mvPosition.xyz;\n                        ${t.worldSizePattern2?`${P("vPatternStartEnd")} = patternStartEnd;`:""}                \n                    `,t.wideLine&&(o=`\n                            ${o}\n                            ${C({varyingName:"vPointNext",varyingType:"v3"})}\n                            ${C({varyingName:"vPointPrec",varyingType:"v3"})}\n                            ${C({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                            ${C({varyingName:"vConstantNext",varyingType:"v3"})}\n                            ${C({varyingName:"vConstantCurr",varyingType:"v3"})}\n                            ${C({varyingName:"vConstantPrec",varyingType:"v3"})}\n                        `)):t.wideLine&&(o=`\n                        ${o}\n                        ${C({varyingName:"vPointNext",varyingType:"v2"})}\n                        ${C({varyingName:"vPointPrec",varyingType:"v2"})}\n                        ${C({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                        ${C({varyingName:"vLineDistanceLeftRight",varyingType:"v4"})}\n                        ${C({varyingName:"vConstantNext",varyingType:"v2"})}\n                        ${C({varyingName:"vConstantCurr",varyingType:"v2"})}\n                        ${C({varyingName:"vConstantPrec",varyingType:"v2"})}\n                    `)),t.wideLine&&(b=`\n                    ${b}\n                    ${n._DefaultShaderChunk.getModelViewTransformationChunk(`${T("mvPositionPrec")} `,`${T()}(previousPos.xyz, 1.0)`,t)}\n                    ${n._DefaultShaderChunk.getModelViewTransformationChunk(`${T("mvPositionSuiv")} `,`${T()}(followingPos.xyz, 1.0)`,t)}\n                    ${T("pmvPosition")}  = ${v("projectionMatrix")} * mvPosition;\n                    ${T("pmvPositionPrec")}  = ${v("projectionMatrix")} * mvPositionPrec;\n                    ${T("pmvPositionSuiv")}  = ${v("projectionMatrix")} * mvPositionSuiv;\n                    ${_("eps")}  = ${_()}(1e-6);\n                    ${S("bPrecCurr")}  = !all(lessThan(abs(position_.xyz - previousPos.xyz), eps));\n                    ${S("bCurrNext")}  = !all(lessThan(abs(followingPos.xyz - position_.xyz), eps));   \n                    \n                    ${`\n            ${S("clipped")}  = false;\n            ${_("testClip")}  = ${_()}(sign(pmvPositionPrec.w + pmvPositionPrec.z), sign(pmvPosition.w + pmvPosition.z), sign(pmvPositionSuiv.w + pmvPositionSuiv.z));\n            if (bPrecCurr && testClip.x * testClip.y < 0.0 ){\n                ${x("a")}  = (pmvPositionPrec.w + pmvPositionPrec.z)/((pmvPositionPrec.w + pmvPositionPrec.z) - (pmvPosition.w + pmvPosition.z));\n                if (testClip.x < 0.0) {\n                    pmvPositionPrec = (1.0 - a) * pmvPositionPrec + a * pmvPosition;\n                    clipped = true;\n                } else if (mod(sideExtrusion,2.0) == 1.0) {\n                   pmvPosition = (1.0 - a) * pmvPositionPrec + a * pmvPosition;\n                    pmvPositionSuiv = pmvPosition;\n                    bCurrNext = false;\n                    clipped = true;\n                }\n\n            }\n            if (bCurrNext && testClip.y * testClip.z < 0.0 ){\n                ${x("a")}  = (pmvPosition.w + pmvPosition.z)/((pmvPosition.w + pmvPosition.z) - (pmvPositionSuiv.w + pmvPositionSuiv.z));\n                if (testClip.z < 0.0) {\n                    pmvPositionSuiv = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;\n                    clipped = true;\n                } else if (mod(sideExtrusion,2.0) == 0.0){\n                    pmvPosition = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;\n                    pmvPositionPrec = pmvPosition;\n                    bPrecCurr = false;\n                    clipped = true;\n                }\n\n            }\n    `}\n                    ${"round"===t.linecap||"round"===t.linejoin?`\n                        ${T("mvpPositionPrecR")}  = pmvPositionPrec;\n                        ${T("mvpPositionR")}  = pmvPosition;\n                        ${T("mvpPositionSuivR")}  = pmvPositionSuiv;\n                        `:""}\n                    pmvPosition.y *= ${g("pixelSize")}.x/${g("pixelSize")}.y;\n                    pmvPositionPrec.y *= ${g("pixelSize")}.x/${g("pixelSize")}.y;\n                    pmvPositionSuiv.y *= ${g("pixelSize")}.x/${g("pixelSize")}.y;\n                    ${x("oldW")}  = abs(pmvPosition.w);\n                    ${x("oldWPrec")}  = abs(pmvPositionPrec.w);\n                    ${x("oldWSuiv")}  = abs(pmvPositionSuiv.w);\n                    pmvPosition /= oldW;\n                    pmvPositionPrec /= oldWPrec;\n                    pmvPositionSuiv /= oldWSuiv;\n                    ${x("offset")}  = ${p("getHalfWidth","f",[])}  * ${g("pixelSize")}.x ;\n                    ${y("pos")} ;\n                    ${y("posPrecCurr")} ;\n                    ${y("posCurrNext")} ;\n                    ${y("dirPrecCurr")} ;\n                    ${y("dirCurrNext")} ;\n                    ${x("orientation")}  = sign(sideExtrusion);\n                    ${S("parity")}  = mod(sideExtrusion,2.0) < 0.5;\n                    if (${d("length(pmvPosition.xy - pmvPositionPrec.xy)")}) {\n                        bPrecCurr = false;\n                    }\n                    if (${d("length(pmvPositionSuiv.xy - pmvPosition.xy)")}) {\n                        bCurrNext = false;\n                    }\n                    ${function(n){return`\n            if (bPrecCurr){\n                dirPrecCurr = pmvPosition.xy - pmvPositionPrec.xy;\n                dirPrecCurr = ${h("dirPrecCurr")};\n                posPrecCurr = pmvPosition.xy + offset * orientation * ${y()}(-dirPrecCurr.y, dirPrecCurr.x);\n            } else if (bCurrNext) {\n                dirPrecCurr = pmvPosition.xy - pmvPositionSuiv.xy;\n                dirPrecCurr = ${h("dirPrecCurr")};\n                posPrecCurr = pmvPosition.xy + offset * dirPrecCurr.xy;\n            }\n            \n            if (bCurrNext){\n                dirCurrNext = pmvPositionSuiv.xy - pmvPosition.xy;\n                dirCurrNext = ${h("dirCurrNext")};\n                posCurrNext = pmvPosition.xy + offset * orientation * ${y()}(-dirCurrNext.y, dirCurrNext.x);\n            } else if (bPrecCurr) {\n                dirCurrNext = pmvPosition.xy - pmvPositionPrec.xy;\n                dirCurrNext = ${h("dirCurrNext")};\n                posCurrNext = pmvPosition.xy + offset * dirCurrNext.xy;\n            }\n            \n            ${y("dir")}  = ${h("dirCurrNext.xy - dirPrecCurr.xy")};\n            ${S("col")}  = false;\n            if ( bPrecCurr && bCurrNext){\n                if (${d("length(dir)")}){\n                    dir = ${y()}(-dirCurrNext.y, dirCurrNext.x);\n                    col = true;\n                }\n                ${S("realCol")}  = length(${f("followingPos.xyz - position_.xyz")} - ${f("position_.xyz - previousPos.xyz")}) < 1e-2;\n                ${x("sinAlpha")}  = dir.y * dirPrecCurr.x - dir.x * dirPrecCurr.y;\n                ${x("alpha")}  = asin(abs(sinAlpha));\n                ${x("distPoints")}  = min(distance(pmvPosition.xy, pmvPositionPrec.xy), distance(pmvPosition.xy, pmvPositionSuiv.xy)) + offset;\n                ${x("dist")}  = offset/ sinAlpha;\n                if (sign(sinAlpha) == -orientation) {\n                    if ( alpha < radians(45.0)) {\n                    ${"round"===n.linejoin?`\n                        if (parity){\n                            pos = pmvPosition.xy - sign(sinAlpha) * offset * ${y()}(-dirCurrNext.y,dirCurrNext.x);\n                            pos -= offset * dirCurrNext;\n                        } else {\n                            pos = pmvPosition.xy - sign(sinAlpha) *offset * ${y()}(-dirPrecCurr.y,dirPrecCurr.x);\n                            pos += offset * dirPrecCurr;\n                        }\n                        `:"\n                        if (parity){\n                            pos = posCurrNext - offset * dirCurrNext;\n                        } else {\n                            pos = posPrecCurr + offset * dirPrecCurr;\n                        }\n                        "}\n                    } else {\n                        pos = pmvPosition.xy - dir *abs(dist);\n                    }\n                    if (col && !realCol) {\n                        if (parity){\n                            pos += dist * dirCurrNext*orientation;\n                        } else {\n                            pos -= dist * dirPrecCurr *orientation;\n                        }\n                    }\n                } else {\n                    if (max(distPoints, offset) < abs(dist)){\n                        dist = max(distPoints - offset, offset)*sign(sinAlpha);\n                        if (alpha < radians(22.5)){\n                            if (parity){\n                                pos = posCurrNext + dist * dirCurrNext*orientation;\n                            } else {\n                                pos = posPrecCurr - dist * dirPrecCurr *orientation;\n                            }\n                            if (col && !realCol) {\n                                if (parity){\n                                    pos += dist * dirCurrNext*orientation;\n                                } else {\n                                    pos -= dist * dirPrecCurr *orientation;\n                                }\n                            }\n                        } else {\n                            pos = pmvPosition.xy + dir * max(distPoints, offset);\n\n                            if (col && !realCol) {\n                                if (parity){\n                                    pos += dist * dirCurrNext*orientation;\n                                } else {\n                                    pos -= dist * dirPrecCurr *orientation;\n                                }\n                            }\n                        }\n                    } else {\n                        pos = pmvPosition.xy + dir *abs(dist);\n                        if (col && !realCol) {\n                            if (parity){\n                                pos += dist * dirCurrNext*orientation;\n                            } else {\n                                pos -= dist * dirPrecCurr *orientation;\n                            }\n                        }\n                    }\n                }\n            } else if(bPrecCurr || bCurrNext) {\n                ${"butt"===n.linecap?`pos = pmvPosition.xy + offset * ${y()}(-dirCurrNext.y, dirCurrNext.x)*orientation;`:"pos = (posCurrNext - pmvPosition.xy)  + posPrecCurr;"}\n            } else {\n                pos = pmvPosition.xy + offset;\n            }\n        \n        `}(t)}\n                    ${t.dashedLine||"round"===t.linejoin||"round"===t.linecap?`${_("auxVec")}  = ${_()}(pos.x, pos.y * ${g("pixelSize")}.y/${g("pixelSize")}.x,0.0);`:""}\n                    ${t.dashedLine&&t.worldSizePattern?`\n                        ${y("zwCur")} = ${y()}(pmvPosition.z, pmvPosition.w);\n                        ${P("vPointCurr")} = ${M("pos.xy","zwCur","oldW")};`:""} \n\n                    float finalZ = ${p("getFinalZ","f",[l("clipped"),i("b2","bvec2(bPrecCurr && !col,bCurrNext)"),m("pmvPosition.xyz"),m("pmvPositionPrec.xyz"),m("pmvPositionSuiv.xyz"),u("pos"),s("oldW"),m("mvPosition.xyz"),s("worldSizeToPixelCurr")])};\n                `,(t.dashedLine&&t.worldSizePattern||t.polygonBorderMode)&&(o=`\n                        ${o}\n                        ${c("getPlanEquation","v4",[m("v1"),m("v2"),m("randomPosition")])}{\n                            ${_("normal")}  = cross(v1,v2);\n                            normal = ${f("normal")};\n                            ${x("d")} ;\n                            d = -dot(normal,randomPosition);\n                            return ${T()}(normal,d);\n                        }\n\n                        ${c("getViewSpaceConvertedPosition","v3",[u("pos"),u("zw"),s("w")])}{\n                            ${T("res")} = ${T()}(pos,zw);\n                            res *= w;\n                            res.y *= ${g("pixelSize")}.y/${g("pixelSize")}.x;\n                            ${D("projMatrix")}  = ${v("projectionMatrix")};\n                            ${D("inverseProjection")}  = ${D()}(projMatrix);\n                            if (! ${d("projMatrix[3][3]")} ) {\n                                inverseProjection[0][0] = 1.0 / projMatrix[0][0];\n                                inverseProjection[1][1] = 1.0 / projMatrix[1][1];\n                                inverseProjection[2][2] = 1.0 / projMatrix[2][2];\n                                inverseProjection[3][2] = -projMatrix[3][2] / projMatrix[2][2];\n                                inverseProjection[3][3] = 1.0;\n                            } else {\n                                inverseProjection[0][0] = 1.0 / projMatrix[0][0]; \n                                inverseProjection[1][1] = 1.0 / projMatrix[1][1];\n                                inverseProjection[2][2] = 0.0;\n                                inverseProjection[2][3] = 1.0 / projMatrix[3][2];\n                                inverseProjection[3][2] = 1.0 / projMatrix[2][3];\n                                inverseProjection[3][3] = -projMatrix[2][2] / (projMatrix[3][2] * projMatrix[2][3]);\n                            }\n                            res = inverseProjection * res;\n                            return res.xyz/res.w;\n                        }\n                    `),o=`\n                    ${o}\n                    ${a.PDSFX_halfWidth_pars_vertex_fragment(t)}\n                        ${c("getSegmentDepthValue","f",[m("dir"),m("posToComp")])}{\n                            ${_("nDir")}  = ${f("dir")};\n                            return min(1e18,(dot(posToComp,nDir) * nDir).z);\n                        }\n\n                        ${c("getFinalZ","f",[l("clipped"),i("b2","precNext"),m("pmvPosition"),m("pmvPositionPrec"),m("pmvPositionSuiv"),u("pos"),s("oldW"),m("mvPosition"),s("worldSizeToPixel")])}{\n                            ${_("computedPosition")}  = ${_()}(pos.x, pos.y,pmvPosition.z);\n                            ${x("finalZ")}  = pmvPosition.z;\n                            ${t.polygonBorderMode?`\n                                ${_("precDir")} ;\n                                ${_("nextDir")} ;\n                                if (precNext.y) {\n                                    nextDir = pmvPositionSuiv.xyz - pmvPosition.xyz;\n                                }\n                                if (precNext.x) {\n                                    precDir = pmvPosition.xyz - pmvPositionPrec.xyz;\n                                }\n                                if (precNext.x && precNext.y && length(cross(nextDir,precDir)) > 1e-6) {\n                                    ${T("equationP")}  = ${p("getPlanEquation","v4",[m("nextDir"),m("precDir"),m("pmvPosition.xyz")])};\n                                    finalZ = - (equationP.x * computedPosition.x + equationP.y * computedPosition.y + equationP.w)/equationP.z;\n                                    ${y("zw")} = ${y()}(finalZ,1.0);\n                                    ${_("mvComputedPos")}  = ${M("pos","zw","oldW")};\n                                    ${_("positionToComputed")}  = mvComputedPos.xyz - mvPosition;\n                                    if (abs(positionToComputed.z) > 10.0*${p("getHalfWidth","f",[])} / worldSizeToPixel) {\n                                        mvComputedPos.z = mvPosition.z + 10.0*${p("getHalfWidth","f",[])} / worldSizeToPixel * sign(positionToComputed.z);\n                                    }\n                                    ${T("mvpComputedPos")}  = ${v("projectionMatrix")} * ${T()}(mvComputedPos,1.0);\n                                    mvpComputedPos /= abs(mvpComputedPos.w);\n                                    finalZ = mvpComputedPos.z;\n                                } else if (precNext.x) {\n                                    finalZ = ${p("getSegmentDepthValue","f",[m("precDir"),m("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                                } else if (precNext.y) {\n                                    finalZ = ${p("getSegmentDepthValue","f",[m("nextDir"),m("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                                }\n                                return 0.99999*finalZ;\n                                `:`\n                                if (!clipped) {\n                                    return finalZ;\n                                }\n                                if (precNext.x) {\n                                    finalZ = ${p("getSegmentDepthValue","f",[m("pmvPosition.xyz - pmvPositionPrec.xyz"),m("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                                } else if (precNext.y) {\n                                    finalZ = ${p("getSegmentDepthValue","f",[m("pmvPositionSuiv.xyz - pmvPosition.xyz"),m("computedPosition.xyz - pmvPosition.xyz")])} + pmvPosition.z;\n                                }\n                                return finalZ;\n                                `}\n                        }\n                `,t.dashedLine&&(b=`\n                        ${b}\n                        ${P("vLineDistanceAltResetSecondDist")}.x = ${P("vLineDistance")}.x;\n                        ${t.worldSizePattern?`\n                            ${P("vConstantNext")} = ${M("pmvPositionSuiv.xy",`${y()}(pmvPositionSuiv.z, pmvPositionSuiv.w)`,"oldWSuiv")};\n                            ${P("vConstantPrec")} = ${M("pmvPositionPrec.xy",`${y()}(pmvPositionPrec.z, pmvPositionPrec.w)`,"oldWPrec")};\n                            ${P("vConstantCurr")} = ${M("pmvPosition.xy",`${y()}(pmvPosition.z, pmvPosition.w)`,"oldW")};\n                            ${P("vLineDistance")}.x = lineDistance.x* modelMatrixScaleX;\n                            ${P("vLineDistance")}.y = lineDistance.y* modelMatrixScaleX;\n                            ${P("vLineDistanceAltResetSecondDist")}.y = 0.0;\n                            if (!parity){\n                                ${P("vLineDistanceAltResetSecondDist")}.x = ${P("vLineDistance")}.y;\n                                ${P("vPointPrec")} = ${P("vConstantPrec")}.xyz;\n                                ${P("vPointNext")} = ${P("vConstantCurr")}.xyz;\n                            } else {\n                                ${P("vLineDistanceAltResetSecondDist")}.x = ${P("vLineDistance")}.x;\n                                ${P("vPointPrec")} = ${P("vConstantCurr")}.xyz;\n                                ${P("vPointNext")} = ${P("vConstantNext")}.xyz;\n                                if (abs(lineDistance.x - lineDistance.y) < 1e-6) {\n                                    ${P("vLineDistanceAltResetSecondDist")}.y = 1.0;\n                                }\n                            }\n                            `:`\n                            ${T("mvpPositionPrec")}  = ${v("projectionMatrix")} * mvPositionPrec;\n                            ${T("mvpPosition")}  = ${v("projectionMatrix")} * mvPosition;\n                            ${T("mvpPositionSuiv")}  = ${v("projectionMatrix")} * mvPositionSuiv;\n                            ${P("vConstantNext")} = (mvpPositionSuiv.xy / mvpPositionSuiv.w + 1.0)/ ${g("pixelSize")};\n                            ${P("vConstantPrec")} = (mvpPositionPrec.xy / mvpPositionPrec.w + 1.0) / ${g("pixelSize")};\n                            ${P("vConstantCurr")} = (mvpPosition.xy / mvpPosition.w + 1.0) / ${g("pixelSize")};\n                            ${t.cpuPattern?`${P("vLineDistance")}.x = lineDistance.x ; ${P("vLineDistance")}.y = lineDistance.y ;`:""}\n                            float worldSizeToPixelPrec = ${p("computeWorldSizeToPixel","f",[$("mvpPositionPrec")])};\n                            float worldSizeToPixelNext = ${p("computeWorldSizeToPixel","f",[$("mvpPositionSuiv")])};\n                            ${P("vLineDistanceAltResetSecondDist")}.y = 0.0;\n                            if (!parity){\n                                ${P("vLineDistanceAltResetSecondDist")}.x = ${P("vLineDistance")}.y;\n                                ${P("vPointPrec")} = ${P("vConstantPrec")};\n                                ${P("vPointNext")} = ${P("vConstantCurr")};\n                                ${t.cpuPattern?`\n                                    ${P("vLineDistanceLeftRight")}.x = lineDistance.x;\n                                    ${P("vLineDistanceLeftRight")}.y = lineDistance.y;\n                                    ${P("vLineDistanceLeftRight")}.z = lineDistance.y;\n                                    ${P("vLineDistanceLeftRight")}.w = (lineDistance.y + length(${P("vConstantNext")}.xy - ${P("vConstantCurr")}.xy));\n                                    `:`\n                                    ${P("vLineDistance")}.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;\n                                    ${P("vLineDistance")}.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                    ${P("vLineDistanceLeftRight")}.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;\n                                    ${P("vLineDistanceLeftRight")}.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                    ${P("vLineDistanceLeftRight")}.z = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;\n                                    ${P("vLineDistanceLeftRight")}.w = (lineDistance.y + length(followingPos.xyz - position_.xyz)) * modelMatrixScaleX * worldSizeToPixelNext;\n                                    `}\n                            } else {\n                                ${P("vLineDistanceAltResetSecondDist")}.x = ${P("vLineDistance")}.x;\n                                ${P("vPointPrec")} = ${P("vConstantCurr")};\n                                ${P("vPointNext")} = ${P("vConstantNext")};\n                                ${t.cpuPattern?`\n                                    ${P("vLineDistanceLeftRight")}.x = (lineDistance.x - length(${P("vConstantCurr")}.xy - ${P("vConstantPrec")}.xy));\n                                    ${P("vLineDistanceLeftRight")}.y = lineDistance.x;\n                                    ${P("vLineDistanceLeftRight")}.z = lineDistance.x;\n                                    ${P("vLineDistanceLeftRight")}.w = lineDistance.y;\n                                    `:`\n                                    ${P("vLineDistance")}.x = lineDistance.x * modelMatrixScaleX* worldSizeToPixelCurr;\n                                    ${P("vLineDistance")}.y = lineDistance.y * modelMatrixScaleX* worldSizeToPixelNext;\n                                    ${P("vLineDistanceLeftRight")}.x = (lineDistance.x - length(position_.xyz - previousPos.xyz)) * modelMatrixScaleX * worldSizeToPixelPrec;\n                                    ${P("vLineDistanceLeftRight")}.y = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;\n                                    ${P("vLineDistanceLeftRight")}.z = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;\n                                    ${P("vLineDistanceLeftRight")}.w = lineDistance.y * modelMatrixScaleX * worldSizeToPixelNext;\n                                    `}\n                                if (${d("lineDistance.x - lineDistance.y")}) {\n                                    ${t.cpuPattern?`\n                                        ${P("vLineDistanceLeftRight")}.w += length(${P("vConstantNext")}.xy -  ${P("vConstantCurr")}.xy );\n                                        `:`\n                                        ${P("vLineDistanceLeftRight")}.w += length(followingPos.xyz -  position_.xyz )* modelMatrixScaleX * worldSizeToPixelNext;\n                                        `}\n                                    ${P("vLineDistanceAltResetSecondDist")}.y = 1.0;\n                                }\n                            }\n                            `}\n                    `),"round"===t.linecap&&(o=`\n                        ${o}\n                        ${C({varyingName:"infosCenterCap",varyingType:"v4"})}\n                        ${C({varyingName:"centerLeftRight",varyingType:"v4"})}\n                    `,b=`\n                        ${b}                \n                        ${y("following")}  = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ ${g("pixelSize")};\n                        ${y("previous")}  = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / ${g("pixelSize")};\n                        ${y("current")}  = (mvpPositionR.xy / mvpPositionR.w + 1.0) / ${g("pixelSize")};\n                        ${y("computedCurrent")}  = (auxVec.xy + 1.0) / ${g("pixelSize")};\n                        if (!bPrecCurr) {\n                            ${P("centerLeftRight")}.x = current.x;\n                            ${P("centerLeftRight")}.y = current.y;\n                            ${P("infosCenterCap")}.z = current.x;\n                            ${P("infosCenterCap")}.w = current.y;\n                            ${P("centerLeftRight")}.z = following.x;\n                            ${P("centerLeftRight")}.w = following.y;\n                            ${P("infosCenterCap")}.x = -${p("getHalfWidth","f",[])};\n                            ${P("infosCenterCap")}.y = 1.0;\n                        } else if (!bCurrNext) {\n                            ${P("centerLeftRight")}.x = previous.x;\n                            ${P("centerLeftRight")}.y = previous.y;\n                            ${P("infosCenterCap")}.z = previous.x;\n                            ${P("infosCenterCap")}.w = previous.y;\n                            ${P("centerLeftRight")}.z = current.x;\n                            ${P("centerLeftRight")}.w = current.y;\n                            ${P("infosCenterCap")}.x = length(current.xy-previous.xy) + ${p("getHalfWidth","f",[])};\n                            ${P("infosCenterCap")}.y = 1.0;\n                        } else {\n                            ${P("centerLeftRight")}.x = previous.x;\n                            ${P("centerLeftRight")}.y = previous.y;\n                            ${P("infosCenterCap")}.z = current.x;\n                            ${P("infosCenterCap")}.w = current.y;\n                            ${P("centerLeftRight")}.z = following.x;\n                            ${P("centerLeftRight")}.w = following.y;\n                            if (parity) {\n                                ${P("infosCenterCap")}.x = dot(computedCurrent.xy - current.xy,  ${h("following.xy - current.xy")});\n                            } else {\n                                ${P("infosCenterCap")}.x = length(current.xy - previous.xy) + dot(computedCurrent.xy - current.xy, ${h("current.xy - previous.xy")});\n                            }\n                            ${P("infosCenterCap")}.y = 0.0;\n                        }\n                    `),"round"===t.linejoin&&(o=`\n                        ${o}\n                        ${C({varyingName:"centerJoin",varyingType:"v4"})}\n                        ${C({varyingName:"centerRightJoin",varyingType:"v4"})}\n                        ${C({varyingName:"centerLeftJoin",varyingType:"v4"})}\n                    `,b=`\n                        ${b}\n                        ${y("followingJoin")}  = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ ${g("pixelSize")};\n                        ${y("previousJoin")}  = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / ${g("pixelSize")};\n                        ${y("currentJoin")}  = (mvpPositionR.xy / mvpPositionR.w + 1.0) / ${g("pixelSize")};\n\n                        ${P("centerLeftJoin")} = ${T()}(0.0);\n                        ${P("centerRightJoin")} = ${T()}(0.0);\n                        ${P("centerJoin")} = ${T()}(0.0);\n                        if (!bPrecCurr) {\n                            ${P("centerLeftJoin")}.x = followingJoin.x;\n                            ${P("centerLeftJoin")}.y = followingJoin.y;\n                            ${P("centerJoin")}.x = currentJoin.x;\n                            ${P("centerJoin")}.y = currentJoin.y;\n                            ${P("centerRightJoin")}.x = followingJoin.x;\n                            ${P("centerRightJoin")}.y = followingJoin.y;\n                            ${P("centerRightJoin")}.z = dirCurrNext.x;\n                            ${P("centerRightJoin")}.w = dirCurrNext.y;\n                        } else if (!bCurrNext) {\n                            ${P("centerLeftJoin")}.x = previousJoin.x;\n                            ${P("centerLeftJoin")}.y = previousJoin.y;\n                            ${P("centerJoin")}.x = currentJoin.x;\n                            ${P("centerJoin")}.y = currentJoin.y;\n                            ${P("centerRightJoin")}.x = previousJoin.x;\n                            ${P("centerRightJoin")}.y = previousJoin.y;\n                            ${P("centerLeftJoin")}.z = -dirPrecCurr.x;\n                            ${P("centerLeftJoin")}.w = -dirPrecCurr.y;\n                        } else {\n                            if (parity) {\n                                ${P("centerLeftJoin")}.x = currentJoin.x;\n                                ${P("centerLeftJoin")}.y = currentJoin.y;\n                                ${P("centerJoin")}.x = currentJoin.x;\n                                ${P("centerJoin")}.y = currentJoin.y;\n                                ${P("centerRightJoin")}.x = followingJoin.x;\n                                ${P("centerRightJoin")}.y = followingJoin.y;\n                                ${P("centerLeftJoin")}.z = -dirCurrNext.x;\n                                ${P("centerLeftJoin")}.w = -dirCurrNext.y;\n                                ${P("centerRightJoin")}.z = dirCurrNext.x;\n                                ${P("centerRightJoin")}.w = dirCurrNext.y;\n                                ${P("centerJoin")}.z = -dir.x;\n                                ${P("centerJoin")}.w = -dir.y;\n                            } else {\n                                ${P("centerLeftJoin")}.x = previousJoin.x;\n                                ${P("centerLeftJoin")}.y = previousJoin.y;\n                                ${P("centerJoin")}.x = currentJoin.x;\n                                ${P("centerJoin")}.y = currentJoin.y;\n                                ${P("centerRightJoin")}.x = currentJoin.x;\n                                ${P("centerRightJoin")}.y = currentJoin.y;\n                                ${P("centerLeftJoin")}.z = -dirPrecCurr.x;\n                                ${P("centerLeftJoin")}.w = -dirPrecCurr.y;\n                                ${P("centerRightJoin")}.z = dirPrecCurr.x;\n                                ${P("centerRightJoin")}.w = dirPrecCurr.y;\n                                ${P("centerJoin")}.z = -dir.x;\n                                ${P("centerJoin")}.w = -dir.y;\n                            }\n                        }\n                    `),b=`\n                    ${b}\n                    ${N("position")} = ${T()}(pos.x, pos.y * ${g("pixelSize")}.y/${g("pixelSize")}.x,finalZ, pmvPosition.w);\n                `)),[o,b]}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentCoreShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),l=n=>r.getVarying(n,r.ShaderStages.in),u=(n=null)=>{var e={name:n};return o.vec3(e)};return{PDSFX_start_fragment:function(n){var e=`\n            INTERNAL_computedvar_clipPosition = ${l("INTERNAL_varying_clipPosition")};\n            INTERNAL_computedvar_viewPosition = ${l("INTERNAL_varying_viewPosition")};\n            INTERNAL_computedvar_viewNormal = ${l("INTERNAL_varying_viewNormal")};\n            INTERNAL_computedvar_viewTangent = ${l("INTERNAL_varying_viewTangent")};\n            INTERNAL_computedvar_viewBinormal = ${l("INTERNAL_varying_viewBinormal")};\n            `;const t=r._context.__varyings__;for(var a in t)if(a.startsWith("INTERNAL_PDSFX_CUSTOM_VARYING")){var o=a.replace("INTERNAL_PDSFX_CUSTOM_VARYING",""),i=t[a];e=i.size>0?`\n                                ${e}\n                                for (int i = 0; i < ${i.size}; i++) {\n                                    ${o}[i] = ${l(a)}[i];\n                                }\n                            `:`\n                                ${e}\n                                ${o} = ${l(a)};\n                            `}return e},PDSFX_map_fragment:function(n){if(!n.useUV)return"";var e=`_uvToUse = ${l("vUv")};`;return(n.specGloss||n.dspbr)&&(e=`\n                    ${e}\n                    _uvToUse2 = ${l("vUv2")};\n                    _uvToUse3 = ${l("vUv3")};\n                `),e},PDSFX_mapping_fragment:function(n){return n.useUV&&(n.mappingType>-1||n.lightMapMappingType>-1)?`INTERNAL_backup_mappingUVTransformation = ${e="mappingUVTransformation",r={uniformName:e},t.getUniform(r)};`:"";var e,r},PDSFX_discard_fragment:function(n){return n.pdsfxUseDiscard?`\n                ${((n=null)=>{var e={name:n};return o.bool(e)})("isDiscarded")}  = ${s("ComputeDiscard","b",[])};\n                if (isDiscarded) discard;\n            `:""},PDSFX_viewNormal_fragment:function(n){return`\n                ${u("INTERNAL_computed_viewNormal")}  = ${s("ComputeViewNormal","v3",[])};\n            `},PDSFX_viewPosition_fragment:function(n){return`\n                ${u("INTERNAL_computed_viewPosition")}  = -${s("ComputeViewPosition","v3",[])};\n            `},PDSFX_end_fragment:function(n){var e="";return n.PDSFX&&(e=`\n                    ${e}\n                    ${s("ProcessFinalColor",null,[(n=>i.parameterRefV4(n))("gl_FragColor")])};\n                `),e}}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexCoreShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=(n,e,t)=>a.FunctionHandler.callFunction(n,e,t),l=n=>{var e={uniformName:n};return t.getUniform(e)},u=n=>r.getVarying(n,r.ShaderStages.out),m=n=>r.getBuiltin(n,r.ShaderStages.out),$=(n=null)=>{var e={name:n};return o.vec2(e)},c=(n=null)=>{var e={name:n};return o.vec3(e)},p=(n=null)=>{var e={name:n};return o.vec4(e)};return{PDSFX_header_vertex:function(n){var e="";n.cpuPattern&&!n.WebGPU&&(e=`\n                    ${e}\n                    #define PDSFX_PIXEL_LINEDISTANCE\n                `),e=`\n                ${e}\n                // Backup variables for all overridable entry points\n                ${c("INTERNAL_backup_position")} ;\n                ${c("INTERNAL_backup_normal")} ;\n                ${c("INTERNAL_backup_tangent")} ;\n                ${c("INTERNAL_backup_binormal")} ;\n                ${c("INTERNAL_backup_previousPos")} ;\n                ${c("INTERNAL_backup_followingPos")} ;\n                ${p("INTERNAL_backup_uv")} ;\n                ${p("INTERNAL_backup_uv2")} ;\n                ${p("INTERNAL_backup_uv3")} ;\n                ${$("_hack_PDSFX_UV1_FOR_CITY_")} ;\n                ${$("_hack_PDSFX_UV2_FOR_CITY_")} ;\n            `;const t=r._context.__attributes__;for(var a in t)if(a.startsWith("INTERNAL_PDSFX_CUSTOM_ATTRIBUTE")){var i=a.replace("INTERNAL_PDSFX_CUSTOM_ATTRIBUTE",""),s=t[a];e=`\n                        ${e}\n                        ${o.declareVariable({name:i,type:s.type})};\n                    `}return e},PDSFX_start_vertex:function(n){let t="";if(n.PDSFX){const u=r._context.__attributes__;for(var a in u){if(a.startsWith("INTERNAL_PDSFX_CUSTOM_ATTRIBUTE"))t=`\n                            ${t}\n                            ${a.replace("INTERNAL_PDSFX_CUSTOM_ATTRIBUTE","")} = ${e.getAttribute(a)};\n                        `}t=`\n                    ${t}\n                    INTERNAL_backup_position = position_;\n                    INTERNAL_backup_normal = normal;\n                    INTERNAL_backup_uv = uv;\n                    INTERNAL_backup_uv2 = uv2;\n                    INTERNAL_backup_uv3 = uv3;\n                    INTERNAL_backup_tangent = tangent;\n                    INTERNAL_backup_binormal = binormal;\n                    ${s("ComputeCommonValues",null,[])};\n                    position_ = ${s("ComputeObjectPosition","v3",[])};\n                    normal = ${s("ComputeObjectNormal","v3",[])};\n                    ${n.dashedLine?`\n                        ${s("ProcessLineDistance",null,[(n=>i.parameterRefV2(n))("lineDistance")])};\n                        `:""}\n                    ${n.wideLine?`\n                        INTERNAL_backup_followingPos = followingPos;\n                        INTERNAL_backup_previousPos = previousPos;\n                        previousPos = ${s("ComputeObjectPreviousPosition","v3",[])}; \n                        followingPos = ${s("ComputeObjectFollowingPosition","v3",[])};\n                        `:""}\n                    uv = ${s("ComputeObjectTexCoord0","v4",[])};\n\t\t\t\t\t_hack_PDSFX_UV1_FOR_CITY_ = uv.xy;\n                    uv2 = ${s("ComputeObjectTexCoord1","v4",[])};\n\t\t\t\t\t_hack_PDSFX_UV2_FOR_CITY_ = uv2.xy;\n                    uv3 = ${s("ComputeObjectTexCoord2","v4",[])};\n                    ${n.needTangentBinormal?`\n                        tangent = ${s("ComputeObjectTangent","v3",[])}; \n                        binormal = ${s("ComputeObjectBinormal","v3",[])};\n                        `:""}             \n                    ${o.declareVariable({name:"_viewTangentSpace",type:"TangentSpace",custom:!0})};\n                    ${n.useUV&&(n.mappingType>-1||n.lightMapMappingType>-1)?`INTERNAL_backup_mappingUVTransformation = ${l("mappingUVTransformation")};`:""}\n                `}return t},PDSFX_start_particle_vertex:function(n){return n.PDSFX?`\n                INTERNAL_backup_size = ${l("size")};\n                INTERNAL_backup_scale = ${l("scale")};\n                INTERNAL_backup_sizeForGLPointSize = INTERNAL_backup_size;\n            `:""},PDSFX_point_size_vertex:function(n){if(n.PDSFX)return`gl_PointSize = ${s("ComputePointSize","f",[])};`;var e="";return e=n.sizeAttenuation?`\n                    ${e}\n                    gl_PointSize = ${l("size")} * ( ${l("scale")} / length( mvPosition.xyz ) );\n                `:`\n                    ${e}\n                    gl_PointSize = ${l("size")};\n                `,n.primitiveHighlight&&n.mobileHL&&(e=`\n                    ${e}\n                    gl_PointSize += 2.0;\n                `),e},PDSFX_end_vertex:function(n){let e="";if(n.PDSFX){e=`\n                    ${e}\n                    ${s("ProcessClipSpacePosition",null,[(n=>i.parameterRefV4(n))(m("position"))])};\n                    ${s("ComputeVaryingValues",null,[])};\n                    ${u("INTERNAL_varying_clipPosition")} = ${m("position")};\n                    ${u("INTERNAL_varying_viewPosition")}  = _viewTangentSpace.Position;\n                    ${u("INTERNAL_varying_viewNormal")}  = _viewTangentSpace.Normal;\n                    ${u("INTERNAL_varying_viewTangent")}  = _viewTangentSpace.Tangent;\n                    ${u("INTERNAL_varying_viewBinormal")}  = _viewTangentSpace.Binormal;\n                `;const n=r._context.__varyings__;for(var t in n)if(t.startsWith("INTERNAL_PDSFX_CUSTOM_VARYING")){var a=t.replace("INTERNAL_PDSFX_CUSTOM_VARYING",""),o=n[t];e=o.size>0?`\n                                ${e}\n                                for (int i = 0; i < ${o.size}; i++) {\n                                    ${u(t)}[i] = ${a}[i];\n                                }\n                            `:`\n                                ${e}\n                                ${u(t)} = ${a};\n                            `}}return e}}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentGetterShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i){"use strict";const s=o.ParameterUtils,l=(n,e,t)=>o.FunctionHandler.declareFunction(n,e,t),u=(n=null)=>{var e={name:n};return i.vec3(e)},m=(n=null)=>{var e={name:n};return i.vec4(e)},$=e.__backUpVariablesFragment;return{PDSFX_getters_fragment:function(n){let e="";for(var t=0;t<$.length;t++){var r=$[t];e=`\n                    ${e}\n                    ${i.declareVariable({name:r.name,type:r.type})};\n                    ${r.getterName?`\n                        ${l(r.getterName,r.type,[])} {\n                            return ${r.name};\n                        }`:""}\n                `}return`\n            ${l("vGetFragCoord","v4",[])}{\n                return gl_FragCoord;\n            }\n            \n            ${l("vSetFragDepth",null,[(n=>s.parameterF(n))("iDepth")])}{\n                ${2===n.WebGLVersion?"gl_FragDepth = iDepth;":""}\n                ${n.extFragDepth?"gl_FragDepthEXT = iDepth;":""}\n            }\n            \n            ${l("vIsFrontFacing","b",[])}{\n                return gl_FrontFacing;\n            }\n            \n            ${l("vGetPointCoord","v2",[])}{\n                return gl_PointCoord;\n            }\n            \n            ${u("INTERNAL_computedvar_viewPosition")};\n            ${l("vGetViewPosition","v3",[])}{\n                return INTERNAL_computedvar_viewPosition;\n            }\n\n            ${u("INTERNAL_computedvar_viewNormal")};\n            ${l("vGetViewNormal","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewNormal);\n            }\n            \n            ${u("INTERNAL_computedvar_viewTangent")};\n            ${l("vGetViewTangent","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewTangent);\n            }\n            \n            ${u("INTERNAL_computedvar_viewBinormal")};\n            ${l("vGetViewBinormal","v3",[])}{\n                return normalize(INTERNAL_computedvar_viewBinormal);\n            }\n            \n\n            ${m("_uvToUse")} ;\n            ${l("vGetTexCoord0","v4",[])}{\n                return _uvToUse;\n            }\n            \n            ${m("_uvToUse2")} ;\n            ${l("vGetTexCoord1","v4",[])}{\n                return _uvToUse2;\n            }\n\n            ${m("_uvToUse3")} ;\n            ${l("vGetTexCoord2","v4",[])}{\n                return _uvToUse3;\n            }\n            \n            ${m("INTERNAL_computedvar_clipPosition")};\n            ${l("vGetClipSpacePosition","v4",[])}{\n                return INTERNAL_computedvar_clipPosition;\n            }\n\n            ${e}\n            `}}}),define("DS/ShaderBuilders/PBRUtils/PBRFragmentEquationsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r){"use strict";const a=t.ParameterUtils,o=t.FunctionHandler,i=()=>r.dereference(),s=(n,e,t=!1)=>a.parameter(n,e,t),l=n=>a.parameterF(n),u=n=>a.parameterV2(n),m=n=>a.parameterV3(n),$=n=>a.parameterInOutV3(n),c=n=>a.parameterV4(n),p=n=>a.parameterT2(n),d=n=>a.parameterTC(n),f=(n,e,t)=>o.declareFunction(n,e,t),h=(n,e,t)=>o.callFunction(n,e,t),g=(n=null)=>{var e={name:n};return r.int(e)},v=(n=null)=>{var e={name:n};return r.float(e)},S=(n=null)=>{var e={name:n};return r.vec2(e)},x=(n=null,e=0)=>{var t={name:n,size:e};return r.vec3(t)},y=(n=null,e=0)=>{var t={name:n,size:e};return r.vec4(t)},_=(n=null)=>{var e={name:n};return r.mat3(e)},T=n=>`max(${n}, 0.0)`,D=n=>h("saturate","v2",[u(n)]),C=n=>h("vMax","f",[m(n)]),P=n=>h("pow2","f",[l(n)]),N=()=>[$("diffuse"),$("specular"),m("L")],M=(n,e)=>h("DistributionGGX","f",[l(n),l(e)]),b=(n,e,t)=>h("GGXVisibility","f",[l(n),l(e),l(t)]),w=(n,e,t)=>h("GeometricSchlick","f",[l(n),l(e),l(t)]),U=(n,e,t)=>h("FresnelSchlick","v3",[m(n),m(e),l(t)]),z=n=>h("DiffuseLambertBRDF","v3",[m(n)]),V=(n,e,t,r)=>h("SpecularBRDF","f",[l(n),l(e),l(t),l(r)]),F=(n,e,t,r,a,o,i,s,u,$)=>h("SpecularAnisoBRDF","f",[l(n),l(e),l(t),l(r),l(a),m(o),m(i),m(s),m(u),l($)]),R=(n,e,t,r)=>h("SpecGlossEnergyConservationTerm","f",[l(n),l(e),m(t),m(r)]);let A,I,L,B,k,E,O;{let n=function(n){return`\n            ${f("SheenModel",null,N())} {           \n                ${x("N")} = surfaceData.viewNormal;\n                ${x("V")} = surfaceData.view;\n                ${x("H")} = normalize(L+V);\n                ${v("NoH")}  = max(dot(N,H), 0.0);\n                ${v("NoL")}  = max(dot(N,L), 0.0);\n                ${v("NoV")}  = max(dot(N,V), 0.0);\n                ${n.dspbrWithSheenColorRoughness?`\n                    ${x("sheenColor")}  = materialData.sheen * materialData.sheenColor * ${h("SheenDistribution","f",[l("NoH"),l("materialData.sheenRoughness")])}* SheenVisGeometricSchlick(NoL,NoV);\n                    ${v("blending")}  = 1.0 - materialData.sheenEnergyConservationConstant;\n                    ${i()}specular *= blending;\n                    ${i()}diffuse *= blending;\n                    ${i()}specular += sheenColor;\n                    `:`\t\t\t\t\n                    ${v("sheen")}  = ${h("SheenDistribution","f",[l("NoH"),l("materialData.sheen")])} * SheenVisGeometricSchlick(NoL,NoV);\n                    ${v("blending")}  = 1.0 - ${(n=>h("pow5","f",[l(n)]))("1.0-materialData.sheen")};\n                    ${i()}diffuse *= PI * sheen * blending + (1.0 - blending);\n                    `}\n            }\n        `},e="\n        ";A=function(t){return t.sheen?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${n.useTransmittance?`\n                    ${n.depthBasedTransmittance?`\n                        ${n.useMapTransmittance?`\n                            ${f("getDepthValue","f",[p("iShadowMap"),u("coord")])} {\n                                ${y("fetchedValue")} = ${o.sample2DTexture("iShadowMap","coord")};\n                                ${n.useESMTransmittance?`\n                                    ${v("unpacked")}  = ${h("unpackDepthESM","f",[c("fetchedValue")])};\n                                    return 2.0 * ONEOVER80*log(unpacked) - 1.0;\n                                    `:`\n                                    ${v("unpacked")} = ${h("unpackRGBA","f",[c("fetchedValue")])};\n                                    return 2.0*unpacked - 1.0;\n                                    `}  \n                            }\n\n                            ${f("multiSampleTransmittance","v3",[c("shadowMapCoord"),u("shadowNearFar"),u("iShadowMapSize"),p("iShadowMap"),s("b","ortho")])} {\n                                ${x("depthMapCoord")}  = shadowMapCoord.xyz/shadowMapCoord.w;\n                                ${S("currentCoord")} ;\n                                ${v("currentDepth")}  = ${h("clipToEye","f",[l("2.0*depthMapCoord.z-1.0"),u("shadowNearFar"),s("b","ortho")])};\n                                ${v("depth")}  = ${h("getDepthValue","f",[p("iShadowMap"),u("depthMapCoord.xy")])};\n                                ${v("fetchedDepth")}  = ${h("clipToEye","f",[l("depth"),u("shadowNearFar"),s("b","ortho")])};\n                                ${v("s")}  = max( currentDepth - fetchedDepth,0.0);\n                                ${S("multiplier")}  = ${D("2.0 / iShadowMapSize")};\n                                for (${g("i")} = 0; i < TRANS_SAMPLE; i++) {\n                                    ${S("offset")}  =  multiplier* poisson25[i];\n                                    currentCoord = ${D("depthMapCoord.xy + offset")};\n                                    depth = ${h("getDepthValue","f",[p("iShadowMap"),u("currentCoord.xy")])};\n                                    s += max( currentDepth - ${h("clipToEye","f",[l("depth"),u("shadowNearFar"),s("b","ortho")])},0.0);\n                                }\n                                return ${h("GetTransmittance","v3",[l(`s / ${v()}(TRANS_SAMPLE + 1)`)])};\n                            }\n                            `:""}\n\n                        ${n.useCubeTransmittance?`\n                            ${f("getCubeDepthValue","f",[d("shadowCubeMap"),m("coord")])} {\n                                ${y("fetchedValue")} = ${o.sampleCubeTexture("shadowCubeMap","coord")};\n                                ${n.useESMTransmittance?`\n                                    ${v("unpacked")}  = ${h("unpackDepthESM","f",[c("fetchedValue")])};\n                                    return 2.0 * ONEOVER80*log(unpacked) - 1.0;\n                                    `:`\n                                    ${v("unpacked")}  = ${h("unpackRGBA","f",[c("fetchedValue")])};\n                                    return 2.0* unpacked - 1.0;\n                                    `}   \n                            }\n\n                            ${f("multiSampleCubeTransmittance","v3",[m("worldPos"),m("lightPosition"),u("shadowNearFar"),l("shadowCubeSize"),d("shadowCubeMap"),s("b","ortho")])} {\n                                ${x("pointVector")}  = worldPos.xyz - lightPosition.xyz;\n\n                                ${x("absVector")}  = abs(pointVector);\n                                ${v("localZComp")}  = max(absVector.x,max(absVector.y,absVector.z));\n                                ${v("normZComp")}  = (shadowNearFar.y + shadowNearFar.x) / (shadowNearFar.y - shadowNearFar.x) - (2.0 * shadowNearFar.y * shadowNearFar.x) / (shadowNearFar.y - shadowNearFar.x) / localZComp;\n                                normZComp = (normZComp + 1.0) * 0.5;\n                                ${x("cubeMapCoord")}  = normalize( pointVector );\n\n                                ${v("currentDepth")}  = length(pointVector);\n                                ${v("depth")}  = ${h("getCubeDepthValue","f",[d("shadowCubeMap"),m("cubeMapCoord")])};\n                                ${v("fetchedDepth")}  = ${h("clipToEye","f",[l("depth"),u("shadowNearFar"),s("b","ortho")])};\n                                ${v("s")}  = max( currentDepth - fetchedDepth,0.0);\n\n                                ${v("pixelSize")}  = 4.0 / shadowCubeSize;\n                                ${x("right")}  = ${h("getGeomT","v3",[m("cubeMapCoord.xyz")])} * pixelSize;\n                                ${x("up")}  = ${h("getGeomB","v3",[m("cubeMapCoord.xyz"),m("right")])} * pixelSize;\n                                ${x("currentCoord")} ;\n\n                                for (${g("i")} = 0; i < TRANS_SAMPLE; i++) {\n                                    ${S("offset")}  =  poisson25[i];\t\t\t\n                                    currentCoord = normalize(cubeMapCoord + offset.x * right + offset.y * up);\n                                    depth = ${h("getCubeDepthValue","f",[d("shadowCubeMap"),m("currentCoord")])};\n                                    s += max( currentDepth - ${h("clipToEye","f",[l("depth"),u("shadowNearFar"),s("b","ortho")])},0.0);\n                                }\n                                return ${h("GetTransmittance","v3",[l(`s / ${v()}(TRANS_SAMPLE + 1)`)])};\n                            }\n                            `:""}\n                        `:""}\n                    `:""} \n            `},e="\n        ";I=function(t){return t.subsurface?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${f("ClearCoatModel",null,N())} {          \n                    ${x("V")} = surfaceData.view;\n                    ${x("N")} = surfaceData.clearCoatNormal;\n                    ${v("r")} = materialData.clearCoatRoughness;\n                    ${x("H")}  = normalize(L+V);\n                    ${v("NoH")}  = ${T("dot(N,H)")};\n                    ${v("NoV")}  = ${T("dot(N,V)")};\n                    ${v("NoL")}  = ${T("dot(N,L)")};\n                    ${v("VoH")}  = ${T("dot(V,H)")};\n                    ${v("distrib")}  = ${M("r","NoH")};\n\n                    ${v("geomVis")}  = ${b("r","NoV","NoL")};\n                    ${x("fresnel")}  = ${U("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","VoH")};\n\n                    ${n.dspbr?`\n                        ${x("fresnelNoL")}  = ${U("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NoL")};\n                        ${x("fresnelNoV")}  = ${U("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NoV")};\n                        ${v("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${C("max(fresnelNoL,fresnelNoV)")};\n                        `:`\n                        ${v("fresnelEnergy")} = ${R("NoL","NoV","materialData.clearCoatSR0Color","materialData.clearCoatSR90Color")};\n                        `}\n                    ${i()}diffuse *= fresnelEnergy;\n                    ${i()}specular *= fresnelEnergy;\n\n                    ${i()}specular += materialData.clearCoat * distrib * fresnel * geomVis;\n                }\n            `},e="\n        ";L=function(t){return t.clearCoat?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${f("SpecGlossFlakesModel",null,N())} {           \n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\n                    ${x("H")} = normalize(L+V);\n                    ${x("vector3Zero")} = ${x()}(0.0);\n                    ${v("VoH")}  = ${T("dot(V,H)")};\n                    {\n                        ${v("NoH")}  = ${T("dot(metalFlakes.flakesNormal,H)")};\n                        ${v("NoV")}  = ${T("dot(metalFlakes.flakesNormal,V)")};\n                        ${v("NoL")}  = ${T("dot(metalFlakes.flakesNormal,L)")};\n                        ${v("distrib")}  = ${M("metalFlakes.flakesRoughness","NoH")};\n                        ${v("geomVis")}  = ${b("metalFlakes.flakesRoughness","NoV","NoL")};\n                        ${x("fresnel")}  = ${U("metalFlakes.flakesSR0Color","vector3Zero","VoH")};\n                        ${v("fresnelEnergy")}  = ${R("NoL","NoV","metalFlakes.flakesSR0Color","vector3Zero")};\n                        ${i()}diffuse *= fresnelEnergy;\n                        ${i()}specular *= fresnelEnergy;\n                        ${i()}specular += distrib * fresnel * geomVis;\n                    }\n                    {\n                        ${v("NoH")}  = ${T("dot(metal.flakesNormal,H)")};\n                        ${v("NoV")}  = ${T("dot(metal.flakesNormal,V)")};\n                        ${v("NoL")}  = ${T("dot(metal.flakesNormal,L)")};\n                        ${v("distrib")}  = ${M("metal.flakesRoughness","NoH")};\n                        ${v("geomVis")}  = ${b("metal.flakesRoughness","NoV","NoL")};\n                        ${x("fresnel")}  = ${U("metal.flakesSR0Color","vector3Zero","VoH")};\n                        ${v("fresnelEnergy")}  = ${R("NoL","NoV","metal.flakesSR0Color","vector3Zero")};\n                        ${i()}diffuse *= fresnelEnergy;\n                        ${i()}specular *= fresnelEnergy;\n                        ${i()}specular += distrib * fresnel * geomVis;\n                    }\n                    ${n.pearlFlakesActivated?`\n                        {\n                            ${v("NoH")}  = ${T("dot(pearlFlakes.flakesNormal,H)")};\n                            ${v("NoV")}  = ${T("dot(pearlFlakes.flakesNormal,V)")};\n                            ${v("NoL")}  = ${T("dot(pearlFlakes.flakesNormal,L)")};\n                            ${v("distrib")}  = ${M("pearlFlakes.flakesRoughness","NoH")};\n                            ${v("geomVis")}  = ${b("pearlFlakes.flakesRoughness","NoV","NoL")};\n                            ${x("fresnel")}  = ${U("pearlFlakes.flakesSR0Color","vector3Zero","VoH")};\n                            ${v("fresnelEnergy")}  = ${R("NoL","NoV","pearlFlakes.flakesSR0Color","vector3Zero")};\n                            ${i()}diffuse *= fresnelEnergy;\n                            ${i()}specular *= fresnelEnergy;\n                            ${i()}specular += distrib * fresnel * geomVis;\n                        }\n                        `:""}\n                }\n            `},e="\n        ";B=function(t){return t.specGlossFlakes?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${f("stochasticFlakesPattern","v3",[m("V"),m("L"),m("N"),l("limit")])} {\n                    ${S("c")} =  ${h("contributingStochasticFlakes","v2",[m("V"),m("L"),m("N"),l("limit")])};\n                    ${v("d")} = c.x;\n                    ${n.dspbrWithFlipFlopColor?`return ${h("computeFlakesTint","v3",[l("c.y")])}* d;`:`return ${h("computeFlakesTint","v3",[])} * d;`}\n                }\n\n                ${f("stochasticFlakesBRDF","v3",[m("V"),m("L"),m("N"),l("VoH"),l("NoL"),l("NoV")])}{\n                    ${v("g")} = ${w("flakesData.flakesRoughness","NoL","NoV")};\n                    ${x("pattern")}  = ${h("stochasticFlakesPattern","v3",[m("V"),m("L"),m("N"),l("flakesData.flakesCosConeAngle")])};\n                    return VoH * g * pattern/ max(NoL*NoV * flakesData.flakesConeSolidAngle,1e-6) ;\n                }\n\n                ${f("closeFlakesPattern","f",[m("L"),l("limit")])}{\n                    return step(0.0, dot(flakesData.closeupFlakesReflect, L) - limit);\n                }\n\n                ${f("closeFlakesBRDF","f",[m("L"),l("NoL")])}{\n                    ${v("pattern")}  = ${h("closeFlakesPattern","f",[m("L"),l("flakesData.flakesCosConeAngle")])};\n                    return  pattern / max(flakesData.flakesConeSolidAngle  * NoL, 1e-6);\n                }\n\n                ${f("DSPBRFlakesModel",null,N())}{\t           \n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\n                    ${x("H")}  = normalize(V+L);\n                    ${v("VoH")}  = dot(V,H);\n                    ${v("NoL")}  = ${T("dot(N,L)")};\n                    ${v("NoV")}  = ${T("dot(N,V)")};\n                    ${v("NoH")}  = ${T("dot(N,H)")};\n\n                    ${x("res")}  = flakesData.smoothFlakesColor * ${V("flakesData.flakesRoughness","NoV","NoL","NoH")};\n                    ${n.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            res += flakesData.stochasticWeight * ${h("stochasticFlakesBRDF","v3",[m("V"),m("L"),m("N"),l("VoH"),l("NoL"),l("NoV")])};\n                        }\n                        `:""}\n                    ${n.dspbrFlakesOneLayer?"":`               \n                        if (flakesData.closeupWeight > 0.0) {\n                            res += flakesData.closeupFlakesColor * ${h("closeFlakesBRDF","f",[m("L"),l("NoL")])};\n                        }\n                        `}\n                    ${i()}diffuse *= flakesData.baseWeight;\n                    ${i()}specular *= flakesData.baseWeight;\n                    ${i()}specular += res;\n                }\n            `},e="\n        ";k=function(t){return t.dspbrFlakes?[n(t),e]:["",""]}}{let n=function(n){return`\n                ${x("Lt")}  = L - 2.0 * dot(L,N) * N;\n                ${v("NoLt")}  = ${T("dot(N, Lt)")};\n                ${x("brdf")}  = ${z("color")};\n                ${n.specgloss?`\n                    ${v("NoV")}  = ${T("dot(N,V)")};\n                    ${v("fTrans")}  = ${R("NoLt","NoV","materialData.sr0Color","materialData.sr90Color")};\n                    `:`${v("fTrans")} = materialData.diffuseEnergyConservationConstant;`}\n            `},e=function(n){return`\n                    ${x("Lt")}  = L - 2.0 * dot(L,N) * N;\n                    ${v("NoLt")}  = ${T("dot(N,Lt)")};\n                    ${v("NoV")} = ${T("dot(N,V)")};\n                    ${n.thinWalled?`\n                        ${x("Ht")}  = normalize(Lt+V);\n                        ${v("NoHt")}  = ${T("dot(N,Ht)")};\n                        ${v("VoHt")}  = ${T("dot(V,Ht)")};\n                        ${n.anisotropy?`\n                            ${v("rX")}  = materialData.roughness;\n                            ${v("rY")}  = rX * (1.0 - materialData.anisotropy);\n                            ${x("brdf")} = color * ${F("rX","rY","NoV","NoLt","NoHt","N","Ht","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                            `:`${x("brdf")} = color * ${V("materialData.roughness","NoV","NoLt","NoHt")};`}                    \n                        `:`\n                        ${x("Ht")}  = normalize(Lt * materialData.ior +V);\n                        ${v("NoHt")}  = ${T("dot(N,Ht)")};\n                        ${v("VoHt")}  = ${T("dot(V,Ht)")};\n                        ${v("LtoHt")}  = ${T("dot(Lt,Ht)")};\n                        ${n.anisotropy?`\n                            ${v("rX")}  = materialData.roughness;\n                            ${v("rY")}  = rX * (1.0 - materialData.anisotropy);\n                            ${x("brdf")}  = color * ${((n,e,t,r,a,o,i,s,u,$,c,p)=>h("TransmissionAnisoBRDF","f",[l(n),l(e),l(t),l(r),l(a),l(o),l(i),m(s),m(u),m($),m(c),l(p)]))("rX","rY","NoV","NoLt","NoHt","VoHt","LtoHt","N","Ht","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                            `:`${x("brdf")}  = color * ${((n,e,t,r,a,o)=>h("TransmissionBRDF","f",[l(n),l(e),l(t),l(r),l(a),l(o)]))("materialData.roughness","NoV","NoLt","NoHt","VoHt","LtoHt")};`}\n                        `}\n                    ${n.dspbr?`\n                        ${x("vec3One")} = ${x()}(1.0);\n                        ${x("fresnelVoHt")}  = ${U("materialData.specularBlendingSR0","vec3One","VoHt")};\n                        ${v("fTrans")}  = 1.0 - materialData.specularContribution * ${C("fresnelVoHt")};\n                        `:`\n                        ${x("sr0Color")}  = materialData.sr0Color;\n                        ${x("sr90Color")}  = materialData.sr90Color;\n                        ${x("fresnelVoHt")}  = ${U("sr0Color","sr90Color","VoHt")};\n                        ${v("fTrans")}  = 1.0 - ${C("fresnelVoHt")};\n                        `}\n            `},t=function(t){return`\n                ${f("CoreModel",null,N())}{           \n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\n                    ${x("sr0Color")}  = materialData.sr0Color;\n                    ${x("sr90Color")}  = materialData.sr90Color;\n\n                    ${v("NoL")}  = ${T("dot(N,L)")};\n                    ${v("NoV")}  = ${T("dot(N,V)")};\n                    ${x("H")}  = normalize(L+V);\n                    ${v("NoH")}  = ${T("dot(N,H)")};\n                    ${v("VoH")}  = ${T("dot(V,H)")};\n                    ${i()}specular = ${U("sr0Color","sr90Color","VoH")};\n                    ${t.useSpecularAA?`\n                        ${_("TBN")}  = surfaceData.TBNMatrixForSpecularAA;\n                        ${x("Htbn")}  = TBN * H;\n                        ${S("roughnesses")} = ${S()}(materialData.roughness, materialData.roughness);\n                        roughnesses = ${h("AxisAlignedNDFFiltering","v2",[m("Htbn"),u("roughnesses")])};\n                        ${i()}specular *= ${F("roughnesses.x","roughnesses.y","NoV","NoL","NoH","N","H","surfaceData.TForSpecularAA","surfaceData.BForSpecularAA","0.0")};\n                        `:`${i()}specular *= ${V("materialData.roughness","NoV","NoL","NoH")};`}\n                    \n                    ${t.dspbr?`\n                        ${i()}diffuse = ${z("materialData.diffuseColor")} * materialData.diffuseEnergyConservationConstant;\n                        ${i()}specular += ${z("materialData.specularEnergyConservationConstant")};\n                        `:`${i()}diffuse = ${z("materialData.diffuseColor")} * ${R("NoL","NoV","sr0Color","sr90Color")};`}\n                }\n\n                ${f("TranslucencyDiffuseModel","v3",[m("L"),m("color")])} {\t\t\n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\t\t\t\t\n                    ${n(t)}\n                    return NoLt * brdf * fTrans;\n                }\n\n                ${f("TranslucencySpecularModel","v3",[m("L"),m("color")])} {\t\n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\t\t\t\t\n                    ${e(t)}\n                    return brdf * NoLt * fTrans;\n                }\n            `},r=function(n){return`     \n                ${f("CoreModelAniso",null,N())}{                  \n                    ${x("N")} = surfaceData.viewNormal;\n                    ${x("V")} = surfaceData.view;\n                    ${v("r")}  = materialData.roughness;\t\n                    ${x("sr0Color")}  = materialData.sr0Color;\n                    ${x("sr90Color")}  = materialData.sr90Color;\n\n                    ${v("NoL")}  = ${T("dot(N,L)")};\n                    ${v("NoV")}  = ${T("dot(N,V)")};\n                    ${x("H")}  = normalize(L+V);\n                    ${v("NoH")}  = ${T("dot(N,H)")};\n                    ${v("VoH")}  = ${T("dot(V,H)")};\n                    ${v("rX")}  = r;\n                    ${v("rY")}  = r * (1.0 - materialData.anisotropy);\n\n                    ${i()}specular = ${U("sr0Color","sr90Color","VoH")};\n                    ${n.useSpecularAA?`\n                        ${_("TBN")} = surfaceData.TBNMatrixForSpecularAA;\n                        ${x("Htbn")}  = TBN * H;\n                        ${S("roughnesses")} = ${S()}(rX, rY);\n                        roughnesses = ${h("AxisAlignedNDFFiltering","v2",[m("Htbn"),u("roughnesses")])};\n                        ${i()}specular *= ${F("roughnesses.x","roughnesses.y","NoV","NoL","NoH","N","H","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};\n                        `:`${i()}specular *= ${F("rX","rY","NoV","NoL","NoH","N","H","surfaceData.tangent","surfaceData.binormal","materialData.anisotropyAngle")};`}\n                    ${n.dspbr?`\n                        ${i()}diffuse = ${z("materialData.diffuseColor")} * materialData.diffuseEnergyConservationConstant;\n                        ${i()}specular += ${z("materialData.specularEnergyConservationConstant")};\n                        `:`${i()}diffuse = ${z("materialData.diffuseColor")} * ${R("NoL","NoV","sr0Color","sr90Color")};`}\n                }\n            `},a="\n        ";E=function(o){let i=`     \n                ${f("DiffuseLambertBRDF","v3",[m("diffuseColor")])}{\n                    return (diffuseColor * INV_PI);\n                }   \n                ${f("SpecularBRDF","f",[l("roughness"),l("NoV"),l("NoL"),l("NoH")])}{\n                    ${v("distrib")}  = ${M("roughness","NoH")};\n                    ${v("geomVis")}  = ${b("roughness","NoV","NoL")};\n                    return distrib*geomVis;\n                }\n                ${f("TransmissionBRDF","f",[l("roughness"),l("NoV"),l("NoL"),l("NoH"),l("VoH"),l("LoH")])}{\n                    ${v("ior2")}  = ${P("materialData.ior")};\n                    ${v("coeff")}  = abs(LoH * VoH) / (max(abs(NoL), 1e-3) * max(abs(NoV),1e-3));\n                    coeff *= ior2;\n                    coeff /= max(${P("materialData.ior*LoH + VoH")}, 1e-3);\n                    ${v("distrib")}  = ${M("roughness","NoH")};\n                    ${v("geomVis")}  = ${w("roughness","NoL","NoV")};\n                    return coeff*distrib*geomVis;\n                }\n            `;return o.useSpecularAA&&(i=`\n                    ${i}\n                    ${f("AxisAlignedNDFFiltering","v2",[m("halfvectorTS"),u("roughness2")])}{\n                        ${S("halfvector2D")}  = halfvectorTS.xy;\n                        ${S("bounds")}  = fwidth(halfvector2D);\n                        ${v("SIGMA2")}  = 0.15915494;\n                        ${S("kernelRoughness2")}  = 2.0 * SIGMA2 * (bounds * bounds);\n                        ${v("KAPPA")}  = 0.18;\n                        ${S("clampedKernelRoughness2")}  = min(kernelRoughness2, KAPPA);\n                        ${S("filteredRoughness2")}  = ${D("roughness2 + clampedKernelRoughness2")};\n                        return filteredRoughness2;\n                    }\n                `),(o.anisotropy||o.useSpecularAA)&&(i=` \n                    ${i}        \n                    ${f("TransmissionAnisoBRDF","f",[l("roughnessX"),l("roughnessY"),l("NoV"),l("NoL"),l("NoH"),l("VoH"),l("LoH"),m("iNormal"),m("H"),m("iTangent"),m("iBinormal"),l("iAnisotropyAngle")])}{\n                        ${v("ior2")}  = materialData.ior * materialData.ior;\n                        ${v("coeff")}  = abs(LoH * VoH) / max(abs(NoL*NoV),1e-3);\n                        coeff *= ior2;\n                        coeff /= materialData.ior * LoH + ior2 *VoH*VoH;\n                        ${v("distrib")}  = AnisotropicDistributionGGX(iTangent, iBinormal, iNormal, H, NoH, roughnessX, roughnessY, iAnisotropyAngle);\n                        ${v("geomVis")}  = AnisotropicGGXVisibility( roughnessX, roughnessY, NoV, NoL, iAnisotropyAngle);\n                        return coeff*distrib*geomVis;\n                    }\n                    ${f("SpecularAnisoBRDF","f",[l("roughnessX"),l("roughnessY"),l("NoV"),l("NoL"),l("NoH"),m("iNormal"),m("H"),m("iTangent"),m("iBinormal"),l("iAnisotropyAngle")])}{\n                        ${v("distrib")}  = AnisotropicDistributionGGX(iTangent, iBinormal, iNormal, H, NoH, roughnessX, roughnessY, iAnisotropyAngle);\n                        ${v("geomVis")}  = AnisotropicGGXVisibility( roughnessX, roughnessY, NoV, NoL, iAnisotropyAngle);;\n                        return distrib*geomVis;\n                    }\n                `),i=`\n                ${i}      \n                ${t(o)}\n            `,o.anisotropy&&(i=`\n                    ${i}\n                    ${r(o)}\n                `),o.maxTubeLights&&(i=`\n                    ${i}         \n\n                    ${f("_TranslucencySpecularModel","v3",[m("L"),m("color")])} {\n                        ${x("N")} = surfaceData.viewNormal;\n                        ${x("V")} = surfaceData.view;\n                        ${e(o)}\n                        return brdf * fTrans;\n                    }          \n                    ${f("_TranslucencyDiffuseModel","v3",[m("L"),m("color")])} {\n                        ${x("N")} = surfaceData.viewNormal;\n                        ${x("V")} = surfaceData.view;\n                        ${n(o)}\n                        return brdf * fTrans;\n                    }\n                `),[i,a]}}return O=function(n){if(!n.iridescence)return["",""];return[`\n                ${((n=null)=>{var e={name:n,constant:!0};return r.mat3(e)})("XYZ_TO_REC709")}  = ${_()}(\n                    3.2404542, -0.9692660,  0.0556434,\n                    -1.5371385,  1.8760108, -0.2040259,\n                    -0.4985314,  0.0415560,  1.0572252\n                );\n\n                ${f("EvalSensitivity","v3",[l("OPD"),m("shift")])}{\n                    ${v("phase")}  = 2.0 * PI * OPD * 1.0e-9;\n                    ${x("val")}  = ${x()}(5.4856e-13, 4.4201e-13, 5.2481e-13);\n                    ${x("pos")}  = ${x()}(1.6810e+06, 1.7953e+06, 2.2084e+06);\n                    ${x("var")}  = ${x()}(4.3278e+09, 9.3046e+09, 6.6121e+09);\n                \n                    ${x("xyz")}  = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-${P("phase")} * var);\n                    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * ${P("phase")});\n                    xyz /= 1.0685e-7;\n                \n                    ${x("rgb")}  = XYZ_TO_REC709 * xyz;\n                    return rgb;\n                }\n\n                ${f("IoRToFresnel0","f",[l("transmittedIoR"),l("incidentIoR")])} {\n                    return ${P("(transmittedIoR - incidentIoR) / (transmittedIoR + incidentIoR)")};\n                }\n\n                ${f("IoRToFresnel0","v3",[m("transmittedIoR"),l("incidentIoR")])}{\n                    ${v("r")}  = ${h("IoRToFresnel0","f",[l("transmittedIoR.r"),l("incidentIoR")])};\n                    ${v("g")}  = ${h("IoRToFresnel0","f",[l("transmittedIoR.g"),l("incidentIoR")])};\n                    ${v("b")}  = ${h("IoRToFresnel0","f",[l("transmittedIoR.b"),l("incidentIoR")])};\n                    return ${x()}(r, g, b);\n                }\n\n                ${f("Fresnel0ToIoR","v3",[m("fresnel0")])}{\n                    ${x("sqrtF0")}  = sqrt( fresnel0 );\n                    return ( ${x()}( 1.0 ) + sqrtF0 ) / ( ${x()}( 1.0 ) - sqrtF0 );\n                }\n\n                ${f("ComputeIridescenceFresnel","v4",[l("outsideIoR"),l("iridescenceIoR"),m("sr0Color"),l("iridescenceThickness"),l("cosTheta1")])}{\n                    ${v("sinTheta2Sq")}  = ${P("outsideIoR / iridescenceIoR")} * ( 1.0 - ${P("cosTheta1")} );\n                    ${v("cosTheta2Sq")}  = 1.0 - sinTheta2Sq;\n                    if ( cosTheta2Sq < 0.0 ) {\n                        return ${y()}( 1.0, 1.0, 1.0, 1.0 );\n                    }\n                    ${v("cosTheta2")}  = sqrt(cosTheta2Sq);\n\n                    ${v("R0")}  = ${h("IoRToFresnel0","f",[l("iridescenceIoR"),l("outsideIoR")])};\n                    ${v("R12")}  = ${h("FresnelSchlick","f",[l("R0"),l("1.0"),l("cosTheta1")])};\n                    ${v("R21")}  = R12;\n                    ${v("T121")}  = 1.0 - R12;\n                    ${v("phi12")}  = 0.0;\n                    if (iridescenceIoR < outsideIoR) {\n                        phi12 = PI;\n                    }\n                    ${v("phi21")}  = PI - phi12;\n\n                    ${x("upThreshold")} = ${x()}(1.0 - 1e-2);\n                    ${x("baseIoR")}  = ${h("Fresnel0ToIoR","V3",[m("min(sr0Color, upThreshold)")])};\n                    ${x("R1")}  = ${h("IoRToFresnel0","v3",[m("baseIoR"),l("iridescenceIoR")])};\n                    ${x("R23")}  = ${U("R1",`${x()}(1.0)`,"cosTheta2")};\n                    ${x("phi23")}  = ${x()}(0.0);\n                    if (baseIoR.x < iridescenceIoR) {\n                        phi23.x = PI;\n                    }\n                    if (baseIoR.y < iridescenceIoR) {\n                        phi23.y = PI;\n                    }\n                    if (baseIoR.z < iridescenceIoR) {\n                        phi23.z = PI;\n                    }\n\n                    ${v("OPD")}  = 2.0 * iridescenceIoR * iridescenceThickness * cosTheta2;\n                    ${x("phi")}  = ${x()}( phi21 ) + phi23;\n\n                    ${x("R123")}  = clamp( R12 * R23, 1e-6, 1.0 - 1e-6 );\n                    ${x("r123")}  = sqrt( R123 );\n                    ${x("Rs")}  = ${P("T121")} * R23 / ( ${x()}( 1.0 ) - R123 );\n\n                    ${x("C0")}  = R12 + Rs;\n                    ${x("I")}  = C0;\n\n                    ${x("Cm")}  = Rs - T121;\n                    for (${g("m")} = 1; m <= 2; ++m) {\n                        Cm *= r123;\n                        ${v("mFloat")} = ${v()}(m);\n                        ${x("Sm")}  = 2.0 * ${h("EvalSensitivity","v3",[l("mFloat * OPD"),m("mFloat * phi")])};\n                        I += Cm * Sm;\n                    }\n                    I = max(I, ${x()}(0.0));\n                    return ${y()}(I, abs(dot(C0, luminanceVector)));\n                }\n            `,""]},{getEquationsShaders:function(n,e){if(!n)return["",""];let t=E(e),r=A(e),a=L(e),o=I(e),i=B(e),s=k(e),l=O(e);return[`\n                ${t[0]}\n                ${r[0]}\n                ${a[0]}\n                ${o[0]}\n                ${i[0]}\n                ${s[0]}\n                ${l[0]}\n            `,"\n            "]}}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexGetterShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";a.ParameterUtils;const i=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t);return{PDSFX_getters_vertex:function(n){var e="";return e=`\n            ${e}\n            ${i("vGetInstanceID","i",[])}{\n                ${n.isMultiInstanced?`return ${((n=null)=>{var e={name:n};return o.int(e)})()}(instanceId/5.0 - 1.0);`:"return 0;"}\n            }\n            \n            ${i("vGetAttribPosition","v3",[])}{\n                return INTERNAL_backup_position;\n            }\n\n            ${i("vGetAttribPreviousPosition","v3",[])}{\n                return INTERNAL_backup_previousPos;\n            }\n\n            ${i("vGetAttribFollowingPosition","v3",[])}{\n                return INTERNAL_backup_followingPos;\n            }\n            \n            ${i("vGetAttribNormal","v3",[])}{\n                return INTERNAL_backup_normal;\n            }\n            \n            ${i("vGetAttribColor","v3",[])}{\n                return color.xyz;\n            }\n\n            ${i("_vGetAttribColorAlpha","f",[])}{\n                return color.a;\n            }\n            \n            ${i("vGetAttribTexCoord0","v4",[])}{\n                return INTERNAL_backup_uv;\n            }\n            \n            ${i("vGetAttribTexCoord1","v4",[])}{\n                return INTERNAL_backup_uv2;\n            }\n            \n            ${i("vGetAttribTexCoord2","v4",[])}{\n                return INTERNAL_backup_uv3;\n            }\n            \n            ${i("vGetAttribTangent","v3",[])}{\n                return INTERNAL_backup_tangent;\n            }  \n\n            ${i("vGetAttribBinormal","v3",[])}{\n                return INTERNAL_backup_binormal;\n            }\n\n            ${((n=null)=>{var e={name:n};return o.float(e)})("INTERNAL_backup_halfWidth")} ;\n            ${i("vGetHalfWidth","f",[])}{\n                return INTERNAL_backup_halfWidth;\n            }\n\n            `}}}),define("DS/ShaderBuilders/PBRUtils/PBRFragmentAnalyticalLightsShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=t.ParameterUtils,i=t.FunctionHandler,s=()=>a.dereference(),l=(n,e,t=!1)=>o.parameter(n,e,t),u=(n,e,t=!1)=>o.parameterInOut(n,e,t),m=(n,e,t=!1)=>o.parameterRef(n,e,t),$=n=>o.parameterF(n),c=n=>o.parameterV2(n),p=n=>o.parameterV3(n),d=n=>o.parameterInOutV3(n),f=n=>o.parameterRefV3(n),h=n=>o.parameterV4(n),g=n=>o.parameterT2(n),v=(n,e,t)=>i.declareFunction(n,e,t),S=(n,e,t)=>i.callFunction(n,e,t),x=n=>r.getShaderOutput(n),y=n=>r.getVarying(n,r.ShaderStages.in),_=n=>S("saturate","f",[$(n)]),T=n=>`max(${n}, 0.0)`,D=n=>S("vMax","v3",[p(n)]),C=n=>S("pow2","f",[$(n)]),P=n=>S("vNormalize","v3",[p(n)]),N=()=>[d("diffuse"),d("specular"),p("L")],M=n=>S("SpecGlossEnergyConservationTerm","f",[p(n)]),b=(n,e,t)=>S("FresnelSchlick","v3",[p(n),p(e),$(t)]),w=(n,e,t,r)=>S("doFullShadowApplication","v3",[p(n),p(e),$(t),h(r)]),U=(n,e)=>S("doShadowApplication","v3",[p(n),$(e)]),z=(n,e,t,r)=>S("doLightingModel",null,[p(n),f(e),f(t),p(r)]),V=(n,e)=>S("TranslucencySpecularModel","v3",[p(n),p(e)]),F=(n,e)=>S("TranslucencyDiffuseModel","v3",[p(n),p(e)]),R=(n,e,t,r,a)=>S("multiSampleTransmittance","v3",[h(n),c(e),c(t),g(r),l("b",a)]),A=n=>e.addObjectUniform(n),I=n=>e.addLightUniform(n),L=n=>{var t={uniformName:n};return e.getLightUniform(t)},B=n=>{var t={uniformName:n};return e.getShadowUniform(t)},k=n=>{var t={uniformName:n};return e.getGlobalUniform(t)},E=(n=null)=>{var e={name:n};return a.bool(e)},O=(n=null)=>{var e={name:n};return a.int(e)},G=(n=null)=>{var e={name:n};return a.float(e)},H=(n=null)=>{var e={name:n};return a.vec2(e)},X=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},W=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},j=(n=null)=>{var e={name:n};return a.mat3(e)},q=n=>{var e={name:n,constant:!0};return a.float(e)},Z=n=>{var e={name:n,constant:!0};return a.vec2(e)};let J,Y,K,Q,nn,en,tn,rn,an;{let n=function(n,e){return`\n                    ${X("lightColor")}  = ${L("directionalLightColor")}[ ${n} ].xyz;\n            \n                    ${X("diffuse")}   = ${X()}( 0.0 );\n                    ${X("specular")}  = ${X()}( 0.0 );\n\n                    ${W("lDirection")}  = ${k("viewMatrix")} * ${W()}( ${L("directionalLightDirection")}[ ${n} ].xyz, 0.0 );\n                    ${X("lVector")}  = normalize( lDirection.xyz );\n                \n                    ${G("shadowExposure")}  = 1.0;\n                    ${W("transparentExposure")}  = ${W()}(1.0);\n                    ${e.shadowMapEnabled?`\n                        ${e.shadowMapCascade?`${"0"===n?`shadowExposure = ${S("getExposureCascaded","f",[(n=>o.parameterRefV4(n))("transparentExposure")])};`:""}`:`\n                            if(${n}<SHADOWS_DIR_END){\n                                shadowExposure = ${S("getExposureFromIndex","f",[l("i",`${n}`)])};\n                                ${e.transparentShadowEnabled?`transparentExposure = ${S("getTransparentExposureFromIndex","v4",[l("i",`${n}`)])};`:""}\n                            }\n                            `}\n                        `:""}\n\n                    \n                    ${e.invisiblePlaneMaterial?`\n                        lightColor = ${X()}(${D("lightColor")});\n                        lightNormalizationFactor += lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                        `:""}\n                    ${e.shadowMapEnabled&&e.transparentShadowEnabled?`\n                        ${X("lightColorNoIntensity")}  = ${B("directionalLightColorNoIntensity")}[ ${n} ].xyz;\n                        ${e.invisiblePlaneMaterial?`\n                            lightColorNoIntensity = ${X()}(${D("lightColorNoIntensity")});\n                            `:""}\n                        ${X("E")}  = ${w("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                        `:`${X("E")} = ${U("lightColor","shadowExposure")};`}\n\n                    ${z("E","diffuse","specular","lVector")};\n\n                    ${e.subsurface?`\n                        ${E("doThicknessBasedTransmittance")}  = true;\n                        ${e.useMapTransmittance?`\n                            if (${n} < SHADOWS_DIR_END) {\n                                ${X("dirAttenuation")}  = lightColor *  ${R(`gShadowCoord[ ${n} ]`,`${H()}(${B("shadowMapNear")}[${n}], ${B("shadowMapFar")}[${n}])`,`${B("shadowMapSize")}[ ${n} ]`,`shadowMap[ ${n} ]`,"true")};\n                                totalTransmissive += dirAttenuation * ${V("lVector","materialData.transparentColor")};\n                                ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * ${F("lVector","materialData.translucencyColor")};`:""}\n                                doThicknessBasedTransmittance = false;\n                            }\n                            `:""}\n                        ${e.thicknessBasedTransmittance?`\n                            if (doThicknessBasedTransmittance) {\n                                ${X("dirAttenuation")} = lightColor *  materialData.transmittanceColor;\n                                totalTransmissive += dirAttenuation * ${V("lVector","materialData.transparentColor")};\n                                ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * ${F("lVector","materialData.translucencyColor")};`:""}\n                            }\n                            `:""}\n                        `:`\n                        ${e.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * lightColor * ${F("lVector","materialData.translucencyColor")};`:""}\n                        `}\n\n                    totalDiffuse += diffuse ;\n                    totalSpecular += specular;\n            `},e=function(n){return`\n            ${I({uniformName:"directionalLightColor",uniformType:"fv4",size:n.maxDirLights,materialName:"directional.colors"})}    \n            ${I({uniformName:"directionalLightDirection",uniformType:"fv4",size:n.maxDirLights,materialName:"directional.positions"})}\n        `},t=function(e){return e.shadowMapEnabled&&e.shadowMapCascade?`\n                {\n                    ${n("0",e)}\n                }\n                ${e.maxDirLights>1?`\n                    for( ${O("i")} = 1; i < ${e.maxDirLights} ; i ++ ) { \n                        ${n("i",e)}\n                    }\n                    `:""}\n                `:`\n                ${e.maxDirLights>0?`\n                    for( ${O("i")} = 0; i < ${e.maxDirLights} ; i ++ ) { \n                        ${n("i",e)}\n                    }\n                    `:""}\n                `};J=function(n){return n.maxDirLights>0?[e(n),t(n)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"directionalIBLLightColor",uniformType:"fv4",size:n.maxDirIBLLights})}  \n            ${I({uniformName:"directionalIBLLightDirection",uniformType:"fv4",size:n.maxDirIBLLights})}  \n        `},t=function(n){return`        \n                for( ${O("i")} = 0; i < ${n.maxDirIBLLights}; i ++ ) {\n                    ${X("lightColor")}  = directionalIBLLightColor[i].xyz;\n                    if (lightColor.r < 1e-6) {\n                        continue;\n                    }\n                    ${W("lWorldDirection")}  = ${W()}( directionalIBLLightDirection[ i ].xyz, 0.0 );\n                    ${W("lDirection")}  = ${k("viewMatrix")} * lWorldDirection;\n                    ${X("lVector")}  = normalize( lDirection.xyz );\n\n                    ${H("normalUV")}  = ${S("getEnvMapUV","v2",[p("normalize(lWorldDirection.xyz)")])};\n                    ${n.envMapDiffuse?`${G("diffMip")}  = 6.0;`:`${G("diffMip")}  = 5.0;`}\n                    ${H("diffuseUV")}  = ${S("getUVFromMips","v2",[$("diffMip"),c("normalUV"),c("mipsTexelSize")])};\n                    ${W("diffuseColor")}  = ${S("texture2DBilinearFromRGBE","v4",[g("envMap2"),c("diffuseUV"),c("mipsSize"),c("mipsTexelSize")])};\n\n                    ${X("E")}  = PI * diffuseColor.rgb * lightColor * ${t="envMapExposureDiffuse",r={uniformName:t},e.getUniform(r)};\n                    if (i + SHADOWS_DIR_IBL_START < SHADOWS_DIR_IBL_END) {\n                        ${X("dirAttenuation")}  = ${R("gShadowCoord[ i + SHADOWS_DIR_IBL_START]",`${H()}(${B("shadowMapNear")}[i+ SHADOWS_DIR_IBL_START], ${B("shadowMapFar")}[i+ SHADOWS_DIR_IBL_START])`,`${B("shadowMapSize")}[ i+ SHADOWS_DIR_IBL_START ]`,"shadowMap[ i+ SHADOWS_DIR_IBL_START]","true")};\n                        totalTransmissive += dirAttenuation * E *  ${V("lVector","materialData.transparentColor")};\n                        ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * dirAttenuation * E * ${F("lVector","materialData.translucencyColor")};`:""}\n                    }    \n                }\n        `;var t,r};Y=function(e){return e.maxDirIBLLights>0&&e.envMap&&e.useMapTransmittance&&!e.shadowMapDebugMaterial?[n(e),t(e)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"pointLightColor",uniformType:"fv4",size:n.maxPointLights})} \n            ${I({uniformName:"pointLightPosition",uniformType:"fv4",size:n.maxPointLights})} \n            ${I({uniformName:"pointLightPhysicalAttenuation",uniformType:"iv1",size:n.maxPointLights})} \n        `},e=function(n){return`\n            for ( ${O("i")} = 0; i < ${n.maxPointLights}; i ++ ) {\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("pointLightPosition")}[ i ].xyz, 1.0 );\n                ${X("lVector")}  = lPosition.xyz + surfaceData.viewPosition.xyz;\n\n                ${G("lAttenuation")}  = 1.0;\n                if (${L("pointLightPhysicalAttenuation")}[ i ]> 0){\n                    lAttenuation = 1.0 / (dot(lVector,lVector) * ${L("pointLightPosition")}[ i ].w);\n                }else {\n                    if ( ${L("pointLightPosition")}[ i ].w > 0.0 ) {\n                        lAttenuation = 1.0 - min( ( length( lVector ) / ${L("pointLightPosition")}[ i ].w ), 1.0 );\n                    }\n                }\n                lVector = normalize( lVector );\n                \n                ${G("shadowExposure")} = 1.0;\n                ${W("transparentExposure")} = ${W()}(1.0);\n                ${n.shadowMapCubeEnabled?`\n                    if (i<${n.maxShadowsCube}){\n                        shadowExposure = ${S("getExposureFromIndexCube","f",[l("i","i"),p(y("vWorldPosition"))])};\n                        ${n.transparentShadowEnabled?`transparentExposure =  ${S("getTransparentExposureFromIndexCube","v4",[l("i","i"),p(y("vWorldPosition"))])};`:""}\n                    }\n                    `:""}\n                 ${X("lightColor")} = ${L("pointLightColor")}[ i ].xyz;\n                ${n.invisiblePlaneMaterial?`\n                    lightColor =${X()}(${D("lightColor")});\n                    lightNormalizationFactor += lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                    `:""}\n                ${n.shadowMapCubeEnabled&&n.transparentShadowEnabled?`\n                    ${X("lightColorNoIntensity")} = ${B("pointLightColorNoIntensity")}[ i ].xyz;\n                    ${n.invisiblePlaneMaterial?`\n                        lightColorNoIntensity =${X()}(${D("lightColorNoIntensity")});\n                        `:""}\n                     ${X("E")} = lAttenuation * ${w("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                    `:` ${X("E")} = lAttenuation * ${U("lightColor","shadowExposure")};`}\n\n                ${z("E","diffuse","specular","lVector")};\n\n                ${n.subsurface?`\n                    ${E("doThicknessBasedTransmittance")} = true;\n                    ${n.useCubeTransmittance?`\n                        if (i < ${n.maxShadowsCube}) {\n                            ${X("pointAttenuation")} = lAttenuation * lightColor * ${S("multiSampleCubeTransmittance","v3",[p("surfaceData.worldPosition"),p(`${B("shadowPointPosition")}[i].xyz`),c(`${H()}(${B("shadowNearCube")}[i], ${B("shadowFarCube")}[i])`),$(`${B("shadowPointPosition")}[i].w`),(n=>o.parameterTC(n))("shadowMapCube[i]"),l("b","false")])};\n                            totalTransmissive += pointAttenuation * ${V("lVector","materialData.transparentColor")};\n                            ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * pointAttenuation * ${F("lVector","materialData.translucencyColor")};`:""}\n                            doThicknessBasedTransmittance = false;\n                        }\n                        `:""}\n                    ${n.thicknessBasedTransmittance?`\n                        if(doThicknessBasedTransmittance) {\n                            ${X("pointAttenuation")} = lAttenuation * lightColor * materialData.transmittanceColor;\n                            totalTransmissive += pointAttenuation * ${V("lVector","materialData.transparentColor")};\n                            ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * pointAttenuation * ${F("lVector","materialData.translucencyColor")};`:""}\n                        }\n                        `:""}\n                    `:`\n                    ${n.dspbrWithTranslucency?`totalTransmissive +=  materialData.translucency * lAttenuation * lightColor * ${F("lVector","materialData.translucencyColor")};`:""}\n                    `}\n\n                totalDiffuse += diffuse;\n                totalSpecular += specular;\n            }\n        `};K=function(t){return t.maxPointLights?[n(t),e(t)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"iesLightColor",uniformType:"fv4",size:n.maxIESLights})} \n            ${I({uniformName:"iesLightTexture",uniformType:"t2v",size:n.maxIESLights})} \n            ${I({uniformName:"matrixWorldInv",uniformType:"m4v",size:n.maxIESLights})} \n\n            ${I({uniformName:"iesLightPosition",uniformType:"fv4",size:n.maxIESLights})} \n            ${I({uniformName:"iesLightPhysicalAttenuation",uniformType:"iv1",size:n.maxIESLights})} \n        `},e=function(n){return`\n            for ( ${O("i")} = 0; i < ${n.maxIESLights}; i ++ ) {\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("iesLightPosition")}[ i ].xyz, 1.0 );\n                ${X("lVector")} = lPosition.xyz + surfaceData.viewPosition.xyz;\n\n                ${G("lAttenuation")}  = 1.0;\n                if (${L("iesLightPhysicalAttenuation")}[ i ]> 0){\n                    lAttenuation = 1.0 / (dot(lVector,lVector) * ${L("iesLightPosition")}[ i ].w);\n                }else {\n                    if ( ${L("iesLightPosition")}[ i ].w > 0.0 ) {\n                        lAttenuation = 1.0 - min( ( length( lVector ) / ${L("iesLightPosition")}[ i ].w ), 1.0 );\n                    }\n                }\n\n                lVector = normalize( lVector );\n\n                 ${X("E")} = ${L("iesLightColor")}[ i ].xyz * lAttenuation * PI;\n\n                ${W("coordInIESWorld")}  = normalize(${L("matrixWorldInv")}[i] * ${W()}(surfaceData.worldPosition,1.0));\n                ${G("stepTexture")}  = 1.0/128.0*72.0;\n                ${G("phi")}  = acos(-coordInIESWorld.z)*INV_PI;\n                ${G("theta")}  = ${S("myAtan2","f",[$("coordInIESWorld.x"),$("-coordInIESWorld.y")])}*INV_PI;\n                if(theta < 0.0) theta *= -1.0;\n                E *= ${i.sample2DTexture("iesLightTexture[i]",`${H()}(phi,theta)`)}.x;\n\n                ${z("E","diffuse","specular","lVector")};\n                \n                ${n.subsurface&&n.thicknessBasedTransmittance?`\n                    ${X("iesAttenuation")} = E * materialData.transmittanceColor;\n                    totalTransmissive += iesAttenuation * ${V("lVector","materialData.transparentColor")};\n                    ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * iesAttenuation * ${F("lVector","materialData.translucencyColor")};`:""} \n                    `:""}  \n                ${n.dspbrWithTranslucency&&!n.subsurface?`totalTransmissive += materialData.translucency * E * ${F("lVector","materialData.translucencyColor")};`:""}\n\n                totalDiffuse  += diffuse;\n                totalSpecular += specular;\n            }\n        `};Q=function(t){return t.maxIESLights&&!t.shadowMapDebugMaterial?[n(t),e(t)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"spotLightColor",uniformType:"fv4",size:n.maxSpotLights})} \n            ${I({uniformName:"spotLightPosition",uniformType:"fv4",size:n.maxSpotLights})} \n            ${I({uniformName:"spotLightDirection",uniformType:"fv4",size:n.maxSpotLights})} \n            ${I({uniformName:"spotLightPhysicalAttenuation",uniformType:"iv1",size:n.maxSpotLights})} \n        `},e=function(n){return`\n            for ( ${O("i")} = 0; i < ${n.maxSpotLights}; i ++ ) {\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("spotLightPosition")}[ i ].xyz, 1.0 );\n                ${X("lVector")} = lPosition.xyz + surfaceData.viewPosition.xyz;\n\n                ${G("lAttenuation")}  = 1.0;\n                if (${L("spotLightPhysicalAttenuation")}[ i ]> 0){\n                    lAttenuation =1.0 / (dot(lVector,lVector) * ${L("spotLightColor")}[ i ].w );\n                } else {\n                    if ( ${L("spotLightColor")}[ i ].w > 0.0 ) {\n                        lAttenuation = 1.0 - min( ( length( lVector ) / ${L("spotLightColor")}[ i ].w ), 1.0 );\n                    }\n                }\n                lVector = normalize( lVector );\n                ${G("spotEffect")}  = dot( ${L("spotLightDirection")}[ i ].xyz, normalize( ${L("spotLightPosition")}[ i ].xyz - surfaceData.worldPosition ) );\n\n                if ( spotEffect > ${L("spotLightPosition")}[ i ].w ) {\n                \n                    ${G("shadowExposure")} = 1.0;\n                    ${W("transparentExposure")} = ${W()}(1.0);\n                    ${n.shadowMapEnabled?`\n                        if((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END){\n                            shadowExposure = ${S("getExposureFromIndex","f",[l("i","i + SHADOWS_SPOT_START")])};\n                            ${n.transparentShadowEnabled?`transparentExposure =  ${S("getTransparentExposureFromIndex","v4",[l("i","i + SHADOWS_SPOT_START")])};`:""}\n                        }\n                        `:""}\n\n                    spotEffect = 1.0 - smoothstep( ${L("spotLightDirection")}[ i ].w,${L("spotLightPosition")}[ i ].w,spotEffect );\n\n                     ${X("lightColor")} =  ${L("spotLightColor")}[ i ].xyz;\n                    ${n.invisiblePlaneMaterial?`\n                        lightColor =${X()}(${D("lightColor")});\n                        lightNormalizationFactor += spotEffect * lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));\n                        `:""}\n                    ${n.shadowMapEnabled&&n.transparentShadowEnabled?`\n                        ${X("lightColorNoIntensity")} = ${B("spotLightColorNoIntensity")}[ i ].xyz;\n                        ${n.invisiblePlaneMaterial?`\n                            lightColorNoIntensity =${X()}(${D("lightColorNoIntensity")});\n                            `:""}\n                         ${X("E")} = spotEffect * lAttenuation * ${w("lightColor","lightColorNoIntensity","shadowExposure","transparentExposure")};\n                        `:` ${X("E")} = spotEffect * lAttenuation * ${U("lightColor","shadowExposure")};`}\n\n                    ${z("E","diffuse","specular","lVector")};\n\n                    ${n.subsurface?`\n                        ${E("doThicknessBasedTransmittance")} = true;\n                        ${n.useMapTransmittance?`\n                            if ((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END) {\t\t\n                                ${X("spotAttenuation")} = lightColor * lAttenuation * spotEffect *  ${R("gShadowCoord[ i + SHADOWS_SPOT_START ]",`${H()}(${B("shadowMapNear")}[i + SHADOWS_SPOT_START], \n                                                                                                    ${B("shadowMapFar")}[i + SHADOWS_SPOT_START])`,`${B("shadowMapSize")}[ i + SHADOWS_SPOT_START ]`,"shadowMap[ i + SHADOWS_SPOT_START]","false")};\n                                totalTransmissive += spotAttenuation * ${V("lVector","materialData.transparentColor")};\n                                ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * spotAttenuation *  ${F("lVector","materialData.translucencyColor")};`:""}\n                                doThicknessBasedTransmittance = false;\n                            }\n                            `:""}\n                        ${n.thicknessBasedTransmittance?`\n                            if (doThicknessBasedTransmittance) {\n                                ${X("spotAttenuation")} = lightColor * lAttenuation * spotEffect * materialData.transmittanceColor;\n                                totalTransmissive += spotAttenuation * ${V("lVector","materialData.transparentColor")};\n                                ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * spotAttenuation * ${F("lVector","materialData.translucencyColor")};`:""}\n                            }\n                            `:""}\n                        `:`\n                        ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * lightColor * lAttenuation * spotEffect *  ${F("lVector","materialData.translucencyColor")};`:""}\n                        `}\n\n                    totalDiffuse += diffuse;\n                    totalSpecular += specular;\n                }\n            }\n        `};nn=function(t){return t.maxSpotLights?[n(t),e(t)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"rectangleLightColor",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${I({uniformName:"rectangleLightPosition",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${I({uniformName:"rectangleLightNormal",uniformType:"fv4",size:n.maxRectangleLights})} \n            ${I({uniformName:"rectangleLightUp",uniformType:"fv4",size:n.maxRectangleLights})} \n        `},e=function(n){return`\n            for (${O("i")} = 0; i < ${n.maxRectangleLights}; i++) {                \n                ${X("transmissive")} = ${X()}(0.0);\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("rectangleLightPosition")}[ i ].xyz, 1.0 );\n                ${W("lNormal")} = ${k("viewMatrix")} * ${W()}( ${L("rectangleLightNormal")}[ i ].xyz, 0.0 );\t\t\n\n                ${G("hw")}  = 0.5*${L("rectangleLightPosition")}[i].w;\n                ${G("hh")} = 0.5*${L("rectangleLightNormal")}[i].w;\n                ${X("up")} = (${k("viewMatrix")} * ${W()}( ${L("rectangleLightUp")}[i].xyz,0.0)).xyz;\n                ${X("right")} = normalize(cross(lNormal.xyz, up));\n                ${X("p0")} = lPosition.xyz + right * hw - up * hh;\n                ${X("p1")} = lPosition.xyz - right * hw - up * hh;\n                ${X("p2")} = lPosition.xyz - right * hw + up * hh;\n                ${X("p3")} = lPosition.xyz + right * hw + up * hh;\n                ${S("areaRectangleLightModel",null,[f("specular"),f("diffuse"),f("transmissive"),p("p0"),p("p1"),p("p2"),p("p3")])};\n\n                 ${X("lightColor")} = ${L("rectangleLightColor")}[i].xyz;\n                ${G("attenuation")} = ${S("cropRectangleLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("p2"),p("p3"),p("surfaceData.viewNormal")])};                   \n                totalDiffuse += attenuation * lightColor * diffuse;\n                totalSpecular += attenuation * lightColor * specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor * ${S("cropRectangleLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("p2"),p("p3"),p("-surfaceData.viewNormal")])};\n                    `:""}\n            }\n        `};en=function(t){return t.maxRectangleLights&&!t.shadowMapDebugMaterial?[n(t),e(t)]:["",""]}}{let n=function(n){return`         \n            ${I({uniformName:"diskLightColor",uniformType:"fv4",size:n.maxDiskLights})} \n            ${I({uniformName:"diskLightPosition",uniformType:"fv4",size:n.maxDiskLights})} \n            ${I({uniformName:"diskLightNormal",uniformType:"fv4",size:n.maxDiskLights})} \n            ${I({uniformName:"diskLightUp",uniformType:"fv4",size:n.maxDiskLights})}\n        `},e=function(n){return`\n            for (${O("i")} = 0; i < ${n.maxDiskLights}; i++) {\n                ${X("transmissive")} =${X()}(0.0);\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("diskLightPosition")}[ i ].xyz, 1.0 );\n                ${W("lNormal")} = ${k("viewMatrix")} * ${W()}( ${L("diskLightNormal")}[ i ].xyz, 0.0 );\n                ${G("radius")} = ${L("diskLightPosition")}[i].w;\n                ${X("up")} = (${k("viewMatrix")} * ${W()}( ${L("diskLightUp")}[i].xyz,0.0)).xyz;\n                ${X("right")} = normalize(cross(lNormal.xyz, up));\n                ${X("p0")} = lPosition.xyz + right * radius - up * radius;\n                ${X("p1")} = lPosition.xyz - right * radius - up * radius;\n                ${X("p2")} = lPosition.xyz - right * radius + up * radius;\n                ${S("areaDiskLightModel",null,[f("specular"),f("diffuse"),f("transmissive"),p("p0"),p("p1"),p("p2")])};\n                ${G("attenuation")} = ${S("cropDiskLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("surfaceData.viewNormal")])};\n\n                 ${X("lightColor")} = ${L("diskLightColor")}[i].xyz;\n                totalDiffuse += attenuation * lightColor*diffuse;\n                totalSpecular += attenuation * lightColor*specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor*${S("cropDiskLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("-surfaceData.viewNormal")])};\n                    `:""}\n            }\n        `};tn=function(t){return t.maxDiskLights&&!t.shadowMapDebugMaterial?[n(t),e(t)]:["",""]}}{let n=function(n){return`\n            ${I({uniformName:"sphereLightColor",uniformType:"fv4",size:n.maxSphereLights})} \n            ${I({uniformName:"sphereLightPosition",uniformType:"fv4",size:n.maxSphereLights})} \n            ${I({uniformName:"sphereLightData",uniformType:"fv4",size:n.maxSphereLights})} \n        `},e=function(n){return`\n            for (${O("i")} = 0; i < ${n.maxSphereLights} ; i++) {\n                ${X("transmissive")} =${X()}(0.0);\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("sphereLightPosition")}[ i ].xyz, 1.0 );\t\t\n                ${G("radius")} =  ${L("sphereLightPosition")}[i].w;\n                ${X("p0")};\n                ${X("p1")};\n                ${X("p2")};\n                ${S("getSphereLightPoints",null,[f("lPosition.xyz"),$("radius"),f("p0"),f("p1"),f("p2")])};\n                ${S("areaDiskLightModel",null,[f("specular"),f("diffuse"),f("transmissive"),p("p0"),p("p1"),p("p2")])};\n                ${G("attenuation")} = ${S("cropDiskLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("surfaceData.viewNormal")])};\n                \n                 ${X("lightColor")} = ${L("sphereLightColor")}[i].xyz;\n                totalDiffuse += attenuation * lightColor*diffuse;\n                totalSpecular += attenuation * lightColor*specular;\n                ${n.subsurface||n.dspbrWithTranslucency?`\n                    totalTransmissive += transmissive * lightColor* ${S("cropDiskLight","f",[p("lPosition.xyz"),p("p0"),p("p1"),p("-surfaceData.viewNormal")])};\n                    `:""}\n            }\n        `};rn=function(t){return t.maxSphereLights&&!t.shadowMapDebugMaterial?[n(t),e(t)]:["",""]}}{let n=function(n){return`    \n            ${I({uniformName:"tubeLightColor",uniformType:"fv4",size:n.maxTubeLights})} \n            ${I({uniformName:"tubeLightPosition",uniformType:"fv4",size:n.maxTubeLights})} \n            ${I({uniformName:"tubeLightRight",uniformType:"fv4",size:n.maxTubeLights})} \n        `},e=function(n){const e=(n,e,t,r,a,o,i)=>S("illuminanceTube","f",[p(n),p(e),p(t),p(r),p(a),$(o),$(i)]);return`\n            for (${O("i")} = 0; i < ${n.maxTubeLights} ; i++) {\n                ${X("diffuse")}  = ${X()}( 0.0 );\n                ${X("specular")}  = ${X()}( 0.0 );\n\n                ${W("lPosition")} = ${k("viewMatrix")} * ${W()}( ${L("tubeLightPosition")}[ i ].xyz, 1.0 );\n                ${G("lRadius")} = ${L("tubeLightPosition")}[i].w;\n                ${G("lWidth")} = ${L("tubeLightRight")}[i].w;\n                ${X("lRight")}  = (${k("viewMatrix")} * ${W()}( ${L("tubeLightRight")}[i].xyz,0.0)).xyz;\n                ${X("P0")}  = lPosition.xyz - lRight * lWidth * 0.5;\n                ${X("P1")}  = lPosition.xyz + lRight * lWidth * 0.5;\n\n                ${X("lightColor")} = ${L("tubeLightColor")}[i].xyz;\n                ${X("E")} = lightColor * ${e("P0","P1","lPosition.xyz","surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")};\n                ${X("closestPoint")}  = ${S("closestPointTube","v3",[p("P0"),p("P1"),p("viewReflect"),p("lPosition.xyz"),$("lRadius")])};\n                ${S("doAreaLightingModel",null,[p("E"),f("diffuse"),f("specular"),p("closestPoint")])};\n\n                ${n.subsurface&&n.thicknessBasedTransmittance?`\n                    ${X("tubeAttenuation")}  = lightColor * ${e("P0","P1","lPosition.xyz","-surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")}  * materialData.transmittanceColor;\n                    totalTransmissive += tubeAttenuation * ${S("_TranslucencySpecularModel","v3",[p("closestPoint"),p("materialData.transparentColor")])};\n                    ${n.dspbrWithTranslucency?`totalTransmissive += materialData.translucency * tubeAttenuation * ${S("_TranslucencyDiffuseModel","v3",[p("closestPoint"),p("materialData.translucencyColor")])};`:""}   \n                    `:""} \n                ${n.dspbrWithTranslucency&&!n.subsurface?`totalTransmissive += materialData.translucency * lightColor * ${e("P0","P1","lPosition.xyz","-surfaceData.viewNormal","lRight","0.5*lWidth","lRadius")} * ${S("_TranslucencyDiffuseModel","v3",[p("closestPoint"),p("materialData.translucencyColor")])};`:""}\n\n                totalDiffuse += diffuse;\n                totalSpecular += specular;\n            }\n        `};an=function(t){return t.maxTubeLights&&!t.shadowMapDebugMaterial?[n(t),e(t)]:["",""]}}let on,sn;{function ln(n,e,t,r,a,o,i){for(var s=[p(e),p(t),p(r),l("m3",a)],u=0;u<o.length;u++)s.push(p(o[u]));return S(n,"f",s)}let n=function(n,e,t){function r(t,r,a,o){return ln(n,t,r,a,o,e)}return t.subsurface?`\n                        ${t.specgloss?`${s()}diffuse *= materialData.scatteringColor;`:`\n                            ${X("baseDiffuseValue")}  = ${s()}diffuse;\n                            ${t.dspbrWithTranslucency?`${s()}diffuse = mix(${s()}diffuse, materialData.scatteringColor * baseDiffuseValue, materialData.translucency);`:""}\n                            ${s()}diffuse = mix(${s()}diffuse, materialData.scatteringColor * baseDiffuseValue, materialData.transparency);\n                            `}\n                        ${t.thicknessBasedTransmittance?`\n                            ${X("attenuation")}  = materialData.transmittanceColor;\n                            ${t.dspbrWithTranslucency?`${s()}transmissive = materialData.translucency * materialData.translucencyColor * attenuation * ${r("-N","V","P","mat3(1.0")} * materialData.diffuseEnergyConservationConstant;`:""}\n                            ${t.dspbr?`${G("fTrans")}  = 1.0 - materialData.specularContribution * ${D("materialData.specularBlendingSR0 * areaData.fresnel.x + areaData.fresnel.y")};`:`${G("fTrans")} = 1.0 - ${D("fresnelCore")};`}\n                            ${s()}transmissive += attenuation * materialData.transparentColor * fTrans * ${r("-N","coreView","P","areaData.Minv")};\n                            `:""}\n                `:`\n                    ${t.dspbrWithTranslucency?`\n                        ${s()}diffuse *= (1.0 - materialData.translucency);\n                        ${s()}transmissive = materialData.translucency * materialData.translucencyColor * ${r("-N","V","P","mat3(1.0)")} * materialData.diffuseEnergyConservationConstant;\n                        `:""}\n            `},e=function(n,e,t){if(!t.specGlossFlakes)return"";function r(t,r,a,o){return ln(n,t,r,a,o,e)}return`\n                            ${X("fresnelMetal")}  = metalFlakes.flakesSR0Color * areaData.fresnelMetalFlakes.x;\n                            ${X("flakesVal")}  = fresnelMetal * ${r("N","V","P","areaData.MinvMetalFlakes")};\n                            ${G("energyFlakes")}  = ${M("fresnelMetal")};\n                            ${s()}specular *= energyFlakes;\n                            ${s()}diffuse *= energyFlakes;\n                            ${s()}transmissive *= energyFlakes;\n                            ${s()}specular += flakesVal;\n\n                            fresnelMetal = metal.flakesSR0Color * areaData.fresnelMetal.x;\n                            flakesVal = fresnelMetal * ${r("N","V","P","areaData.MinvMetal")};\n                            energyFlakes = ${M("fresnelMetal")};\n                            ${s()}specular *= energyFlakes;\n                            ${s()}diffuse *= energyFlakes;\n                            ${s()}transmissive *= energyFlakes;\n                            ${s()}specular += flakesVal;\n\n                            ${t.pearlFlakesActivated?`\n                                fresnelMetal = pearlFlakes.flakesSR0Color * areaData.fresnelPearlFlakes.x;\t\t\t\n                                flakesVal = fresnelMetal * ${r("N","V","P","areaData.MinvPearlFlakes")};\n                                energyFlakes = ${M("fresnelMetal")};\n                                ${s()}specular *= energyFlakes;\n                                ${s()}diffuse *= energyFlakes;\n                                ${s()}transmissive *= energyFlakes;\n                                ${s()}specular += flakesVal;\n                                `:""}\n            `},t=function(n,e,t){if(!t.dspbrFlakes)return"";function r(t,r,a,o){return ln(n,t,r,a,o,e)}return`\t\n                    ${X("flakesVal")} = ${X()}(0.0);\n                    if (flakesData.smoothWeight > 0.0) {\n                        flakesVal += flakesData.smoothFlakesColor *  ${r("N","V","P","areaData.MinvMetal")};\n                    }\n                    ${t.dspbrFlakesThreeLayers?`\n                        if (flakesData.stochasticWeight > 0.0) {\n                            flakesVal += flakesData.stochasticHemisphereFlakesColor * ${r("flakesData.stochasticHemisphereFlakesNormal","V","P","areaData.MinvMetalSto")};\n                        }\n                        `:""}\n                    ${t.dspbrFlakesOneLayer?"":`               \n                        if (flakesData.closeupWeight > 0.0) {\n                            flakesVal += flakesData.closeupFlakesColor * ${r("flakesData.closeupFlakesNormal","V","P","areaData.MinvMetalClose")};\n                        }\n                        `}\n                    \n                    ${s()}diffuse *= flakesData.baseWeight;\n                    ${s()}specular *= flakesData.baseWeight;\n                    ${s()}transmissive *= flakesData.baseWeight;\n                    ${s()}specular += flakesVal;\n            `},r=function(n,e,t){if(!t.clearCoat)return"";return`\n                    ${X("fresnelCoat")}  = materialData.clearCoatSR0Color * areaData.fresnelCC.x + materialData.clearCoatSR90Color * areaData.fresnelCC.y;\n                    ${t.dspbr?`\n                        ${G("NcoV")}  = ${T("dot(surfaceData.clearCoatNormal,V)")};\n                        ${X("fresnelCoating")}  = ${b("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NcoV")};\n                        ${G("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${D("fresnelCoating")};\n                        `:`${G("fresnelEnergy")}  = ${M("fresnelCoat")};`}\n                    ${X("coat")} = fresnelCoat * ${r="N",a="V",o="P",i="areaData.MinvCC",ln(n,r,a,o,i,e)};\n                    ${s()}diffuse *= fresnelEnergy;\n                    ${s()}specular *= fresnelEnergy;\n                    ${s()}transmissive *= fresnelEnergy;\n                    ${s()}specular += materialData.clearCoat * coat;\n            `;var r,a,o,i},m=function(n,e,t){function r(t,r,a,o){return ln(n,t,r,a,o,e)}return`                \n                ${X("coreView")}  = V;\n                ${X("fresnelCore")}  = materialData.sr0Color * areaData.fresnel.x + materialData.sr90Color * areaData.fresnel.y;\n                ${s()}specular = fresnelCore;\n                ${s()}specular *= ${r("N","coreView","P","areaData.Minv")};\n\n                ${G("diffuseValue")}  = ${r("N","V","P","mat3(1.0)")};\n                ${t.dspbr?`\n                    ${s()}specular += diffuseValue * materialData.specularEnergyConservationConstant;\n                    diffuseValue *= materialData.diffuseEnergyConservationConstant;\n                    `:`diffuseValue *= ${M("fresnelCore")};`}\n                ${s()}diffuse = materialData.diffuseColor * diffuseValue;\n            `},c=function(n,e,t){if(!t.sheen||!t.dspbrWithSheenColorRoughness)return"";return`\n                ${X("sheen")}  =${X()}(${r="N",a="V",o="P",i="areaData.MinvSheen",ln(n,r,a,o,i,e)});\n                ${G("sheenBlending")}  = 1.0 - materialData.sheenEnergyConservationConstant;\n                diffuse *= sheenBlending;\n                specular *= sheenBlending;\n                transmissive *= sheenBlending;\n                specular += materialData.sheen * sheen * materialData.sheenColor;\n            `;var r,a,o,i},f=function(n,e,t){if(!t.sheen||t.dspbrWithSheenColorRoughness)return"";return`\n                ${X("sheen")}  =${X()}(${r="N",a="V",o="P",i="areaData.MinvSheen",ln(n,r,a,o,i,e)});\n                ${G("sheenBlending")}  = 1.0 - ${(n=>S("pow5","f",[$(n)]))("1.0-materialData.sheen")};\n                diffuse *= PI * sheen * sheenBlending + (1.0 - sheenBlending);\n            `;var r,a,o,i},g=function(n){return`   \n            ${v("_doCommonLightingModel",null,N())} {   \n                ${n.anisotropy?`${S("CoreModelAniso",null,N())};`:`${S("CoreModel",null,N())};`}\n                ${n.shadowMapDebugMaterial?"return;":""}\n                ${n.sheen?`${S("SheenModel",null,N())};`:""}\n\n                ${n.specGlossFlakes?`${S("SpecGlossFlakesModel",null,N())};`:""}\n                ${n.dspbrFlakes?`${S("DSPBRFlakesModel",null,N())};`:""}\n\n                ${n.clearCoat?`${S("ClearCoatModel",null,N())};`:""}\n            }\n\n            ${v("doShadowApplication","v3",[p("light"),$("shadowExposure")])} {\n                return light*shadowExposure;\n            }\n            \n            ${v("doFullShadowApplication","v3",[p("light"),p("lightColor"),$("shadowExposure"),h("transparentExposure")])}{\n                ${X("intensity")}  = max(light / lightColor,${X()}(0.0));\n                return intensity * min(lightColor,transparentExposure.rgb)*min(shadowExposure,transparentExposure.a);\n            }\n\n            ${v("doLightingModel",null,[p("E"),d("diffuse"),d("specular"),p("L")])} {\n                ${X("N")} = surfaceData.viewNormal;\n                ${X("V")} = surfaceData.view;\n                ${n.shadowMapDebugMaterial?"N = L;":""}\n                ${S("_doCommonLightingModel",null,N())};\n                ${n.invisiblePlaneMaterial?`${X("ENoL")} = PI * E * (step(0.0, dot(N, L)));`:`${X("ENoL")} = E * ${T("dot(N, L)")};`}\n                ${n.shadowMapDebugMaterial?`\n                    ${s()}diffuse *= ENoL; \n                    ${s()}specular *= 0.0; \n                    return;\n                    `:""}\n                ${n.subsurface?`\n                    ${X("sssENoL")} = E * ${S("getScattering","v3",[$("dot(N, L)"),$("surfaceData.curvature")])};\n                    ${n.specgloss?`${s()}diffuse *= sssENoL;`:`\n                        ${X("baseDiffuseValue")} = ${s()}diffuse;       \n                        ${n.dspbrWithTranslucency?`${s()}diffuse *= mix(ENoL, sssENoL, materialData.translucency);`:`${s()}diffuse *= ENoL;`}\n                        ${s()}diffuse = mix(${s()}diffuse, sssENoL * baseDiffuseValue, materialData.transparency);\n                        `}\n                    `:`\n                    ${n.dspbrWithTranslucency?`${s()}diffuse *= ENoL * (1.0 - materialData.translucency);`:`${s()}diffuse *= ENoL;`}\n                    `}\n                ${s()}specular *= ENoL;\n              }\n            `},x=function(n){const e=[{type:"m3",name:"Minv"},{type:"v2",name:"fresnel"}];return n.clearCoat&&(e.push({type:"m3",name:"MinvCC"}),e.push({type:"v2",name:"fresnelCC"})),n.sheen&&e.push({type:"m3",name:"MinvSheen"}),n.specGlossFlakes&&(e.push({type:"m3",name:"MinvMetal"}),e.push({type:"v2",name:"fresnelMetal"}),e.push({type:"m3",name:"MinvMetalFlakes"}),e.push({type:"v2",name:"fresnelMetalFlakes"}),n.pearlFlakesActivated&&(e.push({type:"m3",name:"MinvPearlFlakes"}),e.push({type:"v2",name:"fresnelPearlFlakes"}))),n.dspbrFlakes&&(e.push({type:"m3",name:"MinvMetal"}),e.push({type:"v2",name:"fresnelMetal"}),e.push({type:"m3",name:"MinvMetalSto"}),e.push({type:"v2",name:"fresnelMetalSto"}),e.push({type:"m3",name:"MinvMetalClose"}),e.push({type:"v2",name:"fresnelMetalClose"})),`\n            ${a.createStructure({structName:"areaLightingData",attributes:e})}\n            ${a.declareStructure({name:"areaData",structName:"areaLightingData",addressSpace:"private"})};\n                \n            ${q("AREA_LIGHT_LUT_SIZE")}  = 128.0;\n            ${q("AREA_LIGHT_LUT_UV_NORMALIZATION")}  = 1.0 / (5.0 * AREA_LIGHT_LUT_SIZE + 4.0);\n            ${Z("AREA_LIGHT_LUT_UV_FACTOR")}  = ${H()}(AREA_LIGHT_LUT_SIZE * AREA_LIGHT_LUT_UV_NORMALIZATION, 1.0);\n            ${Z("AREA_LIGHT_UV_CLAMP_MIN")} = ${H()}(0.5 / 128.0, 0.0);\n            ${Z("AREA_LIGHT_UV_CLAMP_MAX")} = ${H()}(1.0, 1.0) - AREA_LIGHT_UV_CLAMP_MIN;\n            // offsets\n            ${Z("AREA_LIGHT_GGX_START")}  = ${H()}(0.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Z("AREA_LIGHT_FRESNEL_FACTOR_START")}  = ${H()}(129.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Z("AREA_LIGHT_BECKMANN_START")}  = ${H()}(258.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Z("AREA_LIGHT_ESTEVEZ_START")}  = ${H()}(387.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n            ${Z("AREA_LIGHT_ASHIKMIN_START")}  = ${H()}(516.0, 0.0) * AREA_LIGHT_LUT_UV_NORMALIZATION;\n\n            ${n.sheen?`\n                ${v("setAreaSheenData",null,[$("roughness"),$("NoV"),u("m3","Minv")])}{\n                    ${H("uvAr")} = clamp(${H()}(roughness, 1.0 - sqrt(1.0 - NoV)), AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR;\n                    ${n.useVelvet?`${W("t1")} = ${i.sample2DTexture("precomputedAreaTexture","uvAr + AREA_LIGHT_ASHIKMIN_START")};`:""}\n                    ${n.useSoftVelvet?`${W("t1")} = ${i.sample2DTexture("precomputedAreaTexture","uvAr + AREA_LIGHT_ESTEVEZ_START")};`:""}\n                    ${n.useSatin?`${W("t1")} = ${i.sample2DTexture("precomputedAreaTexture","uvAr + AREA_LIGHT_BECKMANN_START")};`:""}\n                    ${s()}Minv = ${j()}(\n                       ${X()}(t1.x,  0, t1.y),\n                       ${X()}(  0, 1.0,   0),\n                       ${X()}(t1.z,  0, t1.w)\n                    );\n                }\n                `:""}\n            ${v("setAreaGGXData",null,[$("roughness"),$("NoV"),(n=>o.parameterInOutV2(n))("fresnel"),u("m3","Minv")])}{\n                ${H("uvAr")} = clamp(${H()}(roughness, 1.0 - sqrt(1.0 - NoV)), AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR;\n                ${W("t1")} = ${i.sample2DTexture("precomputedAreaTexture","uvAr + AREA_LIGHT_GGX_START")};\n                ${W("t2")} = ${i.sample2DTexture("precomputedAreaTexture","uvAr + AREA_LIGHT_FRESNEL_FACTOR_START")};\n                ${s()}Minv = ${j()}(\n                   ${X()}(t1.x,  0, t1.y),\n                   ${X()}(  0, 1.0,   0),\n                   ${X()}(t1.z,  0, t1.w)\n                );\n                ${s()}fresnel = ${H()}(t2.z,t2.y);\n            }\n            ${v("cropRectangleLight","f",[p("lP"),p("p0"),p("p1"),p("p2"),p("p3"),p("N")])}{\n                ${X("P")} = -surfaceData.viewPosition;\n                ${G("A")}  = dot(${P("lP - P")}, N);\n                ${G("B")}  = dot(${P("p0 - P")}, N);\n                ${G("C")}  = dot(${P("p1 - P")}, N);\n                ${G("D")}  = dot(${P("p2 - P")}, N);\n                ${G("E")}  = dot(${P("p3 - P")}, N);\n                if (max(A, max(B, max(C, max(D,E)))) <= 1e-6) {\n                    return 0.0;\n                }\n                return 1.0;\n            }\n        `},y=function(n){return`   \n            ${v("IntegrateEdgeVec","v3",[p("v1"),p("v2")])}{     \n                ${G("x")} = dot(v1, v2);\n                ${G("y")}  = abs(x);\n\n                ${G("a")}  = 0.8543985 + (0.4965155 + 0.0145206*y)*y;\n                ${G("b")}  = 3.4175940 + (4.1616724 + y)*y;\n                ${G("v")}  = a / b;\n\n                ${G("theta_sintheta")};\n                if (x > 0.0) {\n                    theta_sintheta = v;\n                } else {\n                    theta_sintheta = 0.5*inversesqrt(1.0 - x*x) - v;\n                }\n                return cross(v1, v2)*theta_sintheta;\n            }\n\n            ${v("areaRectangleLight","f",[p("N"),p("V"),p("P"),l("m3","Minv"),p("p0"),p("p1"),p("p2"),p("p3")])} {\n                \n                ${X("dir")}  = p0 - P;\n                ${X("lightNormal")}  = cross(p1 - p0, p3 - p0);\n                ${E("behind")}  = (dot(dir, lightNormal) < 0.0);\n                if (behind) {\n                    return 0.0;\n                }\n                ${X("T")}  = normalize(V-N*dot(V,N));\n                ${X("B")}  = cross(N,T);\n                ${j("TBN")} = ${j()}(T,B,N);\n                ${j("M")}  = Minv*${S("transposeMatrix","m3",[l("m3","TBN")])};\n\n                ${X("L",4)};\n                L[0] = normalize(M * (p0 - P));\n                L[1] = normalize(M * (p1 - P));\n                L[2] = normalize(M * (p2 - P));\n                L[3] = normalize(M * (p3 - P));\n\n                ${X("F")}  = ${S("IntegrateEdgeVec","v3",[p("L[0]"),p("L[1]")])};\n                F += ${S("IntegrateEdgeVec","v3",[p("L[1]"),p("L[2]")])};\n                F += ${S("IntegrateEdgeVec","v3",[p("L[2]"),p("L[3]")])};\n                F += ${S("IntegrateEdgeVec","v3",[p("L[3]"),p("L[0]")])};\n\n                ${G("formFactor")}  = length(F);\n                ${G("z")} = F.z/formFactor;\n                \n                ${H("uv")} = ${H()}(z*0.5 + 0.5, 1.0 - formFactor);\n                uv = clamp(uv, AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR + AREA_LIGHT_FRESNEL_FACTOR_START;\n                ${G("scale")}  = ${i.sample2DTexture("precomputedAreaTexture","uv ")}.w;\n\n                return ${_("scale * formFactor")};\n            }\n        `},w=function(n){return`\n            ${v("SolveCubic","v3",[h("Coefficient")])} {\n                ${W("coef")} = Coefficient;\n                coef.x /= coef.w;\n                coef.y /= 3.0 * coef.w;\n                coef.z /= 3.0 * coef.w;\n\n                ${G("A")} = coef.w;\n                ${G("B")} = coef.z;\n                ${G("C")}  = coef.y;\n                ${G("D")}  = coef.x;\n\n                ${X("Delta")}  =${X()}(\n                    -B*B + C,\n                    -C*B + D,\n                    dot(${H()}(B, -C), coef.xy)\n                );\n\n                ${G("Discriminant")}  = dot(${H()}(4.0*Delta.x, -Delta.y), Delta.zy);\n\n                ${X("RootsA")};\n                ${X("RootsD")};\n\n                ${H("xlc")};\n                ${H("xsc")};\n\n                {\n                    ${G("A_a")}  = 1.0;\n                    ${G("C_a")}  = Delta.x;\n                    ${G("D_a")}  = -2.0*B*Delta.x + Delta.y;\n\n                    ${G("Theta")}  = atan(sqrt(Discriminant), -D_a)/3.0;\n\n                    ${G("x_1a")}  = 2.0*sqrt(-C_a)*cos(Theta);\n                    ${G("x_3a")}  = 2.0*sqrt(-C_a)*cos(Theta + (2.0/3.0)*PI);\n\n                    ${G("xl")} ;\n                    if ((x_1a + x_3a) > 2.0*B) {\n                        xl = x_1a;\n                    } else {\n                        xl = x_3a;\n                    }\n\n                    xlc = ${H()}(xl - B, A);\n                }\n\n                {\n                    ${G("A_d")}  = D;\n                    ${G("C_d")}  = Delta.z;\n                    ${G("D_d")}  = -D*Delta.y + 2.0*C*Delta.z;\n\n                    ${G("Theta")}  = atan(D*sqrt(Discriminant), -D_d)/3.0;\n\n                    ${G("x_1d")}  = 2.0*sqrt(-C_d)*cos(Theta);\n                    ${G("x_3d")}  = 2.0*sqrt(-C_d)*cos(Theta + (2.0/3.0)*PI);\n\n                    ${G("xs")} ;\n                    if (x_1d + x_3d < 2.0*C) {\n                        xs = x_1d;\n                    } else {\n                        xs = x_3d;\n                    }\n\n                    xsc = ${H()}(-D, xs + C);\n                }\n\n                ${G("E")}  =  xlc.y*xsc.y;\n                ${G("F")}  = -xlc.x*xsc.y - xlc.y*xsc.x;\n                ${G("G")}  =  xlc.x*xsc.x;\n\n                ${H("xmc")} = ${H()}(C*F - B*G, -B*F + C*E);\n\n                ${X("Root")}  =${X()}(xsc.x/xsc.y, xmc.x/xmc.y, xlc.x/xlc.y);\n\n                if (Root.x < Root.y && Root.x < Root.z) {\n                    Root = Root.yxz;\n                } else if (Root.z < Root.x && Root.z < Root.y) {\n                    Root = Root.xzy;\n                }\n\n                return Root;\n            }\n\n            ${v("areaDiskLight","f",[p("N"),p("V"),p("P"),l("m3","Minv"),p("p0"),p("p1"),p("p2")])}{\n                ${X("T")}  = normalize(V-N*dot(V,N));\n                ${X("B")}  = cross(N,T);\n\n                ${j("TBN")} = ${j()}(T,B,N);\n                ${j("R")} = ${S("transposeMatrix","m3",[l("m3","TBN")])};\n\n                ${X("L",3)};\n                L[0] = R * (p0 - P);\n                L[1] = R * (p1 - P);\n                L[2] = R * (p2 - P);\n\n                ${X("c")}   = Minv *(0.5 * (L[0] + L[2]));\n                ${X("v1")}  = Minv *(0.5 * (L[1] - L[2]));\n                ${X("v2")}  = Minv *(0.5 * (L[1] - L[0]));\n\n                if(dot(cross(v1, v2), c) < 0.0) return 0.0;\n\n                ${G("a")};\n                ${G("b")} ;\n                ${G("d11")}  = dot(v1, v1);\n                ${G("d22")}  = dot(v2, v2);\n                ${G("d12")}  = dot(v1, v2);\n                if (abs(d12)/sqrt(d11*d22) > 0.005) {\n                    ${G("tr")}  = d11 + d22;\n                    ${G("det")}  = -d12*d12 + d11*d22;\n\n                    det = sqrt(det);\n                    ${G("u")}  = 0.5*sqrt(tr - 2.0*det);\n                    ${G("v")}  = 0.5*sqrt(tr + 2.0*det);\n                    ${G("e_max")}  = ${C("u + v")};\n                    ${G("e_min")}  = ${C("u - v")};\n\n                    ${X("v1_")};\n                    ${X("v2_")} ;\n\n                    if (d11 > d22) {\n                        v1_ = d12*v1 + (e_max - d11)*v2;\n                        v2_ = d12*v1 + (e_min - d11)*v2;\n                    }\n                    else {\n                        v1_ = d12*v2 + (e_max - d22)*v1;\n                        v2_ = d12*v2 + (e_min - d22)*v1;\n                    }\n\n                    a = 1.0 / e_max;\n                    b = 1.0 / e_min;\n                    v1 = normalize(v1_);\n                    v2 = normalize(v2_);\n                }\n                else {\n                    a = 1.0 / dot(v1, v1);\n                    b = 1.0 / dot(v2, v2);\n                    v1 *= sqrt(a);\n                    v2 *= sqrt(b);\n                }\n\n                ${X("v3")}  = normalize(cross(v1, v2));\n                if (dot(c, v3) < 0.0) v3 *= -1.0;\n\n                ${G("L_")}   = dot(v3, c);\n                ${G("x0")}  = dot(v1, c) / L_;\n                ${G("y0")}  = dot(v2, c) / L_;\n\n                ${G("E1")}  = inversesqrt(a);\n                ${G("E2")}  = inversesqrt(b);\n\n                a *= L_*L_;\n                b *= L_*L_;\n\n                ${G("c0")}  = a*b;\n                ${G("c1")}  = a*b*(1.0 + x0*x0 + y0*y0) - a - b;\n                ${G("c2")}  = 1.0 - a*(1.0 + x0*x0) - b*(1.0 + y0*y0);\n                ${G("c3")}  = 1.0;\n\n                ${X("roots")}  = ${S("SolveCubic","v3",[h("vec4(c0, c1, c2, c3)")])};\n                ${G("e1")}  = roots.x;\n                ${G("e2")}  = roots.y;\n                ${G("e3")}  = roots.z;\n\n                ${X("avgDir")}  =${X()}(a*x0/(a - e2), b*y0/(b - e2), 1.0);\n\n                ${j("rotate")}  = ${j()}(v1, v2, v3);\n\n                avgDir = rotate*avgDir;\n                avgDir = normalize(avgDir);\n\n                ${G("L1")}  = sqrt(-e2/e3);\n                ${G("L2")}  = sqrt(-e2/e1);\n\n                ${G("formFactor")}  = L1*L2*inversesqrt((1.0 + L1*L1)*(1.0 + L2*L2));\n\n                ${H("uv")} = ${H()}(avgDir.z*0.5 + 0.5, 1.0 - formFactor);\n                uv = clamp(uv, AREA_LIGHT_UV_CLAMP_MIN, AREA_LIGHT_UV_CLAMP_MAX) * AREA_LIGHT_LUT_UV_FACTOR + AREA_LIGHT_FRESNEL_FACTOR_START;\n                ${G("scale")}  = ${i.sample2DTexture("precomputedAreaTexture","uv")}.w;\n                \n                return ${_("formFactor*scale")};\n            }\n            \n            ${v("cropDiskLight","f",[p("lP"),p("p0"),p("p1"),p("N")])}{\n                ${X("p2")} = lP - (p0 - lP);\n                ${X("p3")} = lP - (p1 - lP);\n                return ${S("cropRectangleLight","f",[p("lP"),p("p0"),p("p1"),p("p2"),p("p3"),p("N")])};\n            }\n            \n            ${v("getSphereLightPoints",null,[d("lP"),$("radius"),d("p0"),d("p1"),d("p2")])} {            \n                ${X("P")} = -surfaceData.viewPosition;\n                ${X("toUse")}  = ${P("P - lP")};\n                ${s()}lP += radius * toUse;\n                ${X("right")} = ${S("getGeomT","v3",[p("toUse")])};\n                ${X("up")} = ${S("getGeomB","v3",[p("toUse"),p("right")])};\n                ${s()}p0 = ${s()}lP.xyz + right * radius - up * radius;\n                ${s()}p1 = ${s()}lP.xyz - right * radius - up * radius;\n                ${s()}p2 = ${s()}lP.xyz - right * radius + up * radius;\n            }\n        `},U=function(n){return`     \n            ${v("solidAngleRect","f",[p("viewPos"),p("p0"),p("p1"),p("p2"),p("p3")])} {            \n                ${X("v0")}  = p0 - viewPos;\n                ${X("v1")}  = p1 - viewPos;\n                ${X("v2")}  = p2 - viewPos;\n                ${X("v3")}  = p3 - viewPos;\n\n                ${X("n0")}  = normalize(cross(v0,v1));\n                ${X("n1")}  = normalize(cross(v1,v2));\n                ${X("n2")}  = normalize(cross(v2,v3));\n                ${X("n3")}  = normalize(cross(v3,v0));\n\n                ${G("g0")}  = acos(dot(-n0,n1));\n                ${G("g1")}  = acos(dot(-n1,n2));\n                ${G("g2")}  = acos(dot(-n2,n3));\n                ${G("g3")}  = acos(dot(-n3,n0));\n\n                return g0 + g1 + g2 + g3 - 2.0 * PI;\n            }\n\n            ${v("closestOnLine","v3",[p("a"),p("b"),p("c")])} {\n                ${X("ab")} = b - a;\n                ${G("t")} = dot(c - a , ab) / dot(ab,ab);\n                return a + t * ab;\n            }\n\n            ${v("closestOnSegment","v3",[p("a"),p("b"),p("c")])} {             \n                ${X("ab")} = b - a;\n                ${G("t")} = dot(c - a , ab) / dot(ab,ab);\n                return a + ${_("t")} * ab;\n            }\n\n            ${v("closestPointSphere","v3",[p("L"),p("R"),$("radius")])} {\n                ${X("centerToRay")}  = dot(L, R) * R - L;\n                ${X("closestPoint")}  = L + centerToRay * ${_("radius / length(centerToRay)")};\n                return normalize(closestPoint);\n            }\n\n            ${v("closestPointTube","v3",[p("P0"),p("P1"),p("R"),p("Lp"),$("radius")])} {\n                ${X("N")} = surfaceData.viewNormal;\n                ${X("P")} = -surfaceData.viewPosition;\n                ${X("L0")}  = P0 - P;\n                ${X("L1")}  = P1 - P;\n                ${X("Ld")}  = L1 - L0;\n                ${G("coeff")}  = dot(R,L0)*dot(R,Ld) - dot(L0,Ld);\n                coeff /= dot(Ld,Ld) - ${C("dot(R,Ld)")};\n                ${X("L")}  = L0 + ${_("coeff")} * Ld;\n\n                return ${S("closestPointSphere","v3",[p("L"),p("R"),$("radius")])};\n            }\n\n            ${v("illuminanceRectangle","f",[p("p0"),p("p1"),p("p2"),p("p3"),p("lightPosition"),p("viewPosition"),p("N")])}{\n                ${G("angle")}  =  ${S("solidAngleRect","f",[p("viewPosition"),p("p0"),p("p1"),p("p2"),p("p3")])};\n                ${G("coeff")}  = ${T("dot(normalize(lightPosition - viewPosition),N)")};\n                coeff += ${T("dot(normalize(p0 - viewPosition),N)")} + ${T("dot(normalize(p1 - viewPosition),N)")};\n                coeff += ${T("dot(normalize(p2 - viewPosition),N)")} + ${T("dot(normalize(p3 - viewPosition),N)")};\n                return angle * 0.2*coeff;\n            }\n\n            ${v("illuminanceTube","f",[p("P0"),p("P1"),p("lightPosition"),p("N"),p("lRight"),$("lHWidth"),$("lRadius")])}{\n                ${X("viewPosition")} = -surfaceData.viewPosition;\n                ${X("forw")}  = normalize(${S("closestOnLine","v3",[p("P0"),p("P1"),p("viewPosition")])} - viewPosition);\n                ${X("right")} = lRight;\n                ${X("up")} = cross(right, forw);\n            \n                ${X("p0")} = lightPosition.xyz + right * lHWidth + up * lRadius;\n                ${X("p1")} = lightPosition.xyz + right * lHWidth + up * -lRadius;\n                ${X("p2")} = lightPosition.xyz + right * -lHWidth + up * -lRadius;\n                ${X("p3")} = lightPosition.xyz + right * -lHWidth + up * lRadius;\n\n                ${G("illu")} = ${S("illuminanceRectangle","f",[p("p0"),p("p1"),p("p2"),p("p3"),p("lightPosition"),p("viewPosition"),p("N")])};\n\n                ${X("sphPos")}  = ${S("closestOnSegment","v3",[p("P0"),p("P1"),p("viewPosition")])};\n                ${X("sphNorm")} = sphPos - viewPosition;\n                ${X("sphL")}  = normalize(sphNorm);\n                ${G("sqrSphDist")}  = dot(sphNorm, sphNorm);\n                ${G("illu2")}  = PI * ${T("dot(sphL, N)")} * (lRadius*lRadius)/sqrSphDist;\n                return illu+illu2;\n            }\n        `};on=function(a){let o="";if(a.hasAreaLights){let i="areaRectangleLight",s=["p0","p1","p2","p3"],l="areaDiskLight",u=["p0","p1","p2"],$="";a.maxRectangleLights&&($=`           \n                        ${y(a)}      \n    \n                        ${v("areaRectangleLightModel",null,[d("specular"),d("diffuse"),d("transmissive"),p("p0"),p("p1"),p("p2"),p("p3")])} {\t     \n                            ${X("N")} = surfaceData.viewNormal;\n                            ${X("V")} = surfaceData.view;     \n                            ${X("P")} = -surfaceData.viewPosition;\n                            ${m(i,s,a)}\n                            ${f(i,s,a)}\n                            ${n(i,s,a)}\n                            ${c(i,s,a)}\n                            ${e(i,s,a)}\n                            ${t(i,s,a)}\n                            ${r(i,s,a)}            \n                        }\n                    `);let h="";(a.maxDiskLights||a.maxSphereLights)&&(h=`\n                 \n                    ${w(a)}\n    \n                    ${v("areaDiskLightModel",null,[d("specular"),d("diffuse"),d("transmissive"),p("p0"),p("p1"),p("p2")])} {\t          \n                        ${X("N")} = surfaceData.viewNormal;\n                        ${X("V")} = surfaceData.view;     \n                        ${X("P")} = -surfaceData.viewPosition;\n                        ${m(l,u,a)}\n                        ${f(l,u,a)}                    \n                        ${n(l,u,a)}\n                        ${c(l,u,a)}\n                        ${e(l,u,a)}                \n                        ${t(l,u,a)}\n                        ${r(l,u,a)}                    \n                    }\n                    `),o=`\n                    ${x(a)}\n                    ${$}\n                    ${h}\n                `}return a.maxTubeLights&&(o=`\n                    ${o}  \n                    ${U(a)}\n                            \n                    ${v("doAreaLightingModel",null,[p("E"),d("diffuse"),d("specular"),p("L")])}{\n                        ${S("_doCommonLightingModel",null,N())};\n                        ${a.subsurface?`\n                            ${X("sssE")}  = E * materialData.scatteringColor;\n                            ${a.specgloss?`${s()}diffuse *= sssE;`:`                  \n                                ${X("baseDiffuseValue")} = ${s()}diffuse;       \n                                ${a.dspbrWithTranslucency?`${s()}diffuse *= mix(E, sssE, materialData.translucency);`:`${s()}diffuse *= E;`}\n                                ${s()}diffuse = mix(${s()}diffuse, sssE * baseDiffuseValue, materialData.transparency);\n                                `}\n                            `:`\n                            ${a.dspbrWithTranslucency?`${s()}diffuse *= E * (1.0 - materialData.translucency);`:`${s()}diffuse *= E;`}\n                            `}\n                        ${s()}specular *= E;\n                    }\n                `),`\n                ${g(a)}\n                ${o}\n            `}}return sn=function(n){if(!n.hasAreaLights)return["",n.maxTubeLights>0?"vec3 viewReflect = reflect(-surfaceData.view, surfaceData.viewNormal);":""];const e=(n,e,t,r)=>S("setAreaGGXData",null,[$(n),$(e),(n=>o.parameterRefV2(n))(t),m("m3",r)]),t=(n,e,t)=>S("setAreaSheenData",null,[$(n),$(e),m("m3",t)]);let r=`\n                ${I({uniformName:"precomputedAreaTexture",uniformType:"t2"})} \n            `,a=`\n                ${X("viewReflect")}  = reflect(-surfaceData.view, surfaceData.viewNormal);\n                ${n.anisotropy?`\n                    ${X("areaBitangent")}  = normalize(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal);\n                    ${X("anisotropicAreaTangent")}  = cross(areaBitangent, surfaceData.view);\n                    ${X("anisotropicAreaNormal")}  = cross(anisotropicAreaTangent, areaBitangent);\n                    ${X("bentAreaNormal")}  = normalize(mix(surfaceData.viewNormal, anisotropicAreaNormal, materialData.anisotropy));\n                    ${X("reflArea")}  = -reflect( surfaceData.view, bentAreaNormal );\n                    ${e("materialData.roughness",`${T("dot(surfaceData.viewNormal, reflArea)")}`,"areaData.fresnel","areaData.Minv")};\n                    `:`${e("materialData.roughness","NoV","areaData.fresnel","areaData.Minv")};`}\n                \n            `;return n.clearCoat&&(a=`\n                    ${a}      \n                    ${e("materialData.clearCoatRoughness",`${T("dot(surfaceData.clearCoatNormal,surfaceData.view)")}`,"areaData.fresnelCC","areaData.MinvCC")};\n                `),n.sheen&&(a=`\n                    ${a}   \n                    ${G("sheenRough_AL")};\n                    ${n.dspbrWithSheenColorRoughness?"sheenRough_AL = materialData.sheenRoughness;":"sheenRough_AL = materialData.sheen;"}\n                    ${n.useVelvet||n.useSoftVelvet?`\n                        ${n.dspbrWithSquaredEstevezKullaRoughness?`${t("sheenRough_AL * sheenRough_AL","NoV","areaData.MinvSheen")};`:`${t("sheenRough_AL","NoV","areaData.MinvSheen")};`}\n                        `:`${t("0.3","NoV","areaData.MinvSheen")};`}\n                `),n.specGlossFlakes&&(a=`\n                    ${a}                       \n                    ${e("metal.flakesRoughness",`${T("dot(metal.flakesNormal,surfaceData.view)")}`,"areaData.fresnelMetal","areaData.MinvMetal")};\n                    ${e("metalFlakes.flakesRoughness",`${T("dot(metalFlakes.flakesNormal,surfaceData.view)")}`,"areaData.fresnelMetalFlakes","areaData.MinvMetalFlakes")};\n                    ${n.pearlFlakesActivated?`${e("pearlFlakes.flakesRoughness",`${T("dot(pearlFlakes.flakesNormal,surfaceData.view)")}`,"areaData.fresnelPearlFlakes","areaData.MinvPearlFlakes")};`:""}\n                `),n.dspbrFlakes&&(a=`\n                    ${a}                                              \n                    if (flakesData.smoothWeight > 0.0) {\n                        ${e("flakesData.flakesRoughness","NoV","areaData.fresnelMetal","areaData.MinvMetal")};\n                    }\n                    ${n.dspbrFlakesThreeLayers?`                    \n                        if (flakesData.stochasticWeight > 0.0) {\n                            ${G("NdotVSto")}  = ${T("dot(flakesData.stochasticHemisphereFlakesNormal, surfaceData.view)")};\n                            ${e("flakesData.flakesRoughness","NdotVSto","areaData.fresnelMetalSto","areaData.MinvMetalSto")};\t\n                        }\n                        `:""}\t\n                    ${n.dspbrFlakesOneLayer?"":`               \n                        if (flakesData.closeupWeight > 0.0) {       \n                            ${G("NdotVClose")}  = ${T("dot(flakesData.closeupFlakesNormal, surfaceData.view)")};\n                            ${e("flakesData.flakesRoughness","NdotVClose","areaData.fresnelMetalClose","areaData.MinvMetalClose")};\t\n                        }\t\n                        `}\n                    \n                `),[r,a]},{getAnalyticalLightShaders:function(n,e){if(!n)return["","",""];let t=J(e),r=Q(e),a=Y(e),o=K(e),s=nn(e),l=sn(e),u=en(e),m=tn(e),c=rn(e),p=an(e),d="",f="";e.lightMap&&(d=`\n                    ${A({uniformName:"lightMap",uniformType:"t2"})}\n                    ${A({uniformName:"lightMapUvTransform",uniformType:"m3"})}\n                    ${A({uniformName:"lightMapUvSlot",uniformType:"i"})}\n                    ${A({uniformName:"lightMapMappingType",uniformType:"i"})}\n                `,f=`\n                    ${X("aoValue")}  = ${i.sample2DTexture("lightMap","lightMapUV")}.rgb;\n                    ${e.lightMapLinear?"":"aoValue *= aoValue;"}\n                    ${1===e.lightMapMode?`\n                        totalDiffuse =${X()}(0.0);\n                        totalSpecular *= clamp(aoValue, 0.0, 1.0);  \n                        `:""}\n                `);let h=`\n                ${t[0]}\n                ${a[0]}\n                ${o[0]}\n                ${r[0]}\n                ${s[0]}\n                ${l[0]}\n                ${u[0]}\n                ${m[0]}\n                ${c[0]}\n                ${p[0]}\n                ${function(n){return n.useEmission?`\n\n        ${v("doEmission","v3",[$("NoV")])} {\n            ${X("V")} = surfaceData.view;\n            ${X("emissionColor")} = materialData.emissionColor;\n            ${X("res")}  = ${X()}(0.0);\n            ${n.emissionNormalized?`\n                ${X("aux")}  =${X()}(0.2126729,0.7151522,0.0721750);\n                res = materialData.emissionValue * emissionColor/max(dot(emissionColor,aux),1e-6);\n                `:"res = materialData.emissionValue * emissionColor;"}\n            ${n.dspbrWithClearCoatAboveEmissive?`\n                ${n.clearCoat?`\n                    ${G("NcoV")}  = ${T("dot(surfaceData.clearCoatNormal,V)")};\n                    ${X("fresnelCoating")}  = ${b("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color","NcoV")};\n                    ${G("fresnelEnergy")}  = 1.0 - materialData.clearCoat * ${D("fresnelCoating")};\n                    res *= fresnelEnergy;\n                    `:""}\n                return res*INV_PI;\n                `:""}\n            ${!n.dspbrWithClearCoatAboveEmissive&&n.dspbr?"return res*INV_PI;":"return res;"}\n        }\n    `:""}(e)}\n                ${d}\n            `,g=`\n                ${X("totalDiffuse")} = ${X()}(0.0);\n                ${X("totalSpecular")} = ${X()}(0.0);\n                ${e.dspbrWithTranslucency||e.subsurface?`\n                    ${X("totalTransmissive")} = ${X()}(0.0);\n                    `:""}\n                \n                ${e.invisiblePlaneMaterial?`${X("lightNormalizationFactor")}  = ${X()}(0.0);`:""}\n                ${t[1]}\n                ${a[1]}\n                ${o[1]}\n                ${r[1]}\n                ${s[1]}\n                ${l[1]}\n                ${u[1]}\n                ${m[1]}\n                ${c[1]}\n                ${p[1]}\n                ${f}\n\t\t\t\t${X("totalAnalyticalColor")} = totalDiffuse + totalSpecular;\n\t\t\t`;return[h,g=`\n                ${g}\n                ${x("out0")} = ${W()}(totalAnalyticalColor, ${x("out0")}.a);\n                ${e.useEmission?`\n                    ${X("totalEmission")} = ${S("doEmission","v3",[$("NoV")])};\n                    `:""}\n                \n            `,on(e)]}}}),define("DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexEntryPointsShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i=a.ParameterUtils,s=(n,e,t)=>a.FunctionHandler.declareFunction(n,e,t);return{__PDSFXComputeCommonValues_VS:function(n,e){return`\n                ${s("ComputeCommonValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeCommonValues_VS:function(n,e){return""},__PDSFXComputeObjectPosition_VS:function(n,e){return`\n                ${s("ComputeObjectPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectPosition_VS:function(n,e){return"return INTERNAL_backup_position;"},__PDSFXComputeObjectPreviousPosition_VS:function(n,e){return`\n                ${s("ComputeObjectPreviousPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectPreviousPosition_VS:function(n,e){return"return INTERNAL_backup_previousPos;"},__PDSFXComputeObjectFollowingPosition_VS:function(n,e){return`\n                ${s("ComputeObjectFollowingPosition","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectFollowingPosition_VS:function(n,e){return"return INTERNAL_backup_followingPos;"},__PDSFXComputeObjectNormal_VS:function(n,e){return`\n                ${s("ComputeObjectNormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectNormal_VS:function(n,e){return"return INTERNAL_backup_normal;"},__PDSFXComputeObjectTexCoord0_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord0","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord0_VS:function(n,e){return"return INTERNAL_backup_uv;"},__PDSFXComputeObjectTexCoord1_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord1","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord1_VS:function(n,e){return"return INTERNAL_backup_uv2;"},__PDSFXComputeObjectTexCoord2_VS:function(n,e){return`\n                ${s("ComputeObjectTexCoord2","v4",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTexCoord2_VS:function(n,e){return"return INTERNAL_backup_uv3;"},__PDSFXComputeObjectTangent_VS:function(n,e){return`\n                ${s("ComputeObjectTangent","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectTangent_VS:function(n,e){return"return INTERNAL_backup_tangent;"},__PDSFXComputeObjectBinormal_VS:function(n,e){return`\n                ${s("ComputeObjectBinormal","v3",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeObjectBinormal_VS:function(n,e){return"return INTERNAL_backup_binormal;"},__PDSFXProcessViewTangentSpace_VS:function(n,e){return`\n                ${s("ProcessViewTangentSpace",null,[i.parameterInOut("TangentSpace","ioWorldViewTS",!0)])} {\n                    ${e(n,["ioWorldViewTS"])}\n                }\n            `},PDSFXProcessViewTangentSpace_VS:function(n,e){return""},__PDSFXProcessLineDistance_VS:function(n,e){return`\n                ${s("ProcessLineDistance",null,[(n=>i.parameterInOutV2(n))("lineDistance")])} {\n                    ${e(n,["lineDistance"])}\n                }\n            `},PDSFXProcessLineDistance_VS:function(n,e){return""},__PDSFXProcessClipSpacePosition_VS:function(n,e){return`\n                ${s("ProcessClipSpacePosition",null,[(n=>i.parameterInOutV4(n))("ioPosition")])} {\n                    ${e(n,["ioPosition"])}\n                }\n            `},PDSFXProcessClipSpacePosition_VS:function(n,e){return""},__PDSFXComputePointSize_VS:function(n,e){return`\n                ${s("ComputePointSize","f",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputePointSize_VS:function(n,e){return"return INTERNAL_backup_sizeForGLPointSize;"},__PDSFXComputeVaryingValues_VS:function(n,e){return`\n                ${s("ComputeVaryingValues",null,[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeVaryingValues_VS:function(n,e){return""},__PDSFXComputeHalfWidth_VS:function(n,e){return`\n                ${s("ComputeHalfWidth","f",[])} {\n                    ${e(n,[])}\n                }\n            `},PDSFXComputeHalfWidth_VS:function(n,e){return"return INTERNAL_backup_halfWidth;"}}}),define("DS/ShaderBuilders/Commons/PDSFXShaders",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexCoreShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentCoreShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexEntryPointsShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentEntryPointsShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXVertexGetterShaders","DS/ShaderBuilders/Commons/PDSFX/PDSFXFragmentGetterShaders","DS/ShaderBuilders/ShaderUtils/AttributeUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s,l,u,m,$){"use strict";m.ParameterUtils;const c=(n,e,t)=>m.FunctionHandler.declareFunction(n,e,t),p=(n,e,t)=>m.FunctionHandler.callFunction(n,e,t),d=n=>l.addUniform(n),f=n=>{var e={uniformName:n};return l.getUniform(e)},h=n=>l.addObjectUniform(n),g=n=>{var e={uniformName:n};return l.getObjectUniform(e)},v=n=>l.addGlobalUniform(n),S=n=>{var e={uniformName:n};return l.getGlobalUniform(e)},x=n=>u.addVarying(n),y=(n=null)=>{var e={name:n};return $.float(e)},_=(n=null)=>{var e={name:n};return $.vec3(e)},T=(n=null)=>{var e={name:n};return $.mat3(e)};var D={PDSFX_halfWidth_pars_vertex_fragment:function(n){return`\n            ${n.PDSFX?`\n                ${d({uniformName:"INTERNAL_uniform_halfWidth",uniformType:"f",locationName:"halfWidth"})} \n\t\t\t    ${y("halfWidth")} ;\n                `:d({uniformName:"halfWidth",uniformType:"f"})}\n            ${c("getHalfWidth","f",[])}{\n                ${y("halfWidthToUse")}  = ${n.PDSFX?"halfWidth":f("halfWidth")};\n\t\t\t\treturn halfWidthToUse;\n\t\t\t}\n            `},PDSFX_halfWidth_backup_fragment_vertex:function(n){return n.wideLine?`\n                INTERNAL_backup_halfWidth = ${f("INTERNAL_uniform_halfWidth")};\n            `:""},PDSFX_halfWidth_fragment_vertex:function(n){return n.wideLine?`\n                halfWidth = ${p("ComputeHalfWidth","f",[])};\n            `:""},PDSFX_halfWidth_fragment_vertex:function(n){return n.wideLine?`\n                halfWidth = ${p("ComputeHalfWidth","f",[])};\n            `:""},PDSFX_Color_pars_fragment:function(n){return n.PDSFX?`\n                    ${d({uniformName:"INTERNAL_uniform_diffuse",uniformType:"v3",locationName:"diffuse"})} \n                    ${_("diffuse")} ;\n                    ${d({uniformName:"INTERNAL_uniform_opacity",uniformType:"f",locationName:"opacity"})} \n                    ${y("opacity")} ;\n                `:`\n            ${d({uniformName:"diffuse",uniformType:"v3"})}\n            ${d({uniformName:"opacity",uniformType:"f"})}\n            `},PDSFX_Phong_pars_fragment:function(n){return n.PDSFX?`\n                    ${d({uniformName:"INTERNAL_uniform_emissive",uniformType:"v3",locationName:"emissive"})} \n                    ${_("emissive")} ;\n                    ${d({uniformName:"INTERNAL_uniform_specular",uniformType:"v3",locationName:"specular"})} \n                    ${_("specular")} ;\n                `:`\n            ${d({uniformName:"emissive",uniformType:"v3"})}\n            ${d({uniformName:"specular",uniformType:"v3"})}\n            `},PDSFX_Color_backup_fragment:function(n){return`\n                INTERNAL_backup_diffuse = ${f("INTERNAL_uniform_diffuse")};\n                _DSopacity_ = ${f("INTERNAL_uniform_opacity")};\n            `},PDSFX_Color_fragment:function(n){return`\n                diffuse = ${p("ComputeAlbedo","v3",[])};\n                opacity = ${p("ComputeOpacity","f",[])};\n            `},PDSFX_Phong_backup_fragment:function(n){return`\n                INTERNAL_backup_emissive = ${f("INTERNAL_uniform_emissive")};\n                INTERNAL_backup_specular = ${f("INTERNAL_uniform_specular")};\n            `},PDSFX_Phong_fragment:function(n){return`\n                emissive = ${p("ComputeEmissive","v3",[])};\n                specular = ${p("ComputeSpecularReflectance","v3",[])};\n            `}},C={PDSFX_common_pars:function(n){const e=p("getModelViewMatrix","m4",[]);var t="";const r=u._context.__varyings__;for(var a in r)if(a.startsWith("INTERNAL_PDSFX_CUSTOM_VARYING")){var o=a.replace("INTERNAL_PDSFX_CUSTOM_VARYING",""),i=r[a];t=`\n                        ${t}\n                        ${$.declareVariable({name:o,type:i.type,size:i.size})};\n                    `}return t=`\n            ${t}\n            \n            ${x({varyingName:"INTERNAL_varying_viewPosition",varyingType:"v3"})}\n            ${x({varyingName:"INTERNAL_varying_viewNormal",varyingType:"v3"})}\n            ${x({varyingName:"INTERNAL_varying_viewTangent",varyingType:"v3"})}\n            ${x({varyingName:"INTERNAL_varying_viewBinormal",varyingType:"v3"})}\n            ${x({varyingName:"INTERNAL_varying_clipPosition",varyingType:"v4"})}\n            \n            /**** PDSFX Common Getters ****/\n            \n            ${y("INTERNAL_backup_size")} ;\n            ${y("INTERNAL_backup_sizeForGLPointSize")} ;\n            ${y("INTERNAL_backup_scale")} ;\n\n            ${c("vGetWorldViewMatrix","m4",[])}{\n                return ${e};\n            }\n            \n\n            ${h({uniformName:"modelViewInvTranspMatrix",uniformType:"m4"})} \n            ${c("vGetWorldViewInvTranspMatrix","m4",[])}{\n                return ${g("modelViewInvTranspMatrix")};\n            }\n            \n            ${c("vGetViewMatrix","m4",[])}{\n                return ${S("viewMatrix")};\n            }\n            \n            ${c("vGetProjectionMatrix","m4",[])}{\n                return ${S("projectionMatrix")};\n            }\n            \n            ${c("vGetViewProjectionMatrix","m4",[])}{\n                return ${S("projectionMatrix")} * ${S("viewMatrix")};\n            }\n            \n\n            ${v({uniformName:"viewInvMatrix",uniformType:"m4"})} \n            ${c("vGetViewInvMatrix","m4",[])}{\n                return ${S("viewInvMatrix")};\n            }\n            \n\n            ${v({uniformName:"projectionInvMatrix",uniformType:"m4"})} \n            ${c("vGetProjectionInvMatrix","m4",[])}{\n                return ${S("projectionInvMatrix")};\n            }\n            \n\n            ${c("vGetViewProjectionInvMatrix","m4",[])}{\n                return ${S("viewInvMatrix")} * ${S("projectionInvMatrix")};\n            }\n            \n\n            ${v({uniformName:"viewInvTranspMatrix",uniformType:"m4"})} \n            ${c("vGetViewInvTranspMatrix","m4",[])}{\n                return ${S("viewInvTranspMatrix")};\n            }\n            \n\n            ${T("INTERNAL_backup_mappingUVTransformation")} ;\n            ${c("vGetTextureMatrix","m4",[])}{\n                ${((n=null)=>{var e={name:n};return $.mat4(e)})("matrix")} ;\n                matrix[0] = vec4(INTERNAL_backup_mappingUVTransformation[0], 0.0);\n                matrix[1] = vec4(INTERNAL_backup_mappingUVTransformation[1], 0.0);\n                matrix[2] = vec4(INTERNAL_backup_mappingUVTransformation[2], 0.0);\n                return matrix;\n            }\n            \n            ${c("vGetWorldEyePos","v3",[])}{\n                return ${S("cameraPosition")};\n            }\n            \n            ${v({uniformName:"lowlightColor",uniformType:"v3"})} \n            ${c("vGetLowlightColor","v3",[])}{\n                return ${S("lowlightColor")};\n            }\n            \n            ${c("vGetDefaultPointSize","f",[])}{\n                return INTERNAL_backup_size;\n            }\n            \n\n            ${v({uniformName:"nearFarLogFactor",uniformType:"v3"})} \n            ${c("vGetNearFarLogFactor","v3",[])}{\n                return ${S("nearFarLogFactor")};\n            }\n            \n            \n            ${v({uniformName:"viewportSize",uniformType:"v2"})} \n            ${c("vGetViewportSize","i2",[])}{\n                return ${((n=null)=>{var e={name:n};return $.ivec2(e)})()}(${S("viewportSize")});\n            }\n            \n            ${c("vGet3x3WorldMatrix","m3",[])}{\n                return ${T()}(modelMatrix);\n            }\n            \n            \n            ${h({uniformName:"modelInvTranspMatrix",uniformType:"m4"})} \n            ${c("vGet3x3WorldInvTranspMatrix","m3",[])}{\n                return ${T()}(${g("modelInvTranspMatrix")});\n            }\n            \n            `}};return Object.assign(C,D),Object.assign(C,e),Object.assign(C,o),Object.assign(C,r),Object.assign(C,t),Object.assign(C,i),Object.assign(C,a.PDSFXFragmentEntryPointsShaders),C}),define("DS/ShaderBuilders/PBRUtils/PBRVertexShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o=r.ParameterUtils,i=r.FunctionHandler,s=(n,e)=>o.parameter(n,e),l=n=>o.parameterV2(n),u=n=>o.parameterV3(n),m=n=>o.parameterRefV3(n),$=(n,e,t)=>i.declareFunction(n,e,t),c=(n,e,t)=>i.callFunction(n,e,t),p=n=>e.addUniform(n),d=n=>{var t={uniformName:n};return e.getUniform(t)},f=(n=null)=>{var e={name:n};return a.float(e)},h=(n=null)=>{var e={name:n};return a.vec2(e)},g=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},v=(n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)},S=n=>t.addVarying(n),x=n=>t.getVarying(n,t.ShaderStages.out),y=(n,e)=>c("ComputeDisplacedPosition","v3",[l(n),u(e)]);var _=function(n){return`\n            ${p({uniformName:"displacementMap",uniformType:"t2"})} \n            ${p({uniformName:"displacementMapSize",uniformType:"v2"})} \n            ${(n=>e.addObjectUniform(n))({uniformName:"displacementRadius",uniformType:"f"})} \n            ${p({uniformName:"displacementUvTransform",uniformType:"m3"})} \n            ${p({uniformName:"displacementUvSlot",uniformType:"i"})} \n\n            \n            ${a.createStructure({structName:"DisplacementData",attributes:[{type:"v3",name:"normal"},{type:"v3",name:"tangent"},{type:"v3",name:"binormal"}]})}\n            ${a.declareStructure({name:"displacementData",structName:"DisplacementData",addressSpace:"private"})};\n\n            ${n.specgloss?`\n                ${p({uniformName:"displacementBias",uniformType:"f"})} \n                ${p({uniformName:"displacementScale",uniformType:"f"})} \n\n                ${$("ComputeDisplacedPosition","v3",[l("iDisplacementUV"),u("positionToDisplace")])}{\n                    ${h("displacementUV")} = iDisplacementUV;\n                    ${n.mappingType>-1?`displacementUV = ${c("applyMappingOperator","v2",[l("displacementUV"),u("positionToDisplace"),u("displacementData.normal"),m("displacementData.tangent"),m("displacementData.binormal")])};`:""}\n                    displacementUV = ${c("applyUVCombination","v2",[l("displacementUV"),s("m3",`${d("displacementUvTransform")}`)])};\n                    ${g("dv")}  = 2.0 * ${i.sample2DTexture("displacementMap","displacementUV")}.xyz - 1.0;\n                    ${f("df")}  = ${d("displacementScale")} * dv.x + ${d("displacementBias")};\n                    return positionToDisplace + normalize(displacementData.normal) * df;\n                }\n                `:`\n                ${n.displacementAddCoef&&n.displacementMulCoef?`\n                    ${p({uniformName:"displacementAddCoef",uniformType:"v3"})} \n                    ${p({uniformName:"displacementMulCoef",uniformType:"v3"})} \n                    `:""}\n\n                ${$("ComputeDisplacedPosition","v3",[l("iDisplacementUV"),u("positionToDisplace")])}{\n                    ${h("displacementUV")} = iDisplacementUV;\n                    ${n.mappingType>-1?`displacementUV = ${c("applyMappingOperator","v2",[l("displacementUV"),u("positionToDisplace"),u("displacementData.normal"),m("displacementData.tangent"),m("displacementData.binormal")])};`:""}\n                    displacementUV = ${c("applyUVCombination","v2",[l("displacementUV"),s("m3",`${d("displacementUvTransform")}`)])};\n                    ${g("dv")}  = 2.0 * ${i.sample2DTexture("displacementMap","displacementUV")}.xyz - 1.0;\n                    ${n.displacementAddCoef&&n.displacementMulCoef?`dv = ${d("displacementMulCoef")} * dv + ${d("displacementAddCoef")};`:""}\n                    ${g("df")}  = normalize(displacementData.normal) * dv.z + normalize(displacementData.tangent) * dv.x + normalize(displacementData.binormal) * dv.y;\n                    return positionToDisplace + df;\n                }\n                `}\n\n            ${$("ComputeDisplacedNormal","v3",[l("displacementUV"),u("displacedPosition"),u("positionToDisplace")])}{\n                ${f("displacementDelta")}  = length(displacedPosition - positionToDisplace);\n                if (displacementDelta <= 1e-3) {\n                    return normal;\n                }\n                ${h("uvOffsetFactor")}  = 1.25 / ${d("displacementMapSize")};\n                ${f("objectOffsetFactor")}  = 0.00872664625 * ${t="displacementRadius",r={uniformName:t},e.getObjectUniform(r)} / max(max(length(${d("displacementUvTransform")}[0]),length(${d("displacementUvTransform")}[1])), 1.0);\n                ${g("t")}  = displacementData.tangent * objectOffsetFactor;\n                vec3 b = displacementData.binormal * objectOffsetFactor;\n                \n                ${h("offset")} = ${h()}(1.0,0.0);\n                ${g("A")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace + t")} - displacedPosition;\n                A = ${c("vNormalize","v3",[u("A")])};\n\n                offset = ${h()}(0.0,1.0);\n                ${g("C")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace + b")} - displacedPosition;\n                C = ${c("vNormalize","v3",[u("C")])};\n\n                offset = ${h()}(-1.0,0.0);\n                ${g("E")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace - t")} - displacedPosition;\n                E = ${c("vNormalize","v3",[u("E")])};\n\n                offset = ${h()}(0.0,-1.0);\n                ${g("G")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace - b")} - displacedPosition;\n                G = ${c("vNormalize","v3",[u("G")])};\n             \n                offset = ${h()}(1.0,1.0);\n                ${g("B")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace + t + b")} - displacedPosition;\n                B = ${c("vNormalize","v3",[u("B")])};\n\n                offset = ${h()}(-1.0,1.0);\n                ${g("D")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace - t + b")} - displacedPosition;\n                D = ${c("vNormalize","v3",[u("D")])};\n\n                offset = ${h()}(-1.0,-1.0);\n                ${g("F")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace - t - b")} - displacedPosition;\n                F = ${c("vNormalize","v3",[u("F")])};\n\n                offset = ${h()}(1.0,-1.0);\n                ${g("H")}  = ${y("displacementUV + uvOffsetFactor * offset","positionToDisplace + t - b")} - displacedPosition;\n                H = ${c("vNormalize","v3",[u("H")])};\n\n\n                ${g("displacedNormal")}  = cross(A, B) + cross(B, C) + cross(C, D) + cross(D,E)+ cross(E,F)+ cross(F,G)+ cross(G,H)+ cross(H,A);\n                ${f("dotNdN")}  = dot(displacedNormal, displacementData.normal);\n                ${g("res")}  = (sign(dotNdN) + 1e-2)* displacedNormal;\n                return ${c("vNormalize","v3",[u("res")])};\n            }\n    `;var t,r},T=function(n){return`\n            ${x("decalPositionVS")} = mvPosition;\n            ${x("decalPositionCS")} = ${(n=>t.getBuiltin(n,t.ShaderStages.out))("position")};\n        `};return{getDisplacementShaders:function(n){return n.displacementMap?[_(n),function(n){return`\n            displacementData.tangent = normalize(objectTangent.xyz);\n            displacementData.binormal = normalize(objectBinormal.xyz);\n            ${h("displacementUv")};\n            if (${d("displacementUvSlot")} == 1) {\n                displacementUv = ${h()}(uv.xy);\n            } else {\n                displacementUv = ${h()}(uv2.xy);\n            }\n            ${n.skinning?`\n                displacementData.normal = skinnedNormal.xyz;\n                ${g("displacedPosition")}  = ${y("displacementUv","position_.xyz")};\n                ${g("displacedNormal")}  = ${c("ComputeDisplacedNormal","v3",[l("displacementUv"),u("displacedPosition"),u("skinned.xyz")])};\n                `:`\n                displacementData.normal = normal.xyz;\n                ${g("displacedPosition")}  = ${y("displacementUv","position_.xyz ")};\n                ${g("displacedNormal")}  = ${c("ComputeDisplacedNormal","v3",[l("displacementUv"),u("displacedPosition"),u("position_.xyz")])};\n                `}\n    `}(n)]:["",""]},getDecalShaders:function(n){return n.isDecal?[`\n            ${S({varyingName:"decalPositionVS",varyingType:"v4"})}\n            ${S({varyingName:"decalPositionCS",varyingType:"v4"})}\n    `,T()]:["",""]},getMappingShaders:function(e,t){return[`\n                ${e.useUV?`\n                    ${S({varyingName:"vUv",varyingType:"v4"})}\n                    ${S({varyingName:"vUv2",varyingType:"v4"})}\n                    ${S({varyingName:"vUv3",varyingType:"v4"})}\n                    ${p({uniformName:"offsetBumpMap",uniformType:"v2",materialName:"anymap.offset",materialType:"position"})}     \n                    ${p({uniformName:"repeatBumpMap",uniformType:"v2",materialName:"anymap.repeat",materialType:"position"})} \n                    `:""}\n                ${n._DefaultShaderChunk.map_pars_vertex(e)}\n                ${t}\n            `,function(n){var e=n.mappingType>-1&&!n.mappingUseFragment,t=n.mappingType>-1&&n.mappingUseFragment;return`    \n        ${n.useUV?`  \n            ${x("vUv")} = uv * ${v()}(${d("repeatBumpMap")}, 1.0, 1.0) +  ${v()}(${d("offsetBumpMap")}, 0.0, 0.0);\n            ${e?`\n                ${n.needTangentBinormal?`\n                    ${x("vUv")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv.xy"),u("position_"),u("normal"),m("tangent"),m("binormal")])}, 0.0, 0.0);\n                    `:`\n                    ${x("vUv")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv.xy"),u("position_"),u("normal")])}, 0.0, 0.0);\n                    `}\n                `:""}\n\n            // WEBGPU TODO: voir avec Jekfer pourquoi on a toujours le code pour vUv2 et vUv3\n            ${n.WebGPU?"":`\n                ${x("vUv2")} = uv2 * ${v()}(${d("repeatBumpMap")}, 1.0, 1.0) + ${v()}(${d("offsetBumpMap")}, 0.0, 0.0);\n                ${e?`\n                    ${n.needTangentBinormal?`${x("vUv2")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv2.xy"),u("position_"),u("normal"),m("tangent"),m("binormal")])}, 0.0, 0.0);`:`${x("vUv2")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv2.xy"),u("position_"),u("normal")])}, 0.0, 0.0);`}\n                    `:""}\n\n            \t${x("vUv3")}  = uv3 *  ${v()}(${d("repeatBumpMap")}, 1.0, 1.0) +  ${v()}(${d("offsetBumpMap")}, 0.0, 0.0);\n                ${e?`\n                    ${n.needTangentBinormal?`${x("vUv3")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv3.xy"),u("position_"),u("normal"),m("tangent"),m("binormal")])}, 0.0, 0.0);`:`${x("vUv3")}  =  ${v()}(${c("applyMappingOperator","v2",[l("uv3.xy"),u("position_"),u("normal")])}, 0.0, 0.0);`}\n                    `:""}\n                `}\n            `:""}\n\n        ${t?`\n            ${x("localPosition")} = position_;\n            ${x("localNormal")} = normal;\n            `:""}\n    `}(e)]}}}),define("DS/ShaderBuilders/PBRUtils/PBRFragmentIBLShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o){"use strict";const i="",s=r.ParameterUtils,l=r.FunctionHandler,u=n=>s.parameterF(n),m=n=>s.parameterV2(n),$=n=>s.parameterV3(n),c=n=>s.parameterT2(n),p=(n,e,t)=>l.declareFunction(n,e,t),d=(n,e,t)=>l.callFunction(n,e,t),f=n=>t.addUniform(n),h=n=>{var e={uniformName:n};return t.getUniform(e)},g=n=>{var e={uniformName:n};return t.getGlobalUniform(e)},v=n=>{var e={uniformName:n};return t.getLightUniform(e)},S=n=>a.getShaderOutput(n),x=n=>d("vMax","v3",[$(n)]),y=n=>d("unpackFrom16","f",[m(n)]),_=(n,e,t)=>d("sampleBRDFTexture","v4",[u(n),u(e),m(t)]),T=(n,e,t)=>d("computeHorizonFade","f",[$(n),$(e),u(t)]),D=n=>d("getMips","v2",[u(n)]),C=n=>d("getEnvMapUV","v2",[$(n)]),P=(n,e,t)=>d("getUVFromMips","v2",[u(n),m(e),m(t)]),N=(n,e)=>d("getUVBoxFromMips","v4",[u(n),m(e)]),M=(n,e,t,r,a)=>d("sampleMipMapRoughness","v4",[m(n),u(e),u(t),c(r),c(a)]),b=(n,e,t,r,a)=>d("texture2DBilinearFromRGBEwBox","v4",[c(n),(n=>s.parameterV4(n))(e),m(t),m(r),m(a)]),w=(n,e)=>d("correctParallaxFinite","v3",[$(n),$(e)]),U=(n,e)=>d("correctParallax","v3",[$(n),$(e)]),z=(n,e,t)=>d("FresnelSchlick","v3",[$(n),$(e),u(t)]),V=n=>d("SpecGlossEnergyConservationTerm","f",[$(n)]),F=(n=null,e=!1)=>{var t={name:n,constant:e};return o.float(t)},R=(n=null)=>{var e={name:n,constant:!0};return o.float(e)},A=(n=null,e="",t=0)=>{var r={name:n,addressSpace:e,size:t};return o.vec2(r)},I=(n=null,e=!1,t=0)=>{var r={name:n,constant:e,size:t};return o.vec3(r)},L=(n=null,e=!1,t=0)=>{var r={name:n,constant:e,size:t};return o.vec4(r)};let B,k;{let e=function(n){return`      \n                ${n.sslreflection||n.sslrefraction||n.useSSAO?f({uniformName:"invScreenSize",uniformType:"v2"}):i}\n                ${n.sslreflection?f({uniformName:"reflectionColorTexture",uniformType:"t2"}):i}\n                ${n.sslrefraction?f({uniformName:"refractionColorTexture",uniformType:"t2"}):i}\n                ${n.useSSAO?`\n                    ${f({uniformName:"aoTexture",uniformType:"t2"})}\n                    ${f({uniformName:"aoParams",uniformType:"v2"})}\n                    `:i}\n                \n                ${f({uniformName:"precomputedTexture",uniformType:"t2"})}\n                ${R("oneOverMax16int")} = 0.000015259021896696422;\n\n                ${p("unpackFrom16","f",[m("pack")])}{\n                    return 255.0 * oneOverMax16int * (256.0 * pack.x + pack.y);\n                }\n                \n                ${R("E_130_OVER_258")}  = 0.50387596899;\n                ${R("E_128_OVER_258")}  = 0.496124031;\n                ${R("E_1_OVER_128")}  = 0.0078125;\n                ${A("PRECOMPUTED_TEXTURE_LOWER_NEAREST","private")} = ${A()}(1e-2, 0.5 * E_1_OVER_128);\n                ${A("PRECOMPUTED_TEXTURE_UPPER_NEAREST","private")} = ${A()}(1.0 - 0.5 * E_1_OVER_128);\n                \n                // contains G * pow5(1 - VoH) on xy and G * (1 - pow5(1 - VoH)) on zw for the GGX BRDF\n                ${A("PRECOMPUTED_TEXTURE_1","private")}  = E_130_OVER_258 * ${A()}(0.0,1.0);\n                // Contains G of the Beckmann BRDF on xy and G of the Ashikmin BRDF on zw\n                ${A("PRECOMPUTED_TEXTURE_2","private")}  = E_130_OVER_258 * ${A()}(1.0,1.0);\n                // Contains G of the GGX BRDF on xy and G of the Estevez Kulla BRDF on zw\n                ${A("PRECOMPUTED_TEXTURE_3","private")}  = E_130_OVER_258 * ${A()}(0.0,0.0);\n                ${p("sampleBRDFTexture","v4",[u("NdotV"),u("roughness"),m("offset")])}{\n                    ${A("uv")} = E_128_OVER_258 * clamp(${A()}(NdotV,roughness), PRECOMPUTED_TEXTURE_LOWER_NEAREST, PRECOMPUTED_TEXTURE_UPPER_NEAREST) + offset;\n                    return ${l.sample2DTexture("precomputedTexture","uv")};\n                }\n\n            `},r=function(n){return`   \n            ${f({uniformName:"combine",uniformType:"i"})}      \n            ${f({uniformName:"reflectivity",uniformType:"f"})}\n            ${f({uniformName:"reflectivityEnvMap",uniformType:"t2"})}\n\n            ${p("sampleReflectivityEnvMap","v3",[$("reflectVec"),$("color")])}{\n                ${I("endColor")};\n                ${F("probeR")} = INV_PI * acos( reflectVec.z ) / length(reflectVec.xy);\n                ${I("fetchedColor")} = ${l.sample2DTexture("reflectivityEnvMap","0.5 * (probeR * reflectVec.xy + 1.0)")}.xyz;\n                ${I("mapColor")}  = ${d("convertToLinear","v3",[$("fetchedColor")])};\n                if ( ${h("combine")} == 1 ) {\n\n                    endColor = mix( color, mapColor,  ${h("reflectivity")} );\n\n                } else if ( ${h("combine")} == 2 ) {\n\n                    endColor = color + mapColor * ${h("reflectivity")};\n\n                } else {\n\n                    endColor = mix( color, color * mapColor, ${h("reflectivity")} );\n\n                }\n                return endColor;\n            }\n        `},a=function(n){if(n.envMapHDR)var e=function(n){if(n.map&&n.map.hdr){var e=n.map.width,t=n.map.height;return n.map.image&&(e=n.map.image.width,t=n.map.image.height),[parseInt(e),parseInt(t)]}return[2048,1024]},t=1,r=1,a=function(n){return n.envMap&&n.envMap.hdr&&n.envMap.image?(t=n.envMap.width,r=n.envMap.height,n.envMap.image&&(t=n.envMap.image.width,r=n.envMap.image.height),[parseInt(t),parseInt(r)]):[2048,1024]},o=function(n){var e=n.envMipMap[1],r=1;return e&&(r=e.image?parseInt(e.image.width)/t:parseInt(e.width)/t),r};function s(e){return`\n                ${n.envMapRGBHDR?`${e} = ${l.sample2DTexture("map0","uv")};\n                    ${n.envMapRGBsRGB?`${e}  *= ${L()}(${e} .xyz, 1.0);`:i}\n                    `:`${e}  = ${d("texture2DBilinearFromRGBE","v4",[c("map0"),m("uv"),m("hdrSize"),m("hdrTexelSize")])};`}\n                `}function g(e){return`\n                ${n.nonRepeatIBLSampling?`uvAtlas = ${L()}(${P("atlasLevel","uv","mipsTexelSize")}, uv1.zw);`:`uvAtlas = ${N("atlasLevel","mipsTexelSize")};`}\n                ${e} = ${b("map1","uvAtlas","uv","mipsSize","mipsTexelSize")};\n                `}return`   \n                ${f({uniformName:"envMap",uniformType:"t2"})}\n                ${f({uniformName:"envMap2",uniformType:"t2"})}\n                ${f({uniformName:"ambienceMatrix",uniformType:"m4"})}\n                ${f({uniformName:"envMapExposureSpecular",uniformType:"f",defaultValue:1})}\n                ${f({uniformName:"envMapExposureDiffuse",uniformType:"f",defaultValue:1})}\n                ${n.envMapHDR?`\n                    ${f({uniformName:"mapHDRSize",uniformType:"v2",functionLoad:e,functionContext:"material"})}\n                    ${f({uniformName:"envMapHDRSize",uniformType:"v2",functionLoad:a,functionContext:"material"})}\n                    ${f({uniformName:"envMapHDRToMipsRatio",uniformType:"f",functionLoad:o,functionContext:"material"})}\n\n                    ${A("hdrSize","private")};\n                    ${A("hdrTexelSize","private")};\n                    ${A("mipsSize","private")};\n                    ${A("mipsTexelSize","private")};\n                    `:i}\n                \n                ${p("computeHorizonFade","f",[$("R"),$("N"),u("roughness")])}{\n                    ${F("coeff")}  = mix(0.5, 1.0, 1.0 - ${(n=>d("pow2","f",[u(n)]))("roughness")});\n                    return clamp(1.0 + coeff * dot(R, N), 0.0, 1.0);\n                }\n\n                ${p("getMips","v2",[u("roughnessValue")])}{\n                    ${F("mipValue")}  = max(6.0 + 1.15 * log2(roughnessValue + 0.0000001), 0.0);\n                    ${F("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${A()}(mipValue,mipCoef);\n                }\n\n                ${p("getMipsLinearInverted","v2",[u("roughnessValue")])}{\n                    ${F("mipValue")}  = max(5.0 * (1.0 - roughnessValue) + 1.0, 0.0);\n                    ${F("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${A()}(mipValue,mipCoef);\n                }\n\n                ${p("getMipsLinear","v2",[u("roughnessValue")])}{\n                    ${F("mipValue")}  = max(5.0 * (roughnessValue) + 1.0, 0.0);\n                    ${F("mipCoef")}  = fract(mipValue);\n                    if (mipValue > 6.0) {\n\n                        mipValue = 6.0;\n                        mipCoef = 1.0;\n                    }\n                    return ${A()}(mipValue,mipCoef);\n                }\n\n                ${p("getEnvMapUV","v2",[$("vector")])} {\n                    ${I("tmpVector")} = normalize((${h("ambienceMatrix")}*${L()}(vector,0.0)).xyz);\n                    if (abs(tmpVector.x) < 1e-6) {\n                        tmpVector.x = 1e-6;\n                    }\n                    ${F("phi")} = ${n.WebGPU?"atan2":"atan"}(tmpVector.y, tmpVector.x);\n                    ${F("theta")} = acos(tmpVector.z);\n                    return ${A()}(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);\n                }\n\n                ${p("getUVFromMips","v2",[u("mip"),m("uv"),m("texelSize")])} {\n                    ${F("t10")}  = pow(2.0, -floor(log2(mip + 1.0)));\n                    ${F("t11")}  = 2.0 - (mip + 2.0) * t10;\n                    ${F("t12")}  = 0.5 * t10;\n                    return ${A()}(t11 + 1.5 * texelSize.x + (2.0 * t12 - 3.0 * texelSize.x) * uv.x, t12 + 1.5 * texelSize.x + (t12 - 3.0 * texelSize.x) * uv.y);\n                }\n\n                ${p("getUVBoxFromMips","v4",[u("mip"),m("texelSize")])} {\n                    ${F("t10")}  = pow(2.0, -floor(log2(mip + 1.0)));\n                    ${F("t11")}  = 2.0 - (mip + 2.0) * t10;\n                    ${F("t12")}  = 0.5 * t10;\n                    return ${L()}(t11, t12 + 1.5 * texelSize.x , 2.0 * t12, t12 - 3.0 * texelSize.x);\n                }\n\n                ${p("sampleMipMapRoughness","v4",[m("uv"),u("mip"),u("coef"),c("map0"),c("map1")])} {\n                    ${L("color1")};\n                    ${L("color2")};\n                    ${L("uvAtlas")};\n                    ${F("atlasLevel")};\n                    ${n.envMapHDR?`\n                        ${n.WebGPU?`\n                            ${L("colorBase")};\n                            ${L("colorFromAtlas")};\n                            ${s("colorBase")}\n                            atlasLevel  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                            ${g("colorFromAtlas")}\n                            if (mip < 1.0) {\n                                color1 = colorBase;\n                            } else {\n                                color1 = colorFromAtlas;\n                            }\n                            `:`\n                            if (mip < 1.0) {                     \n                                ${s("color1")}\n                            } else {\n                                atlasLevel = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                                ${g("color1")}\n                                \n                            }\n                            `}                   \n                        atlasLevel  = clamp(floor(mip), 0.0, 5.0);\n                        ${g("color2")}\n\n                        return mix(color1, color2, coef);\n                        `:`return ${l.sample2DTexture("map1","uv")};`}\n                }\n\n                ${n.useFiniteEnvMap?`\n                    ${f({uniformName:"sphereCenter",uniformType:"v3"})}\n                    ${f({uniformName:"projectionCenter",uniformType:"v3"})}\n                    ${f({uniformName:"sphereRadius",uniformType:"f"})}\n\n                    ${p("correctParallaxFinite","v3",[$("rayDir"),$("rayOrig")])}{\n                        ${F("t")}  = 0.0;\n                        ${I("dist")}  = rayOrig - ${h("sphereCenter")};\n                        ${F("B")}  = 2.0*dot(rayDir, dist);\n                        ${F("C")}  = dot(dist, dist) - ${h("sphereRadius")}*${h("sphereRadius")};\n                        ${F("disc")}  = B*B - 4.0*C;\n                        if (disc < 0.0) {\n                            t = -1.0;\n                        } else {\n                            t = (-B + sqrt(disc)) / 2.0; \n                        }\n                        ${I("hitPos")}  = rayOrig + t*rayDir;\n                        ${I("sn")}  = (hitPos - ${h("projectionCenter")});\n                        return normalize(sn);\n                    }\n                    `:i}\n            `},o=function(n){return`\n            ${f({uniformName:"envMapSheen",uniformType:"t2"})}\n            \n            ${p("sampleMipMapRoughnessSheen","v4",[m("uv"),u("mip"),u("coef"),c("map1")])} {\n                ${L("color1")} ;\n                ${L("color2")} ;\n\n                ${L("uv1")} ;\n                ${L("uv2")} ;\n\n                ${F("level1")}  = clamp(floor(mip) - 1.0, 0.0, 4.0);\n                ${n.nonRepeatIBLSampling?`\n                    ${A("uvFromMips")} = ${P("level1","uv","mipsTexelSize")};\n                    uv1.x = uvFromMips.x;\n                    uv1.y = uvFromMips.y;\n                    `:`uv1 = ${N("level1","mipsTexelSize")};`}\n                color1 = ${b("map1","uv1","uv","mipsSize","mipsTexelSize")};\n\n                ${F("level2")}  = clamp(floor(mip), 0.0, 5.0);\n                ${n.nonRepeatIBLSampling?`\n                    ${A("uv2FromMips")} = ${P("level2","uv","mipsTexelSize")};\n                    uv2.x = uv2FromMips.x;\n                    uv2.y = uv2FromMips.y;\n                    `:`uv2 = ${N("level2","mipsTexelSize")};`}\n                color2 = ${b("map1","uv2","uv","mipsSize","mipsTexelSize")};\n\n                return mix(color1, color2, coef);\n            }\n        `},s=function(n){return`   \n            ${f({uniformName:"reflectionProbeProxyMin",uniformType:"v3"})} \n            ${f({uniformName:"reflectionProbeProxyMax",uniformType:"v3"})}\n            ${f({uniformName:"reflectionProbePos",uniformType:"v3"})}\n\n            ${p("correctParallax","v3",[$("worldPos"),$("reflectVec")])} {\n\n                ${I("rbmax")}  = (${h("reflectionProbeProxyMax")} - worldPos) / reflectVec;\n                ${I("rbmin")}  = (${h("reflectionProbeProxyMin")} - worldPos) / reflectVec;\n\n                ${I("rbminmax")}  = max(rbmax, rbmin);\n\n                ${F("distance")}  = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n                ${I("intersectPos")}  = worldPos + reflectVec * distance;\n\n                return normalize(intersectPos - ${h("reflectionProbePos")});\n            }\n        `};B=function(i){let l=`\n                ${e(i)}\n            `;return i.envMap?(l=`\n                    ${l}\n                    ${n._DefaultShaderChunk.rgbe_sample_methods_repeat(i)}\n                    ${a(i)}\n                `,i.sheen&&i.envMapSheen&&(l=`\n                        ${l}\n                        ${o(i)}\n                    `),i.reflectionProbes&&(l=`\n                        ${l}\n                        ${s(i)}\n                    `)):l=`\n                    ${l}\n                    ${(n=>t.addLightUniform(n))({uniformName:"ambientLightColor",uniformType:"v4",materialName:"ambient",materialType:"array"})}\n                `,i.reflectivityEnvMap&&(l=`\n                    ${l}\n                    ${r(i)}\n                `),l}}{let e,t,r=function(e){return` \n\t\t\t\t${I("ambientTerm")}  = ${v("ambientLightColor")}.xyz;\n                ${e.invisiblePlaneMaterial?`\n                    ambientTerm = ${I()}(${x("ambientTerm")});\n                    lightNormalizationFactor += ambientTerm;\n                    `:i}\n\t\t\t\t${I("ambientColor")}  = albedo;\n\t\t\t\t${e.subsurface?"ambientColor *= materialData.scatteringColor;":i}\n                ${e.sslreflection||e.sslrefraction?`\n                    ${I("specularColor")}  = ${I()}(0.0);\n                    ${F("NdotV")}  = dot(surfaceData.viewNormal, surfaceData.view);\n                    `:i}\n                ${e.sslreflection?`\n                    ${L("preCompGGX")}  = ${_("NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_1")};\n                    ${I("GFresnelVoH")}  = materialData.sr0Color* ${y("preCompGGX.xy")} + materialData.sr90Color * ${y("preCompGGX.zw")};\n                    ${L("ssrColor")}  = ${l.sample2DTexture("reflectionColorTexture",`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                    specularColor += GFresnelVoH * ssrColor.w * ssrColor.xyz; \n                    `:i}\n                ${e.sslrefraction&&e.useTransparency?`\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                        ${A("preCompRefraction")}  = ${_("-NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${F("GRefract")}  = ${y("preCompRefraction")};\n                        ${L("ssrefractionColor")}  = ${l.sample2DTexture("refractionColorTexture",`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                        ${I("refractionFresnel")}  = ${z("materialData.specularBlendingSR0",`${I()}(1.0)`,"NdotV")};\n                        ${I("refractColorFactor")} = GRefract * materialData.transparentColor * (1.0 - materialData.specularContribution * ${x("refractionFresnel")});\n                        specularColor += refractColorFactor * ssrefractionColor.w * ssrefractionColor.xyz;\n                    } \n                    `:i}\n                ${e.lightMap?`\n                    ${1===e.lightMapMode?`${S("out0")} += ${L()}(aoValue * ambientColor, 0.0);`:`${S("out0")} += ${L()}(aoValue * ambientColor * ambientTerm, 0.0);`}\n                    `:`${S("out0")} += ${L()}(ambientColor * ambientTerm, 0.0);`}         \n                ${e.sslreflection||e.sslrefraction?`\n                    ${S("out0")} += ${L()}(specularColor, 0.0);\n                    `:i}   \n                ${e.invisiblePlaneMaterial?`\n                    if (length(lightNormalizationFactor) < 1e-6) {\n                        ${S("out0")} = ${L()}(1.0, 1.0, 1.0, ${S("out0")}.a);\n                    } else {\n                        ${S("out0")} /= ${L()}(lightNormalizationFactor, 1.0);\n                    }\n                    `:i}\n            `},a=function(n){return`\n            ${F("NdotV")} = dot(surfaceData.viewNormal, surfaceData.view);\n            ${I("specularIBLValue")} = ${I()}(0.0);\n            ${I("diffuseIBLValue")} = ${I()}(0.0);\n            ${n.envMap?`\n                ${I("cameraToVertex")} = normalize( ${I()}( (${L()}( -surfaceData.view, 0.0 ) * ${g("viewMatrix")}).xyz ) );\n                ${I("worldVertexNormal")} = normalize( ${I()}( (${L()}( viewNormal, 0.0 ) * ${g("viewMatrix")}).xyz ) );\n                ${I("reflectVec")} = ${I()}(0.0);\n                ${A("reflectionUV")} = ${A()}(0.0);\n                \n                ${F("expoSpecular")} = ${h("envMapExposureSpecular")};\n                ${F("expoDiffuse")} = ${h("envMapExposureDiffuse")};\n                `:`\n                ${L("IBLColor")} = ${v("ambientLightColor")};\n                `}\n        `},o=function(n){return`\n                ${n.invisiblePlaneMaterial?`\n                    diffuseIBLValue = ${I()}(${x("diffuseIBLValue")});\n                    lightNormalizationFactor += diffuseIBLValue;\n                    `:i}\n                ${I("totalIBLValue")}  = specularIBLValue + diffuseIBLValue;\n                ${n.lightMap?`\n                    ${1===n.lightMapMode?"totalIBLValue *= clamp(aoValue, 0.0, 1.0);":"totalIBLValue *= aoValue;"}\n                    `:i}\n                ${S("out0")} += ${L()}(totalIBLValue, 0.0);\n                ${n.invisiblePlaneMaterial?`\n                    if (length(lightNormalizationFactor) < 1e-6) {\n                        ${S("out0")} = ${L()}(1.0, 1.0, 1.0, gl_FragColor.a);\n                    } else {\n                        ${S("out0")} /= ${L()}(lightNormalizationFactor, 1.0);\n                    }\n                    `:i}\n            `},s=function(e){return`\n                \n                ${F("hOcclusion")}  = 1.0;\n                ${e.envMap?`\n                    ${A("mips")}  = ${D("materialData.roughness")};\n                    ${e.reflectionProbes?`reflectVec = ${U("surfaceData.worldPosition","reflectVec")};`:i}\n                    ${e.useFiniteEnvMap?`reflectVec = ${w("reflectVec","surfaceData.worldPosition")};`:i}\n                    reflectionUV = ${C("reflectVec")};\n                    ${L("cubeColor")} = expoSpecular * ${M("reflectionUV","mips.x","mips.y","envMap","envMap2")};\n                    ${e.normalMap?`\n                        hOcclusion  = ${T("reflectVec","worldVertexNormal","materialData.roughness")};\n                        hOcclusion *= hOcclusion;\n                        `:i}\n                    `:`             \n                    ${L("cubeColor")} = IBLColor;\n                    `}\n                ${L("preCompGGX")}  = ${_("NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_1")};\n                ${I("GFresnelVoH")}  = materialData.sr0Color * ${y("preCompGGX.xy")} + materialData.sr90Color * ${y("preCompGGX.zw")};         \n                specularIBLValue = cubeColor.xyz * GFresnelVoH;\n                ${e.sslreflection?`\n                    ${L("ssrColor")}  = ${l.sample2DTexture("reflectionColorTexture",`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                    specularIBLValue = mix(specularIBLValue, GFresnelVoH * ssrColor.xyz, ssrColor.w);\n                    `:i}\n                specularIBLValue *= hOcclusion;\n                ${e.sslrefraction&&e.useTransparency?`\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                        ${e.envMap?`\n                            ${I("refractVec")}  = refract(cameraToVertex, surfaceData.worldNormal, ${e.thinWalled?"1.0":"1.0/materialData.adjustedIoR"});\n                            ${e.reflectionProbes?`refractVec = ${U("surfaceData.worldPosition","refractVec")};`:i}\n                            ${e.useFiniteEnvMap?`refractVec = ${w("refractVec","surfaceData.worldPosition")};`:i}\n                            ${A("refractionUV")}  = ${C("refractVec")};\n                            ${L("cubeRefractColor")}  = expoSpecular * ${M("refractionUV","mips.x","mips.y","envMap","envMap2")};\n                            `:`\n                            ${L("cubeRefractColor")}  = IBLColor;\n                            `}\n                        \n                        ${A("preCompRefraction")}  = ${_("-NdotV","materialData.roughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${F("GRefract")}  = ${y("preCompRefraction")};\n                        ${L("ssrefractionColor")}  = ${l.sample2DTexture("refractionColorTexture",`${n._DefaultShaderChunk.getScreenUVs(e)}`)};\n                        ${I("refractionColor")} = mix(cubeRefractColor.xyz, ssrefractionColor.xyz, ssrefractionColor.w);\n                        ${e.dspbr?`\n                            ${I("refractionFresnel")}  = ${z("materialData.specularBlendingSR0",`${I()}(1.0)`,"NdotV")};\n                            ${F("fTransRefraction")}  = 1.0 - materialData.specularContribution * ${x("refractionFresnel")};`:`\n                            ${I("refractionFresnel")} = ${z("materialData.sr0Color","materialData.sr90Color","NdotV")};\n                            ${F("fTransRefraction")} = 1.0 -  ${x("refractionFresnel")};\n                            `}\n                        refractionColor *= GRefract * materialData.transparentColor * fTransRefraction;\n                        ${e.subsurface?`          \n                            ${e.thicknessBasedTransmittance?"refractionColor *= materialData.transmittanceColor;":`          \n                                ${e.sssLUT?`\n                                    ${F("transS")}  = ${x("maxTranslucencyDepth")}/ 15.0;\n                                    `:`\n                                    ${F("transS")} = 1.0 / ${x("absorptionCoefficients")};\n                                    `}\n                                refractionColor *= ${d("GetTransmittance","v3",[u("transS")])};\n                                `}\n                            `:i}\n                        specularIBLValue += refractionColor;\n                        \n                    }\n                    `:i}\n            `},$=function(n){return`\n                ${L("diffuseTexelColor")} = ${L()}(0.0);\n                ${n.envMap?`\n                    ${A("normalUV")} = ${C("normalize(surfaceData.worldNormal)")};\n                    ${n.envMapDiffuse?`${F("diffMip")} = 6.0;`:`${F("diffMip")} = 5.0;`}\n                    ${L("diffUVBox")};\n                    ${n.nonRepeatIBLSampling?`diffUVBox = ${L()}(${P("diffMip","normalUV","mipsTexelSize")}, diffUVBox.zw);`:`diffUVBox = ${N("diffMip","mipsTexelSize")};`}\n                    diffuseTexelColor = expoDiffuse * ${b("envMap2","diffUVBox","normalUV","mipsSize","mipsTexelSize")};\n                    `:"\n                    diffuseTexelColor = IBLColor;\n                    "}\n                ${n.dspbr?"\n                    specularIBLValue += diffuseTexelColor.rgb * materialData.specularEnergyConservationConstant;\n                    diffuseTexelColor *= materialData.diffuseEnergyConservationConstant;\n                    ":`diffuseTexelColor *= ${V("GFresnelVoH")};`}\n                diffuseIBLValue = materialData.diffuseColor * diffuseTexelColor.xyz;\n            `},p=function(n){return`\n                ${s(n)}\n                ${$(n)}\n            `};{let n=function(n){return`\n                    ${I("diffuseInvIBLValue")} = ${I()}(0.0);\n                    ${!n.dspbrWithTranslucency||n.subsurface&&!n.thicknessBasedTransmittance?i:`\n                        if (materialData.translucency > 1e-6) {\n                            ${n.envMap?`\n                                ${A("normalInvUV")}  = ${C("normalize(-surfaceData.worldNormal)")};\n                                ${L("diffuseInvTexelColor")}  = expoDiffuse * ${b("envMap2","diffUVBox","normalInvUV","mipsSize","mipsTexelSize")};\n                                `:`\n                                ${L("diffuseInvTexelColor")} = IBLColor;\n                                `}\n                            diffuseInvIBLValue = materialData.translucencyColor * diffuseInvTexelColor.rgb * materialData.diffuseEnergyConservationConstant;\n                        }\n                        `}\n                `},t=function(n){return`   \n                    ${n.specgloss?"diffuseIBLValue *= materialData.scatteringColor;":`\n                        ${I("baseDiffuseIBLValue")}  = diffuseIBLValue;\n                        ${n.dspbrWithTranslucency?`\n                            diffuseIBLValue = mix(diffuseIBLValue, materialData.scatteringColor * baseDiffuseIBLValue, materialData.translucency);\n                            ${n.thicknessBasedTransmittance?"\n                                diffuseIBLValue = mix(diffuseIBLValue,  materialData.transmittanceColor * diffuseInvIBLValue, materialData.translucency);\n                                ":i}\n                            `:i}\n                        diffuseIBLValue = mix(diffuseIBLValue, materialData.scatteringColor * baseDiffuseIBLValue, materialData.transparency);\n                        `} \n                `},r=function(n){return`            \n                    ${n.dspbrWithTranslucency?"diffuseIBLValue = mix(diffuseIBLValue, diffuseInvIBLValue, materialData.translucency);":i}\n                `};e=function(e){return e.subsurface?`\n                        ${n(e)}\n                        ${t(e)}\n                    `:`\n                    ${n(e)}\n                    ${r(e)}\n                `}}{let n=function(n){return`\n                    ${F("NdotVcoating")}  = dot(surfaceData.clearCoatNormal, surfaceData.view);\n                    ${n.envMap?`\n                        ${I("reflectVecCoating")}  = reflect( cameraToVertex, surfaceData.clearCoatWorldNormal );\n                        ${A("mipsC")}  = ${D("materialData.clearCoatRoughness")};\n                        ${n.reflectionProbes?`reflectVecCoating = ${U("surfaceData.worldPosition","reflectVecCoating")};`:i}\n                        ${n.useFiniteEnvMap?`reflectVecCoating = ${w("reflectVecCoating","surfaceData.worldPosition")};`:i}\n                        ${A("reflectionUVcoating")}  = ${C("reflectVecCoating")};\n                        ${L("cubeColorcoating")} = expoSpecular * ${M("reflectionUVcoating","mipsC.x","mipsC.y","envMap","envMap2")};\n                        ${n.clearCoatNormalMap?`\n                            ${F("chOcclusion")} = ${T("reflectVecCoating","worldVertexNormal","materialData.clearCoatRoughness")};\n                            chOcclusion *= chOcclusion;\n                            cubeColorcoating *= chOcclusion;\n                            `:i}   \n                        `:`\n                        ${L("cubeColorcoating")} = IBLColor;\n                        `}            \n                    ${L("precompCoat")}  = ${_("NdotVcoating","materialData.clearCoatRoughness","PRECOMPUTED_TEXTURE_1")};\n                    ${I("GFresnelVoHCoat")}  = ${y("precompCoat.xy")} * materialData.clearCoatSR0Color + ${y("precompCoat.zw")} * materialData.clearCoatSR90Color;\n                    ${I("clearCoatIBLValue")} = cubeColorcoating.xyz * GFresnelVoHCoat;\n                    ${n.dspbr?`\n                        ${I("coatingFresnel")}  = ${z("materialData.clearCoatSR0Color","materialData.clearCoatSR90Color",`${(n=>`max(${n}, 0.0)`)("NdotVcoating")}`)};\n                        ${F("energyCoating")}  = 1.0 - materialData.clearCoat* ${x("coatingFresnel")};\n                        `:`\n                        ${F("energyCoating")} = ${V("GFresnelVoHCoat")};\n                        `}\n                    specularIBLValue *= energyCoating;\n                    diffuseIBLValue *= energyCoating;\n                    specularIBLValue += clearCoatIBLValue * materialData.clearCoat;\n                `};t=function(e){return e.clearCoat?n(e):i}}let f,R,B=function(n){return n.envMap?n.anisotropy?`\n                    ${I("bitangent")}  = normalize(${I()}(${L()}(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal, 0.0) * ${g("viewMatrix")}));\n                    ${I("anisotropicTangent")}  = cross(bitangent, -cameraToVertex);\n                    ${I("anisotropicNormal")}  = cross(anisotropicTangent, bitangent);\t\t\n                    ${I("bentNormal")}  = normalize(mix(surfaceData.worldNormal, anisotropicNormal, 0.22*materialData.anisotropy));\n                    reflectVec = reflect( cameraToVertex, bentNormal );\n                `:"\n                reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );             \n            ":i},E=function(n){return n.envMap&&n.anisotropy?`\n                    reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );\n                    ${n.reflectionProbes?`reflectVec = ${U("surfaceData.worldPosition","reflectVec")};`:i}\n                    ${n.useFiniteEnvMap?`reflectVec = ${w("reflectVec","surfaceData.worldPosition")};`:i}        \n                    reflectionUV = ${C("reflectVec")};   \n                `:i};{let n=function(n){return`             \n                    ${F("NdotVMetalFlakes")}  = dot(metalFlakes.flakesNormal, surfaceData.view);\n                    ${n.envMap?`\n                        ${I("reflectVecMetalFlakes")}  = reflect( cameraToVertex, metalFlakes.flakesWorldNormal );\n                        ${A("mipsMetalFlakes")}  = ${D("metalFlakes.flakesRoughness")};\n                        ${n.reflectionProbes?`reflectVecMetalFlakes = ${U("surfaceData.worldPosition","reflectVecMetallicFlakes")};`:i}\n                        ${n.useFiniteEnvMap?`reflectVecMetalFlakes = ${w("reflectVecMetalFlakes","surfaceData.worldPosition")};`:i}                    \n                        ${A("reflectionUVMetalFlakes")}  = ${C("reflectVecMetalFlakes")};\n                        ${L("cubeColorMetalFlakes")} = expoSpecular * ${M("reflectionUVMetalFlakes","mipsMetalFlakes.x","mipsMetalFlakes.y","envMap","envMap2")};\n                        ${F("mFhOcclusion")}  = ${T("reflectVecMetalFlakes","worldVertexNormal","metalFlakes.flakesRoughness")};\n                        mFhOcclusion *= mFhOcclusion;\n                        cubeColorMetalFlakes *= mFhOcclusion;\n                        `:`\n                        ${L("cubeColorMetalFlakes")} = IBLColor;\n                        `}\n                    ${L("precompMetalFlakes")}  = ${_("NdotVMetalFlakes","metalFlakes.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                    ${I("GFresnelVoHMetalFlakes")}  = ${y("precompMetalFlakes.xy")} * metalFlakes.flakesSR0Color ;             \n                    ${I("metalFlakesIBLValue")} = cubeColorMetalFlakes.xyz * GFresnelVoHMetalFlakes;       \n                    ${F("energyMetalFlakes")}  = ${V("GFresnelVoHMetalFlakes")};\n                    diffuseIBLValue *= energyMetalFlakes;\n                    specularIBLValue *= energyMetalFlakes;\n                    specularIBLValue += mFhOcclusion*metalFlakesIBLValue;\n                `},e=function(n){return`             \n                    ${F("NdotVMetal")} = NdotV;\n                    ${n.envMap?`\n                        ${A("mipsMetal")} = ${D("metal.flakesRoughness")};\n                        ${A("reflectionUVMetal")} = reflectionUV;\n                        ${L("cubeColorMetal")} = expoSpecular * ${M("reflectionUVMetal","mipsMetal.x","mipsMetal.y","envMap","envMap2")};\n                        `:`\n                        ${L("cubeColorMetal")} = IBLColor;\n                        `}\n                    ${L("precompMetal")}  = ${_("NdotVMetal","metal.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                    ${I("GFresnelVoHMetal")}  = ${y("precompMetal.xy")} * metal.flakesSR0Color ;                   \n                    ${I("metalIBLValue")} = cubeColorMetal.xyz * GFresnelVoHMetal;\n                    ${F("energyMetal")} = ${V("GFresnelVoHMetal")};\n                    diffuseIBLValue *= energyMetal;\n                    specularIBLValue *= energyMetal;\n                    specularIBLValue += hOcclusion*metalIBLValue;\n                `},t=function(n){return`\n                        ${F("NdotVPearlFlakes")}  = dot(pearlFlakes.flakesNormal, surfaceData.view);\n                        ${n.envMap?`\n                            ${I("reflectVecPearlFlakes")}  = reflect( cameraToVertex, pearlFlakes.flakesWorldNormal );               \n                            ${A("mipsPearl")}  = ${D("pearlFlakes.flakesRoughness")};\n                            ${n.reflectionProbes?`reflectVecPearlFlakes = ${U("surfaceData.worldPosition","reflectVecPearlFlakes")};`:i}\n                            ${n.useFiniteEnvMap?`reflectVecPearlFlakes = ${w("reflectVecPearlFlakes","surfaceData.worldPosition")};`:i}              \n                            ${A("reflectionUVPearlFlakes")}  = ${C("reflectVecPearlFlakes")};\n                            ${L("cubeColorPearlFlakes")} = expoSpecular * ${M("reflectionUVPearlFlakes","mipsPearl.x","mipsPearl.y","envMap","envMap2")};\n                            ${F("pFhOcclusion")}  = ${T("reflectVecPearlFlakes","worldVertexNormal","pearlFlakes.flakesRoughness")};\n                            pFhOcclusion *= pFhOcclusion;\n                            cubeColorPearlFlakes *= pFhOcclusion;\n                            `:"\n                            cubeColorPearlFlakes = IBLColor;\n                            "}\n                        ${L("precompPearlFlakes")}  = ${_("NdotVPearlFlakes","pearlFlakes.flakesRoughness","PRECOMPUTED_TEXTURE_1")};\n                        ${I("GFresnelVoHPearlFlakes")}  = ${y("precompPearlFlakes.xy")} * pearlFlakes.flakesSR0Color ;\n                        ${I("pearlFlakesIBLValue")} = cubeColorPearlFlakes.xyz * GFresnelVoHPearlFlakes;\n                        ${F("energyPearlFlakes")}  = ${V("GFresnelVoHPearlFlakes")};\n                        diffuseIBLValue *= energyPearlFlakes;\n                        specularIBLValue *= energyPearlFlakes;\n                        specularIBLValue += pearlFlakesIBLValue;\n                `},r=function(n){return`\n                    ${I("flakesIBLValue")}  = ${I()}(0.0);\n                    ${n.envMap?`\n                        ${A("mipsDSPBRFlakes")}  = ${D("flakesData.flakesRoughness")};    \n                        `:i}       \n                    if (flakesData.smoothWeight > 0.0) {                \n                        ${n.envMap?`\n                            ${A("reflectionUVSmoothFlakes")}  = reflectionUV;\n                            ${L("cubeColorSmoothFlakes")}  = expoSpecular * ${M("reflectionUVSmoothFlakes","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y","envMap","envMap2")};  \n                            `:`\n                            ${L("cubeColorSmoothFlakes")} = IBLColor;\n                            `}     \n                        ${A("preCompDSPBRSmoothFlakes")}  = ${_("NdotV","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                        ${F("GSmoothFlakes")}  = ${y("preCompDSPBRSmoothFlakes")};\n                        flakesIBLValue += cubeColorSmoothFlakes.xyz * GSmoothFlakes * flakesData.smoothFlakesColor;\n                    }\n                    ${n.dspbrFlakesThreeLayers?`                      \n                        if (flakesData.stochasticWeight > 0.0) {\n                            ${F("NdotVSto")}  = dot(flakesData.stochasticHemisphereFlakesNormal, surfaceData.view);\n                            ${n.envMap?`                      \n                                ${I("worldReflStoFlakes")}  = normalize( ${I()}( ${L()}( flakesData.stochasticHemisphereFlakesReflect, 0.0 ) * ${g("viewMatrix")} ) );\n                                ${n.reflectionProbes?`worldReflStoFlakes = ${U("surfaceData.worldPosition","worldReflStoFlakes")};`:i}\n                                ${n.useFiniteEnvMap?`worldReflStoFlakes = ${w("worldReflStoFlakes","surfaceData.worldPosition")};`:i}\n                                ${A("stoFlakesEnvMapUV")}  = ${C("worldReflStoFlakes")};\n                                ${L("stoFlakesTexelColor")}  = expoSpecular * ${M("stoFlakesEnvMapUV","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y","envMap","envMap2")};\n                                `:`\n                                ${L("stoFlakesTexelColor")} = IBLColor;\n                                `}  \n                            ${A("preCompDSPBRStoFlakes")}  = ${_("NdotVSto","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                            ${F("GStoFlakes")}  = ${y("preCompDSPBRStoFlakes")};\n                            flakesIBLValue += flakesData.stochasticHemisphereFlakesColor * stoFlakesTexelColor.xyz * GStoFlakes;\n                        }\n                        `:i}\n                    ${n.dspbrFlakesOneLayer?i:`\n                        if (flakesData.closeupWeight > 0.0) {\n                            ${F("NdotVClose")}  = dot(flakesData.closeupFlakesNormal, surfaceData.view);\n                            ${n.envMap?`   \n                                ${I("worldReflCloseFlakes")}  = normalize( ${I()}( ${L()}( flakesData.closeupFlakesReflect, 0.0 ) * ${g("viewMatrix")} ) );\n                                ${n.reflectionProbes?`worldReflCloseFlakes = ${U("surfaceData.worldPosition","worldReflCloseFlakes")};`:i}     \n                                ${n.useFiniteEnvMap?`worldReflCloseFlakes = ${w("worldReflCloseFlakes","surfaceData.worldPosition")};`:i}\n                                ${A("closeFlakesEnvMapUV")}  = ${C("worldReflCloseFlakes")};\n                                ${L("closeFlakesTexelColor")}  = expoSpecular * ${M("closeFlakesEnvMapUV","mipsDSPBRFlakes.x","mipsDSPBRFlakes.y","envMap","envMap2")};\n                                ${A("preCompDSPBRCloseFlakes")}  = ${_("NdotVClose","flakesData.flakesRoughness","PRECOMPUTED_TEXTURE_3")}.xy;\n                                `:`\n                                ${L("closeFlakesTexelColor")} = IBLColor;\n                                `}  \n                            ${F("GCloseFlakes")}  = ${y("preCompDSPBRCloseFlakes")};\n                            flakesIBLValue += flakesData.closeupFlakesColor * closeFlakesTexelColor.xyz * GCloseFlakes;\n                        }\n                        `}\n                \n                    diffuseIBLValue *= flakesData.baseWeight;\n                    specularIBLValue *= flakesData.baseWeight;\n                    specularIBLValue += flakesIBLValue;\n                    `};f=function(a){return a.dspbrFlakes?r(a):a.specGlossFlakes?`\n                        ${e(a)}\n                        ${n(a)}\n                        ${a.pearlFlakesActivated?t(a):i}\n                    `:i}}{let e=function(e){return`        \n                    ${e.dspbrWithSheenColorRoughness?`\n                        ${F("sheenRough_IBL")}  = materialData.sheenRoughness;                                             \n                        ${e.dspbrWithSquaredEstevezKullaRoughness?"sheenRough_IBL *= sheenRough_IBL;":i}\n                        `:`${F("sheenRough_IBL")}  = materialData.sheen;`}\n                    ${e.sheenMode===n.SheenMode.SATIN?"sheenRough_IBL = 0.3;":i}\n                    ${e.envMap?`\n                        ${e.sheenMode===n.SheenMode.VELVET||e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                            ${A("mipsF")}  = ${d("getMipsLinearInverted","v2",[u("sheenRough_IBL")])};\n                            `:`\n                            ${A("mipsF")} = ${d("getMipsLinear","v2",[u("sheenRough_IBL")])};\n                            `}\n                        ${L("sheenColor")}  = expoSpecular * ${d("sampleMipMapRoughnessSheen","v4",[m("reflectionUV"),u("mipsF.x"),u("mipsF.y"),c("envMapSheen")])};\n                        `:`\n                        ${L("sheenColor")}  = IBLColor;\n                        `}\n                    ${e.sheenMode===n.SheenMode.VELVET?`\n                        ${A("precompSheen")}  = ${_("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_2")}.zw;\n                        `:`\n                        ${e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                            ${A("precompSheen")}  = ${_("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_3")}.zw;\n                            `:`\n                            ${A("precompSheen")}  = ${_("NdotV","sheenRough_IBL","PRECOMPUTED_TEXTURE_2")}.xy;\n                            `}\n                        `}\n                    ${F("GFab")}  = ${y("precompSheen")};\n                    ${I("sheenIBLValue")} = GFab * sheenColor.rgb;\n                    ${e.dspbrWithSheenColorRoughness?`\n                        ${F("sheenBlending")} = 1.0 - materialData.sheenEnergyConservationConstant;\n                        diffuseIBLValue *= sheenBlending;\n                        specularIBLValue *= sheenBlending;\n                        specularIBLValue +=  materialData.sheen * materialData.sheenColor * sheenIBLValue;\n                        `:`\n                        ${F("sheenBlending")}  = 1.0 - ${(n=>d("pow5","f",[u(n)]))("1.0-materialData.sheen")};\n                        diffuseIBLValue *= PI * sheenBlending * sheenIBLValue + (1.0 - sheenBlending);\n                        `}\n                `};R=function(n){return n.sheen&&n.envMapSheen?e(n):i}}k=function(n){if(!n.envMap&&!n.useIBLColor)return r(n);return`\n                ${a(n)}\n                ${B(n)}\n                ${p(n)}\n                ${E(n)}\n                ${e(n)}\n                ${R(n)}\n                ${f(n)}\n                ${t(n)}\n                ${o(n)}\n            `}}return{getIndirectLightShaders:function(n,e){return n?[B(e),e.shadowMapDebugMaterial?i:k(e)]:[i,i]}}}),define("DS/ShaderBuilders/LineUtils/LineBasicFragmentShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a){"use strict";const o="",i=r.ParameterUtils,s=n=>i.parameterF(n),l=n=>i.parameterRefF(n),u=n=>i.parameter("b",n),m=n=>i.parameterV2(n),$=n=>i.parameterV3(n),c=n=>i.parameterV4(n),p=(n,e,t)=>r.FunctionHandler.declareFunction(n,e,t),d=(n,e,t)=>r.FunctionHandler.callFunction(n,e,t),f=n=>e.addUniform(n),h=n=>{var t={uniformName:n};return e.getUniform(t)},g=(n=null)=>{var e={name:n};return a.bool(e)},v=(n=null)=>{var e={name:n};return a.int(e)},S=(n=null)=>{var e={name:n};return a.float(e)},x=(n=null)=>{var e={name:n};return a.vec2(e)},y=(n=null,e=0)=>{var t={name:n,size:e};return a.vec3(t)},_=n=>t.addVarying(n),T=n=>t.getVarying(n,t.ShaderStages.in);return function(e,t){let r=n._ShaderChunk,i=`\n            ${r.PDSFX_Color_pars_fragment(e)}\n            ${t}\n        `,D="";(e.wideLine||e.dashedLine)&&(e.wideLine&&(i=`\n                    ${i}\n                    ${r.PDSFX_halfWidth_pars_vertex_fragment(e)}\n                `,"round"===e.linejoin&&(i=`\n                        ${i}\n                        ${_({varyingName:"centerJoin",varyingType:"v4"})}\n                        ${_({varyingName:"centerRightJoin",varyingType:"v4"})}\n                        ${_({varyingName:"centerLeftJoin",varyingType:"v4"})}\n\n                        ${p("doCentralJoin",null,[c("iCenterJoin")])} {\n                            ${S("distanceJoin")}  = 0.0;\n                            ${S("varJoinC")}  = 0.0;\n                            if (dot(gl_FragCoord.xy - iCenterJoin.xy, iCenterJoin.zw) <= 0.0) {\n                                return;\n                            }\n                            distanceJoin = length(gl_FragCoord.xy - iCenterJoin.xy) / ${d("getHalfWidth","f",[])};\n                            if (distanceJoin > 1.0) {\n                                discard;\n                            }\n                        }\n\n                        ${p("doSideJoins",null,[c("iCenterRightJoin"),c("iCenterLeftJoin")])} {\n                            ${g("rightJoin")}  = abs(length(fwidth(iCenterRightJoin))) < 1e-2 && dot(gl_FragCoord.xy - iCenterRightJoin.xy, iCenterRightJoin.zw) > 0.0;\n                            ${g("leftJoin")}  =  abs(length(fwidth(iCenterLeftJoin))) < 1e-2 && dot(gl_FragCoord.xy - iCenterLeftJoin.xy, iCenterLeftJoin.zw) > 0.0;\n                            ${S("distanceRight")}  = 0.0;\n                            ${S("distanceLeft")}  = 0.0;\n                            ${S("varJoinR")}  = 0.0;\n                            ${S("varJoinL")}  = 0.0;\n                            if (rightJoin) {\n                                distanceRight = length(gl_FragCoord.xy - iCenterRightJoin.xy) / ${d("getHalfWidth","f",[])};\n                                if (distanceRight > 1.0) {\n                                    discard;\n                                }\n                            }\n                            if (leftJoin) {\n                                distanceLeft = length(gl_FragCoord.xy - iCenterLeftJoin.xy) / ${d("getHalfWidth","f",[])};\n                                if (distanceLeft > 1.0) {\n                                    discard;\n                                }\n                            }\n                        }\n\n                        ${p("doRoundJoins",null,[c("iCenterJoin"),c("iCenterRightJoin"),c("iCenterLeftJoin")])} {\n                            ${g("isOnJoin")}  = abs(length(fwidth(iCenterJoin))) < 1e-2;\n                            if (isOnJoin) {\n                                ${d("doCentralJoin",null,[m("iCenterJoin")])};\n                                return;\n                            }\n                            ${d("doSideJoins",null,[m("iCenterRightJoin"),m("iCenterLeftJoin")])};\n                         }\n                    `,D=`\n                        ${D}\n                        ${d("doRoundJoins",null,[c(T("centerJoin")),c(T("centerRightJoin")),c(T("centerLeftJoin"))])};\n                    `),"round"===e.linecap&&(i=`\n                        ${i}\n                        ${_({varyingName:"infosCenterCap",varyingType:"v4"})}\n                        ${_({varyingName:"centerLeftRight",varyingType:"v4"})}\n\n                        ${p("doLeftCap","b",[u("leftSide"),m("iInfos"),m("iCenterLeft")])} {\n                            ${g("leftCap")}  = leftSide && iInfos.x < 0.0;\n                            if (!leftCap) {\n                                return false;\n                            }\n                            ${S("distanceL")}  = length(gl_FragCoord.xy - iCenterLeft)/${d("getHalfWidth","f",[])};\n                            if (distanceL > 1.0) {\n                                discard;\n                            }\n                            return true;\n                        }\n\n                        ${p("doRightCap","b",[u("rightSide"),m("iInfos"),m("iCenterCap"),m("iCenterRight")])} {\n                            ${g("rightCap")}  = rightSide  && iInfos.x > length(iCenterRight - iCenterCap);\n                            if (!rightCap) {\n                                return false;\n                            }\n                            ${S("distanceR")}  = length(gl_FragCoord.xy - iCenterRight) / ${d("getHalfWidth","f",[])};\n                            if (distanceR > 1.0) {\n                                 discard;\n                            }\n                            return true;\n                        }\n\n                        ${p("doRoundCap",null,[m("iInfos"),m("iCenterCap"),m("iCenterRight"),m("iCenterLeft")])} {\n                            ${g("centerSide")}  = abs(length(fwidth(iCenterCap))) < 1e-2;\n                            ${g("capToCap")}   = abs(fwidth(iInfos.y)) < 1e-2 && iInfos.y > 0.0;\n                            ${g("leftSide")}   = abs(length(fwidth(iCenterLeft))) < 1e-2 ;\n                            ${g("rightSide")}   = abs(length(fwidth(iCenterRight))) < 1e-2 ;\n                            ${g("toTreat")}   = ! (leftSide && rightSide && centerSide) || capToCap;\n                            if (!toTreat) {\n                                return;\n                            }\n                            ${g("leftCap")}   = ${d("doLeftCap","b",[u("leftSide"),m("iInfos"),m("iCenterLeft")])};\n                            ${g("rightCap")}   = ${d("doRightCap","b",[u("rightSide && centerSide"),m("iInfos"),m("iCenterCap"),m("iCenterRight")])};\n                        }\n                    `,D=`\n                        ${D}\n                        ${d("doRoundCap",null,[m(T("infosCenterCap.xy")),m(T("infosCenterCap.zw")),m(T("centerLeftRight.zw")),m(T("centerLeftRight.xy"))])};\n                    `)),e.dashedLine)&&(i=`\n                    ${i}          \n                    ${f({uniformName:"scale",uniformType:"f"})}\n                    ${f({uniformName:"totalSize",uniformType:"f"})}\n                    ${f({uniformName:"patternOffset",uniformType:"f"})}\n                    ${e.patternSize?f({uniformName:"dashPattern",uniformType:"fv4",size:Math.ceil(e.patternSize/4)}):""}\n                    ${_({varyingName:"vLineDistance",varyingType:"v2"})}\n                    ${e.worldSizePattern?`\n                            ${e.worldSizePattern2?_({varyingName:"vPatternStartEnd",varyingType:"v2"}):o}\n                            ${_({varyingName:"vPointCurr",varyingType:"v3"})}\n                            ${e.wideLine?`\n                                ${_({varyingName:"vPointNext",varyingType:"v3"})}\n                                ${_({varyingName:"vPointPrec",varyingType:"v3"})}\n                                ${_({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                                ${_({varyingName:"vConstantCurr",varyingType:"v3"})}\n                                ${_({varyingName:"vConstantNext",varyingType:"v3"})}\n                                ${_({varyingName:"vConstantPrec",varyingType:"v3"})}\n                                `:""}\n                            \n                            ${p("getDistance","f",[$("pointCurr"),$("next"),$("prev")])}{\n                                ${y("resPoint")}  = ${y()}(0.0);\n                                ${y("direction")}  = next-prev;\n                                ${S("lxy")}  = length(direction.xy);\n                                ${x("dirXY")}  = ${d("vNormalize","v2",[m("direction.xy")])};\n                                ${S("dotVal")}  = dot(pointCurr.xy - prev.xy, dirXY);\n                                resPoint.x = dotVal * dirXY.x;\n                                resPoint.y = dotVal * dirXY.y;\n                                resPoint.z = length(resPoint.xy) / lxy * direction.z;\n                                return clamp(length(resPoint), 0.0, length(direction));\n                            }\n\n                            ${p("getDistance","f",[$("pointCurr"),$("next"),$("prev"),$("origin")])}{\n                                ${y("resPoint")}  = ${y()}(0.0);\n                                ${y("direction")}  = next-prev;\n                                ${S("lxy")}  = length(direction.xy);\n                                ${x("dirXY")} = ${d("vNormalize","v2",[m("direction.xy")])};\n                                ${S("dotVal")}  = dot(pointCurr.xy - origin.xy, dirXY);\n                                resPoint.x = dotVal * dirXY.x;\n                                resPoint.y = dotVal * dirXY.y;\n                                resPoint.z = length(resPoint.xy) / lxy * direction.z;\n                                return clamp(length(resPoint), 0.0, length(direction));\n                            }\n                        `:`              \n                            ${e.wideLine?`\n                                ${_({varyingName:"vPointNext",varyingType:"v2"})}\n                                ${_({varyingName:"vPointPrec",varyingType:"v2"})}\n                                ${_({varyingName:"vLineDistanceAltResetSecondDist",varyingType:"v2"})}\n                                ${_({varyingName:"vLineDistanceLeftRight",varyingType:"v4"})}\n                                ${_({varyingName:"vConstantNext",varyingType:"v2"})}\n                                ${_({varyingName:"vConstantCurr",varyingType:"v2"})}\n                                ${_({varyingName:"vConstantPrec",varyingType:"v2"})}\n                                `:""}\n                            \n                            ${p("getDistance","f",[m("lineDistance"),m("next"),m("prev")])}{\n                                ${S("res")}  = 0.0;\n                                ${x("direction")}  = next-prev;\n                                ${S("l")}  = length(direction);\n                                res = dot(gl_FragCoord.xy  - prev, direction)/(l*l);\n                                return res * (lineDistance.y - lineDistance.x);\n                            }\n\n                            ${p("getDistance","f",[m("next"),m("prev"),m("origin"),s("ratio")])}{\n                                ${S("res")}  = 0.0;\n                                ${x("direction")}  = next-prev;\n                                ${S("l")}  = length(direction);\n                                res = dot(gl_FragCoord.xy - origin, direction)/(l*l);\n                                return res* ratio;\n                            }\n                        `}\n                    ${e.patternSize?`\n                        ${p("getPatternInfo","v3",[s("dist")])}{\n                            ${v("index")}  = 0;\n                            ${S("prec")}  = 0.0;\n                            ${S("cur")}  = 0.0;\n                            for (${v("i")} = 0; i < ${Math.ceil(e.patternSize/4)}; i++) {\n                                ${((n=null,e=0)=>{var t={name:n,size:e};return a.vec4(t)})("dashInfo")} = max(${h("scale")},1e-6)* ${h("dashPattern")}[i];\n\t\t\t\t\t\t\t\t${function(){let n=o,e=["x","y","z","w"];for(let t=0;t<4;t++)n=`\n                            ${n};\n                            cur = dashInfo.${e[t]};\n                            if (cur > dist) {\n                                break;\n                            }\n                            prec = cur;\n                            index++;\n                        `;return n}()}\n                            }\n                            return ${y()}(${S()}(index),prec,cur);\n                        }\n\n                        ${p("getPatternDistance","f",[s("dist")])}{\n                            ${"butt"===e.linecap?`return dist + ${h("patternOffset")};`:`\n                                ${!e.wideLine||e.worldSizePattern?`return dist + ${h("patternOffset")};`:`return dist + ${d("getHalfWidth","f",[])} + ${h("patternOffset")};`}\n                                `}\n                        }\n\n                        ${p("getPatternAlpha","f",[s("dist"),m("patternStartEnd")])}{\n                            ${S("mDist")}  = mod( dist, max(${h("scale")},1e-6)*${h("totalSize")} );\n                            ${e.worldSizePattern2?"\n                                if (patternStartEnd.x > -0.5) {\n                                    mDist -= patternStartEnd.x;\n                                    if (mDist < 0.0 || mDist > patternStartEnd.y - patternStartEnd.x) {\n                                        return 1.0;\n                                    }\n                                }\n                                ":""}\n                            ${y("patternInfo")}  = ${d("getPatternInfo","v3",[s("mDist")])};\n                            ${e.invertedPattern?"\n                                if (abs(mod(patternInfo.x,2.0)) < 0.5) {\n                                    return 1.0;\n                                }\n                                return 0.0;\n                                ":"\n                                if (abs(mod(patternInfo.x,2.0)) < 0.5) {\n                                    return 0.0;\n                                }\n                                return 1.0;\n                                "}\n                        }\n                        `:""}\n                `,D=`\n                    ${D}\n                    ${S("dist")}  = ${T("vLineDistance")}.x;\n                    ${S("dist2")}  = 0.0;\n                    ${e.wideLine?`\n                        ${g("isConnection")}  = length(fwidth(${T("vConstantCurr")})) < 1e-10;\n                        ${g("resetDist2")}  = fwidth(${T("vLineDistanceAltResetSecondDist")}).y > 1e-2;\n                        if (!isConnection){\n                            dist += ${d("getDistance","f",e.worldSizePattern?[$(T("vPointCurr")),$(T("vPointNext")),$(T("vPointPrec"))]:[m(T("vLineDistance")),m(T("vPointNext")),m(T("vPointPrec"))])};\n                        } else  {\n                            ${e.worldSizePattern?`\n                                ${y("constantCurr")} = ${T("vConstantCurr")};\n                                ${y("constantPrec")} = ${T("vConstantPrec")};\n                                ${y("constantNext")} = ${T("vConstantNext")};\n                                dist = ${T("vLineDistanceAltResetSecondDist")}.x + ${d("getDistance","f",[$(T("vPointCurr")),$("constantCurr"),$("constantPrec"),$("constantCurr")])};\n                                dist2 = ${d("getDistance","f",[$(T("vPointCurr")),$("constantNext"),$("constantCurr"),$("constantCurr")])};\n                                `:`\n                                ${x("constantCurr")} = ${T("vConstantCurr")};\n                                ${x("constantPrec")} = ${T("vConstantPrec")};\n                                ${x("constantNext")} = ${T("vConstantNext")};\n                                ${x("lineDistanceLeft")} = ${T("vLineDistanceLeftRight")}.xy;\n                                ${x("lineDistanceRight")} = ${T("vLineDistanceLeftRight")}.zw;\n                                dist = ${T("vLineDistanceAltResetSecondDist")}.x + ${d("getDistance","f",[m("constantCurr"),m("constantPrec"),m("constantCurr"),s("lineDistanceLeft.y - lineDistanceLeft.x")])};\n                                dist2 = ${d("getDistance","f",[m("constantNext"),m("constantCurr"),m("constantCurr"),s("lineDistanceRight.y - lineDistanceRight.x")])};\n                                `}\n                            if (!resetDist2) {\n                                dist2 += ${T("vLineDistanceAltResetSecondDist")}.x;\n                            }\n                        }\n                        `:""}\n                    ${e.patternSize?`\n                        ${x("patternStartEnd")} = ${e.worldSizePattern2?T("vPatternStartEnd"):`${x()}(0.0,0.0)`};\n                        ${S("ajdustedDist")}  = ${d("getPatternDistance","f",[s("dist")])};\n                        ${S("patternAlpha")}  = ${d("getPatternAlpha","f",[s("ajdustedDist"),m("patternStartEnd")])};\n                        ${e.PDSFX?`${d("ProcessLinePattern",null,[l("patternAlpha"),l("ajdustedDist")])};`:o}\n                        if (abs(dist2) > 1e-6) {\n                            ${S("ajdustedDist2")}  = ${d("getPatternDistance","f",[s("dist2")])};\n                            ${S("patternAlpha2")}  = ${d("getPatternAlpha","f",[s("ajdustedDist2"),m("patternStartEnd")])};\n                            ${e.PDSFX?`${d("ProcessLinePattern",null,[l("patternAlpha2"),l("ajdustedDist2")])};`:o}\n                            patternAlpha = min(patternAlpha, patternAlpha2);\n                        }\n                        if (patternAlpha > 0.5) {\n                            discard;\n                        }\n                        `:""}\n                `);return[i,D]}}),define("DS/ShaderBuilders/LineBasicShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/LineUtils/LineBasicVertexShaderBuilderUtils","DS/ShaderBuilders/LineUtils/LineBasicFragmentShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s){"use strict";const l=i.ParameterUtils,u=n=>{var e={uniformName:n};return a.getUniform(e)},m=(n=null,e=0)=>{var t={name:n,size:e};return s.vec4(t)},$=n=>o.addVarying(n);let c=function(n){return`\n        ${((n,e,t)=>i.FunctionHandler.declareFunction(n,e,t))("isNull","b",[(n=>l.parameterF(n))("x")])} {\n            return abs(x) < 1e-6;\n        }\n\n    `},p=function(e,t){let a=n._ShaderChunk,o=n._DeferredShaderChunk,[l,p]=r(e,c());return`\n            ${`\n            #define LINEBASIC\n            ${a.clip_pars_fragment(e)}\n\t\t\t${a.color_pars_fragment(e)}\n\t\t\t${l}\n\t\t\t${e.useUV?$({varyingName:"vUv",varyingType:"v4"}):""}\n            ${a.fog_pars_fragment(e)}\n\t\t\t${o.oit_pars_fragment(e)}\n\t\t\t${t?`\n                ${o.depth_pars_fragment(e)}\n                ${o.picking_pars_fragment(e)}\n                ${o.picking_instancing_pars_fragment(e)}\n                ${o.highlight_pars_fragment(e,!0)}\n                ${o.gpupos_pars_fragment(e)}\n                `:""}\n\t\t\t\n            ${a.postprocess_pars_fragment(e)}\n        `}\n            void main() {\n                ${`\n                ${e.PDSFX?`\n                    ${a.PDSFX_start_fragment(e)}\n                    ${a.PDSFX_map_fragment(e)}\n                    ${a.PDSFX_mapping_fragment(e)}\n                    ${a.PDSFX_Color_backup_fragment(e)}\n                    ${a.PDSFX_halfWidth_backup_fragment_vertex(e)}\n\t\t\t\t    ${((n,e,t)=>i.FunctionHandler.callFunction(n,e,t))("ComputeCommonValues",null,[])}; \n                    ${a.PDSFX_discard_fragment(e)}\n                    ${a.PDSFX_halfWidth_fragment_vertex(e)}\n                    ${a.PDSFX_Color_fragment(e)}\n                    `:""}\n                ${((n=null,e=0)=>{var t={name:n,size:e};return s.vec3(t)})("diffuseToUse")}  = ${e.PDSFX?"diffuse":`${u("diffuse")}`};\n                ${((n=null)=>{var e={name:n};return s.float(e)})("opacityToUse")}  = ${e.PDSFX?"opacity":`${u("opacity")}`};\n                ${e.selectionMaterial?`gl_FragColor = ${m()}( diffuseToUse, 1.0 );`:`gl_FragColor = ${m()}( diffuseToUse, opacityToUse );`}\n\n                ${a.clip_fragment(e)}\n\t\t\t\t${a.color_fragment(e)}\n\t\t\t\t${a.alphatest_fragment(e)}\n                ${p}\n\t\t\t\t${a.postprocess_fragment(e)}\n\t\t\t\t${a.linear_to_gamma_fragment(e)}\n\n\t\t\t\t${a.PDSFX_end_fragment(e)}\n                ${a.fog_fragment(e)}\n\t\t\t\t${a.backgroundviewmode_lowlight_fragment(e)}\n                ${o._debug_common_lineic_fragment(e)}\n                ${o.oit_fragment(e)}\n\t\t\t\t${t?`\n                    ${o.depth_fragment(e)}\n                    ${o.picking_fragment(e)}\n                    ${o.picking_instancing_fragment(e)}\n                    ${o.highlight_fragment_edge(e)}\n                    ${o.lineic_normal_fragment(e)}\n                    ${o.lineic_normal_depth_fragment(e)}\n                    ${o.gpupos_fragment(e)}\n                    `:""}\n        \n        `}\n            }\n        `},d=function(e,r){let a=n._ShaderChunk,i=n._DeferredShaderChunk,[s,l]=t(e,c());return`\n            ${`\n            #define LINEBASIC\n            ${a.clip_pars_vertex(e)}\n\t\t\t${a.color_pars_vertex(e)}\n\t\t\t${a.morphtarget_pars_vertex(e)}\n\t\t\t${a.skinning_pars_vertex(e)}\n            ${s}\n            ${a.fog_pars_vertex(e)}\n\n            ${e.useUV?$({varyingName:"vUv",varyingType:"v4"}):""}\n\n            ${i.oit_pars_vertex(e)}\n            ${r?`\n                ${i.depth_pars_vertex(e)}\n                ${i.picking_pars_vertex(e)}\n                ${i.picking_instancing_pars_vertex(e)}\n                ${i.highlight_pars_vertex(e)}\n                ${i.gpupos_pars_vertex(e)}\n                `:""}\n        `}\n            void main() {\n                ${`\n            ${e.PDSFX?a.PDSFX_halfWidth_backup_fragment_vertex(e):""}\n            ${a.PDSFX_start_vertex(e)}\n            ${e.PDSFX?a.PDSFX_halfWidth_fragment_vertex(e):""}\n            ${e.useUV?`${(n=>o.getVarying(n,o.ShaderStages.out))("vUv")} = uv;`:""}\n            ${a.color_vertex(e)}\n            ${a.skinbase_vertex(e)}\n            ${a.morphtarget_vertex(e)}\n            ${a.skinning_vertex(e)}\n            ${a.position_vertex(e)}\n            ${a.default_vertex(e)}\n            ${a.clip_vertex(e)}\n            ${a.fog_vertex(e)}\n            ${l}\n            \n            ${i.oit_vertex(e)}\n            ${r?`\n                ${i.depth_vertex(e)}\n                ${i.picking_vertex(e)}\n                ${i.picking_instancing_vertex(e)}\n                ${i.highlight_vertex(e)}\n                ${i.gpupos_vertex(e)}\n                `:""}\n            ${a.PDSFX_end_vertex(e)}\n        `}\n            }\n        `};return new e(function(n,e,t){let r=e.isDeferredMaterial,a=p(e,r);return{vertexShader:d(e,r),fragmentShader:a}})}),define("DS/ShaderBuilders/PBRUtils/PBRFragmentShaderBuilderUtils",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/PBRUtils/PBRFragmentAnalyticalLightsShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentIBLShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentEquationsShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentUniformsShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s,l){"use strict";const u=s.ParameterUtils,m=s.FunctionHandler,$=()=>l.dereference(),c=(n,e)=>u.parameter(n,e),p=n=>u.parameterF(n),d=n=>u.parameterI(n),f=n=>u.parameterV2(n),h=n=>u.parameterV3(n),g=n=>u.parameterRefV3(n),v=n=>u.parameterV4(n),S=(n,e,t)=>m.declareFunction(n,e,t),x=(n,e,t)=>m.callFunction(n,e,t),y=n=>o.addGlobalUniform(n),_=n=>{var e={uniformName:n};return o.getGlobalUniform(e)},T=n=>o.addObjectUniform(n),D=n=>{var e={uniformName:n};return o.getObjectUniform(e)},C=n=>{var e={uniformName:n};return o.getShadowUniform(e)},P=n=>i.addVarying(n),N=n=>i.getVarying(n,i.ShaderStages.in),M=(n=null)=>{var e={name:n};return l.int(e)},b=(n=null)=>{var e={name:n};return l.float(e)},w=(n=null,e="")=>{var t={name:n,addressSpace:e};return l.vec2(t)},U=(n=null,e=0)=>{var t={name:n,size:e};return l.vec3(t)},z=(n=null,e=0)=>{var t={name:n,size:e};return l.vec4(t)},V=n=>{var e={name:n,constant:!0};return l.float(e)};let F=function(n){return`\n                ${y({uniformName:"currentNormalStencilDepth",uniformType:"t2"})}    \n                ${y({uniformName:"currentTexCoord",uniformType:"t2"})} \n                ${n.mobileDevice?y({uniformName:"currentRGBADepth",uniformType:"t2"}):""}\n                ${T({uniformName:"decalExplicitUv",uniformType:"b"})} \n                ${T({uniformName:"modelViewInvMatrix",uniformType:"m4"})} \n                ${y({uniformName:"viewInfo",uniformType:"v2"})}    \n                ${T({uniformName:"decalStencilValue",uniformType:"f"})}    \n\n                ${P({varyingName:"decalPositionVS",varyingType:"v4"})}\n                ${P({varyingName:"decalPositionCS",varyingType:"v4"})}\n                \n                ${S("getEyeDepthPers","f",[p("iZClipSpace")])}{\n                    ${w("nearFar")}  = ${_("viewInfo")};\n                    return (2.0 *nearFar.x * nearFar.y) / (nearFar.y + nearFar.x - iZClipSpace * (nearFar.y - nearFar.x));\n                }\n\n                ${S("getEyeDepthOrtho","f",[p("iZClipSpace")])}{\n                    ${w("nearFar")}  = ${_("viewInfo")};\n                    return 0.5 * ((nearFar.y - nearFar.x) * iZClipSpace + nearFar.y + nearFar.x);\n                }\n\n                ${S("noBoxTest","v3",[p("depth"),(n=>u.parameterInOutV2(n))("dUv"),(n=>u.parameterInOutV3(n))("dObjectSpacePosition"),v("decalPosition")])} {\n                    ${z("nMVPosition")} ;\n                    if (${_("projectionMatrix")}[3][3] > 0.5) {\n                        ${b("viewDepth")}  = ${x("getEyeDepthOrtho","f",[p("2.0*depth-1.0")])};\n                        ${U("viewRay")}  = ${U()}(0.0, 0.0, -1.0);\n                        ${U("origin")}  = ${U()}(decalPosition.xy, 0.0);\n                        nMVPosition = ${z()}(origin + viewRay * viewDepth,1.0);\n                    } else {\n                        ${b("viewDepth")} = ${x("getEyeDepthPers","f",[p("2.0*depth-1.0")])};\n                        ${U("viewRay")} = (decalPosition.xyz  / -decalPosition.z);\n                        nMVPosition = ${z()}(viewRay * viewDepth,1.0);\n                    }\n                    ${z("pos")}  = (${D("modelViewInvMatrix")} * nMVPosition);\n                    ${$()}dObjectSpacePosition = pos.xyz;\n                    pos.x /= pos.w;\n                    pos.y /= pos.w;\n                    pos.z /= pos.w;\n                    ${$()}dUv = pos.xy + 0.5;\n                    ${b("depthToUse")}  = depth;\n                    ${b("dDecalx")}  = dFdx (depthToUse);\n                    ${b("dDecaly")}  = dFdy (depthToUse);\n                    ${n.mobileDevice?"\n                        depthToUse -= 4.0 * (sqrt(dDecalx*dDecalx + dDecaly*dDecaly) + DEPTH_PRECISION);\n                        ":"\n                        depthToUse -= 2.0 * (sqrt(dDecalx*dDecalx + dDecaly*dDecaly) + DEPTH_PRECISION);\n                        "}\n                    if (any(greaterThan(abs(pos.xyz), ${U()}(.5)))){\n                         discard;\n                    }\n                    ${n.shadowMapEnabled?`\n                        for( ${M("i")} = 0; i < ${n.maxShadows}; i ++ ) {\n                            gShadowCoord[ i ] = ${x("computeShadowCoord","v4",[h("pos.xyz"),c("m4",`${C("shadowMatrix")}[i]`),h(`${C("shadowCameraPosition")}[i].xyz`),h(`${C("lowPartShadowCameraPosition")}[i].xyz`)])};\n                        }\n                        `:""}\n                    gl_FragDepthEXT = depthToUse;\n                    return -nMVPosition.xyz;\n                }\n        `},R=function(n){return`\n            ${w("screenPos")}  = ${N("decalPositionCS")}.xy/${N("decalPositionCS")}.w;\n            ${w("decalFetchUv")}  = 0.5*vec2(screenPos.x, screenPos.y) + 0.5;\n            ${z("normalStencilDepthValue")}  = ${m.sample2DTexture("currentNormalStencilDepth","decalFetchUv")};\n            if (floor(normalStencilDepthValue.z + 0.5) - ${D("decalStencilValue")}  < 0.0) {\n                discard;\n            }\n            ${U("decalNormal")}  = ${x("decodeOct22Normal","v3",[f("normalStencilDepthValue.xy")])};\n            ${U("dObjectNormal")}  = normalize((${D("modelViewInvMatrix")}  * ${z()}(decalNormal, 0.0)).xyz);\n            ${w("dUv")} ;\n            ${U("dObjectSpacePosition")} ;\t\t\n            float decalDepth = normalStencilDepthValue.w;\n            ${n.mobileDevice?`\n                decalDepth = ${x("unpackRGBA","f",[v(`${m.sample2DTexture("currentRGBADepth","decalFetchUv")}`)])};\n                `:""}\n            ${U("dViewPosition")}  = ${x("noBoxTest","v3",[p("decalDepth"),(n=>u.parameterRefV2(n))("dUv"),g("dObjectSpacePosition"),v(N("decalPositionVS"))])};\n            ${w("dUv2")}  = dUv;\n            if (${D("decalExplicitUv")}) {\n                ${z("currentTexCoordsFetch")}  = ${m.sample2DTexture("currentTexCoord","decalFetchUv")};\n                dUv = currentTexCoordsFetch.xy;\n                dUv2 = currentTexCoordsFetch.zw;\n            }\n            ${U("dWorldPosition")}  =  ${x("getModelTransformation","v4",[v(`${z()}(dObjectSpacePosition, 1.0)`)])}.xyz;\n            ${n.shadowMapCubeEnabled?"decalShadowCubeWorldPosition = dWorldPosition;":""}\n    `},A=function(n){return`   \n            ${n.useUV?`\n                ${n.isDecal?"\n                    uvToUse = dUv;\n                    uv2ToUse = dUv2;\n                    ":`\n                    uvToUse = ${N("vUv")}.xy;\n                    uv2ToUse = ${N("vUv2")}.xy;\n                    `}\n                ${n.lightMap?`\n                    ${w("lightMapUV")} = uvToUse;\n                    if (${D("lightMapUvSlot")} != 1) {\n                        lightMapUV = uv2ToUse;\n                    }   \n                    ${n.lightMapMappingType>-1?`\n                        ${n.isDecal?`\n                            lightMapUV = ${x("applyMappingOperator","v2",[f("lightMapUV"),h("dObjectSpacePosition"),h("dObjectNormal"),d(`${D("lightMapMappingType")}`)])};\n                            `:`\n                            lightMapUV = ${x("applyMappingOperator","v2",[f("lightMapUV"),h(N("localPosition")),h(N("localNormal")),d(`${D("lightMapMappingType")}`)])};\n                            `}\n                        `:""}\n                    lightMapUV = ${x("applyLightMapUVCombination","v2",[f("lightMapUV"),c("m3",`${D("lightMapUvTransform")}`)])};\n                    `:""}\n                ${n.mappingType>-1&&n.mappingUseFragment?`\n                    ${n.isDecal?`\n                        if (!${D("decalExplicitUv")}) {\n                            ${n.needTangentBinormal?`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h("dObjectSpacePosition"),h("dObjectNormal"),g("tangent"),g("binormal")])};`:`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h("dObjectSpacePosition"),h("dObjectNormal")])};`}  \n                            uv2ToUse = ${x("applyMappingOperator","v2",[f("uv2ToUse"),h("dObjectSpacePosition"),h("dObjectNormal")])};\n                        } else {\n                            ${n.needTangentBinormal?`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h("dObjectSpacePosition"),h("dObjectNormal"),d("0"),g("tangent"),g("binormal")])};`:`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h("dObjectSpacePosition"),h("dObjectNormal"),d("0")])};`}  \n                            uv2ToUse = ${x("applyMappingOperator","v2",[f("uv2ToUse"),h("dObjectSpacePosition"),h("dObjectNormal"),d("0")])};\n                        }\n                        `:`\n                        ${n.needTangentBinormal?`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h(N("localPosition")),h(N("localNormal")),g("tangent"),g("binormal")])};`:`uvToUse = ${x("applyMappingOperator","v2",[f("uvToUse"),h(N("localPosition")),h(N("localNormal"))])};`}\n                        uv2ToUse = ${x("applyMappingOperator","v2",[f("uv2ToUse"),h(N("localPosition")),h(N("localNormal"))])};\n                        `}\n                    `:""}\n                `:""}\n            ${n.needTangentBinormal&&n.mappingType>-1&&n.mappingUseFragment?`\n                if (${e="mappingType",t={uniformName:e},o.getUniform(t)}>0){\n                    ${w("bogusUV")}  = ${x("applyMappingOperator","v2",[f(`${w()}(0.0)`),h(N("localPosition")),h(N("localNormal")),g("tangent"),g("binormal")])};\n                }\n                `:""}\n        `;var e,t},I=function(n){return`\n\n            ${S("gaussian","f",[p("x"),p("mean"),p("variance")])}{\n                ${b("value")}  = x - mean;\n                value *= value;\n                value /= 2.0 * variance;\n                return exp(-value);\n            }\n\n            ${S("mod289","v4",[v("x")])}{\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${S("mod289","v3",[h("x")])}{\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${S("mod289","v2",[f("x")])} {\n              return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n\n            ${S("permute","v3",[h("x")])}{\n                ${U("value")}  = ((x*34.0)+1.0)*x;\n            \treturn ${x("mod289","v3",[h("value")])};\n            }\n\n            ${S("permute","v4",[v("x")])}{\n                ${z("value")}  = ((x*34.0)+1.0)*x;\n            \treturn ${x("mod289","v4",[v("value")])};\n            }\n\n            ${S("taylorInvSqrt","v4",[v("r")])}{\n            \treturn 1.79284291400159 - 0.85373472095314 * r;\n            }\n\n            ${S("snoise","f",[h("v")])}{\n\n                ${e="C",t={name:e,constant:!0},l.vec2(t)} = ${w()}(1.0/6.0, 1.0/3.0);\n                ${(n=>{var e={name:n,constant:!0};return l.vec4(e)})("D")} = ${z()}(0.0, 0.5, 1.0, 2.0);\n\n                ${U("i")}   = floor(v + dot(v, C.yyy) );\n                ${U("x0")}  =   v - i + dot(i, C.xxx) ;\n\n                ${U("g")}  = step(x0.yzx, x0.xyz);\n                ${U("l")}  = 1.0 - g;\n                ${U("i1")}  = min( g.xyz, l.zxy );\n                ${U("i2")}  = max( g.xyz, l.zxy );\n\n                ${U("x1")}  = x0 - i1 + C.xxx;\n                // 2.0*C.x = 1/3 = C.y\n                ${U("x2")}  = x0 - i2 + C.yyy; \n                // -1.0+3.0*C.x = -0.5 = -D.y\n                ${U("x3")}  = x0 - D.yyy;      \n\n                i = mod289(i);\n                ${z("permutationAux")}  = i.z + ${z()}(0.0, i1.z, i2.z, 1.0 );\n                permutationAux = ${x("permute","v4",[v("permutationAux")])} + i.y + ${z()}(0.0, i1.y, i2.y, 1.0 );\n                permutationAux = ${x("permute","v4",[v("permutationAux")])} + i.x + ${z()}(0.0, i1.x, i2.x, 1.0 );\n                ${z("permutation")}  = ${x("permute","v4",[v("permutationAux")])};\n\n                // 1.0/7.0\n                ${b("n_")}  = 0.142857142857;\n                ${U("ns")} = n_ * D.wyz - D.xzx;\n                //  mod(permutation,7*7)\n                ${z("j")} = permutation - 49.0 * floor(permutation * ns.z * ns.z);  \n\n                ${z("x_")}  = floor(j * ns.z);\n                // mod(j,N)\n                ${z("y_")}  = floor(j - 7.0 * x_ );    \n\n                ${z("x")}  = x_ *ns.x + ns.yyyy;\n                ${z("y")}  = y_ *ns.x + ns.yyyy;\n                ${z("h")}  = 1.0 - abs(x) - abs(y);\n\n                ${z("b0")}  = vec4( x.xy, y.xy );\n                ${z("b1")}  = vec4( x.zw, y.zw );\n\n                ${z("s0")}  = floor(b0)*2.0 + 1.0;\n                ${z("s1")}  = floor(b1)*2.0 + 1.0;\n                ${z("sh")}  = -step(h, vec4(0.0));\n\n                ${z("a0")}  = b0.xzyw + s0.xzyw*sh.xxyy;\n                ${z("a1")}  = b1.xzyw + s1.xzyw*sh.zzww;\n\n                ${U("p0")}  = ${U()}(a0.xy,h.x);\n                ${U("p1")}  = ${U()}(a0.zw,h.y);\n                ${U("p2")}  = ${U()}(a1.xy,h.z);\n                ${U("p3")}  = ${U()}(a1.zw,h.w);\n\n                ${z("r")} = ${z()}(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3));\n                ${z("norm")}  = ${x("taylorInvSqrt","v4",[v("r")])};\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n\n                ${z("m")}  = max(0.6 - ${z()}(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot( m*m, ${z()}( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n            }\n\n\n\n            ${(n=>{var e={name:n,constant:!0};return l.int(e)})("NBOCTAVES")}  = 10;\n\n            ${S("getMean","f",[p("LODLevel")])}{\n                ${b("mult")}  = 1.8;\n                ${b("LOD")}  = 3.0;\n                ${b("oldLOD")}  = 0.0;\n                for (${M("i")} = NBOCTAVES - 1 ; i >=0; i--) {\n                    ${b("pente")}  = 1.0 / (LOD - oldLOD);\n                    ${b("origine")}  = ${b()}(i) + 1.0 + oldLOD * pente;\n                    if (LODLevel <= LOD) {\n                        return origine - pente * LODLevel;\n                    }\n                    oldLOD = LOD;\n                    LOD *= mult;\n                }\n                return 0.0;\n            }\n\n            ${S("FBM","f",[h("iVector")])}{\n                ${U("vector")}  = iVector;\n                ${b("res")}  = 0.0;\n                ${b("amplitude")}  = 1.0;\n                ${b("sum")}  = 0.0;\n                for (${M("octave")}  = 0; octave < 1; octave++) {\n                    if (amplitude < 10.0 * kEpsilon) {\n                        break;\n                    }\n                    vector = vector * 2.0;\n                    sum += amplitude;\n                    res += ${x("snoise","f",[h("vector")])} * amplitude;\n                    amplitude *= 0.5;\n                }\n                return clamp(res/sum,-1.0,1.0);\n            }\n\n            ${S("arrayFBMMixer","f",[h("iVector"),p("LODLevel"),p("frequency"),p("low"),p("up")])}{\n                ${U("vector")}  = iVector;\n                ${b("res")}  = 0.0;\n                ${b("sum")}  = 0.0;\n                ${b("variance")}  = 1.5;\n                ${b("mean")}  = ${x("getMean","f",[p("LODLevel")])};\n                ${b("amplitude")} ;\n                ${M("minIndex")}  = ${M()}(max(0.0, mean - low));\n                ${M("maxIndex")}  = ${M()}(min(${b()}(NBOCTAVES), mean + up));\n                ${b("nFrequency")} = frequency * pow(1.8, ${b()}(minIndex));\n                ${M("octave")}  = minIndex;\n                for (${M("i")} = 0; i < 10 ; i++) {\n                    if (octave >= maxIndex) {break;}\n                    ${U("vec")}  = vector * nFrequency;\n                    nFrequency *= 1.8;\n                    amplitude = ${x("gaussian","f",[p(`${b()}(octave)`),p("mean"),p("variance")])};\n                    sum += amplitude;\n                    res += ${x("snoise","f",[h("vec")])} * amplitude;\n                    octave++;\n                }\n                return clamp(res/sum,-1.0,1.0);\n            }\n    `;var e,t},L=function(n){return`\n        ${V("kEpsilon")}  = 0.00001;\n\n        ${S("myAtan2","f",[p("y"),p("x")])}{\n\n            ${b("absx")};\n            ${b("absy")};\n            ${b("val")};\n\t\t\t${b("ret")};\n\t\t\tif (x == 0.0 && y == 0.0) { return 0.0; }\n\t\t\tif (y < 0.0) { absy = -y; } else { absy = y; }\n            if (x < 0.0) { absx = -x; } else { absx = x; }\n\t\t\tif (absy - absx == absy) {\n                if (y < 0.0) { return -PI*0.5; }\n                return PI*0.5;\n            }\n\t\t\tif (absx - absy == absx) {\n                val = 0.0;\n            } else {\n                val = ${n.WebGPU?"atan2(y, x);":"atan(y/x);"}\n            }\n\t\t\tif (x > 0.0) { return val; }\n\t\t\tif (y < 0.0) { return val - PI; }\n            return val + PI;\n\t\t}\n\n        ${S("vOrthoProjectionOnLine","v3",[h("P"),h("A"),h("B")])}{\n            ${U("v")}  = normalize(B - A);\n            ${U("AP")}  = P - A;\n            return A + dot(AP,v) * v;\n        }\n\n        ${S("vSmoothstep","f",[p("lower"),p("upper"),p("factor")])}{\n\t\t\tif (upper <= lower) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn smoothstep(lower, upper, factor);\n\t\t}\n        \n        ${S("vLerp","f",[p("a"),p("b"),p("w")])}{\n            return a + w * (b-a);\n        }\n\t\t\n        ${S("vLerp","v3",[h("a"),h("b"),p("w")])}{\n            return a + w * (b-a);\n        }\n\n        ${S("TangentToWorldGeom","v3",[h("Vec"),h("TangentZ")])}{\n\n            ${U("TangentX")}  = ${x("getGeomT","v3",[h("TangentZ")])};\n            ${U("TangentY")}  = ${x("getGeomB","v3",[h("TangentZ"),h("TangentX")])};\n\n            return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n        }\n\n        \n\n        ${S("modI","f",[p("a"),p("b")])}{\n\t\t\t${b("m")}  = a - floor((a+0.5)/b)*b;\n\t\t\treturn floor(m+0.5);\n\t\t}\n\n        ${S("modI","i",[d("a"),d("b")])}{\n            ${b("fA")}  = ${b()}(a);\n            ${b("fB")}  = ${b()}(b);\n\t\t\treturn ${M()}(${x("modI","f",[p("fA"),p("fB")])});\n\t\t}\n\n        ${S("vRound","f",[p("a")])}{\n\t\t\treturn floor(a + 0.5);\n\t\t}\n\n        ${S("vMax","f",[f("v")])}{\n\t\t\treturn max(v.x,v.y);\n\t\t}\n\n        ${S("vMax","f",[h("v")])}{\n\t\t\treturn max(${x("vMax","f",[f("v.xy")])},v.z);\n\t\t}\n\n        ${S("vMax","f",[v("v")])}{\n\t\t\treturn max(${x("vMax","f",[f("v.xy")])},${x("vMax","f",[f("v.zw")])});\n\t\t}\n\n        ${S("vMin","f",[f("v")])}{\n\t\t\treturn min(v.x,v.y);\n\t\t}\n\n        ${S("vMin","f",[h("v")])}{\n\t\t\treturn min(${x("vMin","f",[f("v.xy")])},v.z);\n\t\t}\n\n        ${S("vMin","f",[v("v")])}{\n\t\t\treturn min(${x("vMin","f",[f("v.xy")])},${x("vMin","f",[f("v.zw")])});\n\t\t}\n\n        ${S("affine","f",[p("value"),p("value0"),p("value1")])}{\n            return value * (value1 - value0) + value0;\n        }\n\n        ${S("toTexCoord","f",[p("x"),p("minValue"),p("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);\n        }\n\n        ${S("toTexCoord","v2",[f("x"),f("minValue"),f("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${w()}(0.0), ${w()}(1.0));\n        }\n\n        ${S("toTexCoord","v3",[h("x"),h("minValue"),h("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${U()}(0.0), ${U()}(1.0));\n        }\n\n        ${S("toTexCoord","v4",[v("x"),v("minValue"),v("maxValue")])}{\n            return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue), ${z()}(0.0), ${z()}(1.0));\n        }\n\n        ${S("vIsnan","b",[p("val")])}{\n\t\t  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n\t\t}\n\n        ${S("transposeMatrix","m3",[c("m3","m")])}{\n            ${((n=null)=>{var e={name:n};return l.mat3(e)})("mT")} ;\n\n            mT[0] = ${U()}(m[0][0], m[1][0], m[2][0]);\n            mT[1] = ${U()}(m[0][1], m[1][1], m[2][1]);\n            mT[2] = ${U()}(m[0][2], m[1][2], m[2][2]);\n\n            return mT;\n        }\n\n        ${S("saturate","f",[p("iValue")])}{\n            return clamp(iValue, 0.0, 1.0);\n        }\n\n        ${S("saturate","v2",[f("iValue")])}{\n            return clamp(iValue, ${w()}(0.0), ${w()}(1.0));\n        }\n\n        ${S("saturate","v3",[h("iValue")])}{\n            return clamp(iValue, ${U()}(0.0), ${U()}(1.0));\n        }\n\n        ${S("saturate","v4",[v("iValue")])}{\n            return clamp(iValue, ${z()}(0.0), ${z()}(1.0));\n        }\n\n        ${S("fma","f",[p("x"),p("y"),p("z")])}{\n            return x*y + z;\n        }\n\n        ${S("fma","v2",[f("x"),f("y"),f("z")])}{\n            return x*y + z;\n        }\n\n        ${S("fma","v3",[h("x"),h("y"),h("z")])}{\n            return x*y + z;\n        }\n\n        ${S("fma","v4",[v("x"),v("y"),v("z")])}{\n            return x*y + z;\n        } \n\n        ${S("FresnelSchlick","v3",[h("iSr0Color"),p("ctheta")])}{\n            ${b("Fc")}  = ${x("pow5","f",[p("1.0 - ctheta")])};\n            return Fc + (1.0 - Fc) * iSr0Color;\n        }\n\n        ${S("FresnelSchlick","v3",[h("iSr0Color"),h("iSr90Color"),p("ctheta")])}{\n            ${b("power")}  =  ${x("pow5","f",[p("1.0 - ctheta")])};\n            return  mix(iSr0Color, iSr90Color, power);\n        }\n\n        \n        ${S("FresnelSchlick","f",[p("iSr0Color"),p("iSr90Color"),p("ctheta")])}{\n            ${b("power")} =  ${x("pow5","f",[p("1.0 - ctheta")])};\n            return  mix(iSr0Color, iSr90Color, power);\n        }\n        \n        ${S("FresnelSchlick","v2",[p("ctheta")])}{\n            ${b("power")} =  ${x("pow5","f",[p("1.0 - ctheta")])};\n            return vec2((1.0-power),power);\n        }\n\n        ${S("F0FromFresnelSchlick","v3",[h("iFresnel"),h("iSr90Color"),p("ctheta")])}{\n            ${b("power")} =  ${x("pow5","f",[p("1.0 - ctheta")])};\n            power = clamp(power, 0.0, 1.0 - 1e-6);\n            return (iFresnel - iSr90Color * power) / (1.0 - power);\n        }\n    `},B={getDecalShaders:function(n){return n.isDecal?[F(n),R(n)]:["",""]},getNoiseShader:function(n){return n.specGlossFlakes||n.orangePeel?I():""},getUtilityShader:function(e,t){let r=`\n                ${L(t)}\n            `;return e&&(r=`\n                    ${r}\n                    ${function(e){return`       \n            ${S("SpecGlossEnergyConservationTerm","f",[p("NoL"),p("NoV"),h("iSr0Color"),h("iSr90Color")])} {\n                ${U("fresnelNoL")}  = ${x("FresnelSchlick","v3",[h("iSr0Color"),h("iSr90Color"),p("NoL")])};\n                ${e.specglossNRE?"return 1.0 - dot(fresnelNoL, luminanceVector);":`${U("fresnelNoV")} = ${x("FresnelSchlick","v3",[h("iSr0Color"),h("iSr90Color"),p("NoV")])};\n                    return 1.0 - ${x("vMax","f",[h("max(fresnelNoL, fresnelNoV)")])};\n                    `}\n            }\n\n            ${S("SpecGlossEnergyConservationTerm","f",[h("fresnel")])} {\n                return 1.0 - dot(fresnel, luminanceVector);\n            }\n            \n            ${e.mobileDevice?` \n\n                ${S("GeometricLambda","f",[p("a"),p("cosTheta")])} {\n                    return 1.0 - a + a/max(cosTheta, 1e-6);\n                }\n                \n                ${S("GeometricSchlick","f",[p("roughness"),p("NoV"),p("NoL")])} {\n                    ${b("a")}  = roughness * roughness;\n                    ${b("GLNoL")}  = ${x("GeometricLambda","f",[p("a"),p("NoL")])};\n                    ${b("GLNoV")}  = ${x("GeometricLambda","f",[p("a"),p("NoV")])};\n                    return 2.0 / (GLNoL + GLNoV);\n                }\n                `:` \n                ${S("GeometricLambda","f",[p("a2"),p("cosTheta")])} {\n                    return sqrt(1.0 - a2 + a2/max(cosTheta * cosTheta, 1e-6));\n                }\n                \n                ${S("GeometricSchlick","f",[p("roughness"),p("NoV"),p("NoL")])} {              \n                    ${b("a")}  = roughness * roughness;\n                    ${b("a2")}  = a * a;\n                    ${b("GLNoL")}  = ${x("GeometricLambda","f",[p("a2"),p("NoL")])};\n                    ${b("GLNoV")}  = ${x("GeometricLambda","f",[p("a2"),p("NoV")])};\n                    return 2.0 / (GLNoL + GLNoV);\n                }\n                `} \n            \n            ${S("GGXVisibility","f",[p("roughness"),p("NoV"),p("NoL")])} {\n                ${b("factor")}  = 0.25 / max(abs(NoL * NoV), 1e-3);\n                return factor * ${x("GeometricSchlick","f",[p("roughness"),p("NoV"),p("NoL")])};\n            }\n            \n            ${S("DistributionGGX","f",[p("roughness"),p("NoH")])} {\n                ${b("alpha")}  = roughness * roughness;\n                ${b("alpha2")}  = alpha * alpha;\n                ${b("NoH2")}  = NoH * NoH;\n                ${b("d")} = max((alpha2 - 1.0) * NoH2 + 1.0, 1e-6);\n                return alpha2* INV_PI / (d * d);\n            }\n\n            ${e.sheen?`\n                ${S("SheenVisGeometricSchlick","f",[p("NoV"),p("NoL")])} {\n                    ${b("div")}  = 4.0 * max(NoL + NoV - NoL*NoV, 1e-6);\n                    return 1.0 / div;\n                }\n\n                ${S("SheenDistribution","f",[p("NoH"),p("sheenValue")])} {\n                    ${b("cosine2")}  = max(NoH * NoH,kEpsilon);\n                    ${b("sine2")}  = max(1.0-cosine2,kEpsilon);\n                    ${b("D")}  = 1.0;\n                    ${b("normalisationTerm")}  = 0.31830988618379;\n                    ${e.sheenMode===n.SheenMode.VELVET?`\n                        ${b("a2")}  = sheenValue * sheenValue;\n                        normalisationTerm *= 1.0/(4.0*a2+1.0);\n                        ${b("sine4")}  = max(sine2 * sine2,kEpsilon);\n                        ${b("cotan2")}  = cosine2/sine2;\n                        ${b("value")}  = -cotan2 / a2;\n                        D = 1.0+4.0 * exp(value)/ sine4;\n                        `:""}\n                    ${e.sheenMode===n.SheenMode.VELVET_SOFT?`\n                        ${e.dspbrWithSquaredEstevezKullaRoughness?`${b("a")} = sheenValue * sheenValue;`:`${b("a")} = sheenValue;`}\n                        a = max(a, 1e-3);\n                        normalisationTerm *= 0.5;\n                        ${b("sine")}  = sqrt(sine2);\n                        D = (2.0 + 1.0 /a ) * pow(sine, 1.0 / a);\n                        `:""}\n                    ${e.sheenMode===n.SheenMode.SATIN?`\n                        ${b("a2")} = 0.0081;\n                        normalisationTerm *= 1.0/(8.0*a2);\n                        ${b("cosine4")}  = max(cosine2 * cosine2,kEpsilon);\n                        ${b("tan2")}  = sine2/cosine2;\n                        ${b("value")}  = -tan2/( a2*8.0);\n                        D = exp(value) / cosine4 ;\n                        `:""}\n                    return D * normalisationTerm;\n                }\n                \n                `:""}\n        `}(t)}\n                `,t.dspbr&&(r=`\n                        ${r}\n                        ${function(n){return`\n         \n            ${S("DirectionalMultipleAlbedo","f",[p("cosTheta"),p("roughness")])} {\n                ${b("a2")}  = ${x("pow4","f",[p("roughness")])};\n                ${b("res")}  = 3.09507 + cosTheta * (-9.11369 + cosTheta * (15.8884 + cosTheta * (-13.70343 + 4.51786 * cosTheta)));\n                res *= (-0.20277 + a2 * (2.772 + a2 * (-2.6175 + 0.73343*a2)));\n                res *= 1.4594 * a2 * cosTheta;\n                return 1.0  - res;\n            } \n\n            ${S("AverageDirectionalMultipleAlbedo","f",[p("roughness")])} {\n                ${b("a2")} = ${x("pow4","f",[p("roughness")])};\n                return 1.0 + a2 * (-0.133 + a2 * (-1.8695 + a2 * (2.2268 - 0.83397*a2)));\n            }\n\n            ${S("AverageMultipleFresnel","f",[p("F0")])} {\n                return mix(1.0, F0, 0.95238095238);\n            }\n            \n            ${S("AverageMultipleFresnel","v3",[h("iSr0Color"),h("iSr90Color")])} {\n                return mix(iSr90Color, iSr0Color, 0.95238095238);\n            }\n\n            \n            ${S("DirectionalAlbedo","f",[h("specularSr0"),p("cosTheta"),p("roughness")])} {       \n                ${b("a2")}  = ${x("pow4","f",[p("roughness")])};\n                ${b("E0")}  = ${x("vMax","f",[h("specularSr0")])};\n                ${b("a")}  = E0 + (1.0 - E0) * ${x("pow5","f",[p("1.0 - cosTheta")])};\n                ${b("b")}  = 0.04762 + 0.95238*E0;\n                ${b("w")}  = 1.0 - ${x("pow5","f",[p("1.0 - a2")])};\n                return ${x("vLerp","f",[p("a"),p("b"),p("w")])};\n            }\n\n            ${S("DirectionalAlbedo","f",[p("F0"),h("specularTint"),p("cosTheta"),p("roughness")])} {      \n                return ${x("DirectionalAlbedo","f",[h("F0 * specularTint"),p("cosTheta"),p("roughness")])};\n            }\n\n            ${S("AverageDirectionalAlbedo","f",[h("specularSr0"),p("roughness")])} {\n                ${b("a2")}  = ${x("pow4","f",[p("roughness")])};\n                ${b("E0")}  = ${x("vMax","f",[h("specularSr0")])};\n                return E0 + (-0.33263 * a2 - 0.072359) * (1.0 - E0) * E0;\n            }\n\n            ${S("AverageDirectionalAlbedo","f",[p("F0"),h("specularTint"),p("roughness")])} {\n                return ${x("AverageDirectionalAlbedo","f",[h("F0 * specularTint"),p("roughness")])};\n            }\n\n            \n            ${n.dspbrWithSheenColorRoughness?`\n                ${S("DirectionalSheenAlbedo","f",[p("cosTheta"),p("roughness")])} {\n                    ${n.dspbrWithSquaredEstevezKullaRoughness?`${b("a")} = roughness * roughness;`:`${b("a")} = roughness;`}\n                    return 0.04495972 + 0.47479907 * (sqrt(1.0 - cosTheta) + (1.0 - cosTheta) * sqrt(1.0 - sqrt(a)));\n                }\n                `:""}\n        `}(t)}\n                    `),(t.anisotropy||t.useSpecularAA)&&(r=`\n                        ${r}  \n                        ${`     \n\n        ${S("AnisotropicGeometricSchlick","f",[p("roughnessX"),p("roughnessY"),p("NoV"),p("NoL"),p("iAnisotropyAngle")])} {        \n            ${b("ax")}  = roughnessX * roughnessX;\n            ${b("ay")}  = roughnessY * roughnessY;\n            ${b("a2")}  = ${x("pow2","f",[p("cos(iAnisotropyAngle)*ax")])} + ${x("pow2","f",[p("sin(iAnisotropyAngle)*ay")])};\n            ${b("G1")}  = sqrt(1.0-a2+a2/max(NoL*NoL,1e-6));\n            ${b("G2")}  = sqrt(1.0-a2+a2/max(NoV*NoV,1e-6));\n            return 2.0 / (G1+G2);\n        }\n\n        ${S("AnisotropicGGXVisibility","f",[p("roughnessX"),p("roughnessY"),p("NoV"),p("NoL"),p("iAnisotropyAngle")])} {\n            ${b("factor")}  = 0.25 / max(abs(NoL * NoV), 1e-3);\n            return factor *  ${x("AnisotropicGeometricSchlick","f",[p("roughnessX"),p("roughnessY"),p("NoV"),p("NoL"),p("iAnisotropyAngle")])};\n        }\n\n        ${S("AnisotropicDistributionGGX","f",[h("T"),h("B"),h("N"),h("H"),p("NoH"),p("iRoughnessX"),p("iRoughnessY"),p("iAnisotropyAngle")])} {\n            ${U("rot_X")}  = cos(2.0 * PI * iAnisotropyAngle) * T + sin(2.0 * PI * iAnisotropyAngle) * B;\n            ${U("rot_Y")}  = cross(N, rot_X);\n\n            ${b("dot_t_h")}  = dot(rot_X, H);\n            ${b("dot_b_h")}  = dot(rot_Y, H);\n            ${b("alpha_T")}  = iRoughnessX;\n            ${b("alpha_B")}  = iRoughnessY;\n\n            alpha_T = max(alpha_T * alpha_T, 1e-3);\n            alpha_B = max(alpha_B * alpha_B, 1e-3);\n\n            ${b("a")}  = dot_t_h / alpha_T;\n            ${b("b")}  = dot_b_h / alpha_B;\n\n            ${b("D")}  = a * a + b * b + NoH * NoH;\n            D = PI * alpha_T * alpha_B * D * D;\n            D = 1.0 / max(D, kEpsilon);\n\n            return D;\n        }\n\n        ${S("ComputeAnisotropicRoughness","f",[h("T"),h("B"),h("N"),h("H"),p("iRoughness"),p("anisotropy"),p("anisotropyAngle")])} {\n            ${U("rot_X")}  = cos(2.0 * PI * anisotropyAngle) * T + sin(2.0 * PI * anisotropyAngle) * B;\n            ${U("rot_Y")}  = cross(N, rot_X);\n\n            ${b("dot_t_h")}  = dot(rot_X, H);\n            ${b("dot_b_h")}  = dot(rot_Y, H);\n            ${b("alpha_T")} = iRoughness;\n            ${b("alpha_B")} = iRoughness * (1.0 - anisotropy) ;\n\n            alpha_T = max(alpha_T * alpha_T, kEpsilon);\n            alpha_B = max(alpha_B * alpha_B, kEpsilon);\n\n            ${b("tmp")}  =  sign(dot_b_h) * sign(dot_t_h);\n\n            dot_t_h = max(abs(dot_t_h),0.05) * tmp;\n            dot_b_h = max(abs(dot_b_h),0.05);\n\n            ${b("phi")}  = atan(dot_t_h,dot_b_h);\n            ${b("a")}  = ${x("pow2","f",[p("cos(phi) / alpha_T")])};\n            ${b("b")}  = ${x("pow2","f",[p("sin(phi) / alpha_B")])};\n            ${b("a2")}  = 1.0/ (a+b);\n\n            ${b("roughness")}  = ${x("saturate","f",[p("sqrt(sqrt(a2))")])};\n            return clamp(roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX) ;\n        }\n    `}   \n                    `)),r},getMappingShaders:function(e,t){return[`\n                ${e.useUV?`\n                    ${P({varyingName:"vUv",varyingType:"v4"})}\n                    ${w("uvToUse","private")};\n\n                    ${P({varyingName:"vUv2",varyingType:"v4"})}\n                    ${w("uv2ToUse","private")};\n                    \n                    ${P({varyingName:"vUv3",varyingType:"v4"})}\n                    `:""}\n                ${n._DefaultShaderChunk.map_pars_fragment(e)}\n                ${e.WebGPU?"":t}\n            `,A(e)]}};return Object.assign(B,e),Object.assign(B,t),Object.assign(B,r),Object.assign(B,a),B}),define("DS/ShaderBuilders/PBRShaderBuilder",["DS/Mesh/ThreeJS_Base","DS/ShaderBuilders/ShaderBuilder","DS/ShaderBuilders/PBRUtils/PBRShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRVertexShaderBuilderUtils","DS/ShaderBuilders/PBRUtils/PBRFragmentShaderBuilderUtils","DS/ShaderBuilders/ShaderUtils/UniformUtils","DS/ShaderBuilders/ShaderUtils/ShaderInOutUtils","DS/ShaderBuilders/ShaderUtils/FunctionUtils","DS/ShaderBuilders/ShaderUtils/TypeUtils"],function(n,e,t,r,a,o,i,s,l){"use strict";const u=s.ParameterUtils,m=(n,e)=>u.parameter(n,e),$=(n,e)=>u.parameterV2(n,e),c=(n,e,t)=>s.FunctionHandler.declareFunction(n,e,t),p=n=>{var e={uniformName:n};return o.getUniform(e)},d=n=>i.getShaderOutput(n),f=n=>i.addVarying(n),h=n=>i.getVarying(n,i.ShaderStages.out),g=(n=null)=>{var e={name:n};return l.vec2(e)},v=(n=null,e="",t=0)=>{var r={name:n,addressSpace:e,size:t};return l.vec3(r)},S=(n=null)=>{var e={name:n};return l.mat2(e)},x=n=>{var e={name:n,constant:!0};return l.float(e)};let y=function(n){const e=`          \n                        if(${p("mappingTransformSemantic")}==2){\n                            ${g("T0")}  = ${p("mappingUVTransformation")}[2].xy; // M0 translation only\n                            ${g("Ti")}  = uvtransform[2].xy; // Mi translation only\n                    \n                            ${S("Ri")}  = ${S()}(uvtransform[0].xy, uvtransform[1].xy);//rotation\n                            ${S("R0")}  = ${S()}(${p("mappingUVTransformation")}[0].xy, ${p("mappingUVTransformation")}[1].xy);//rotation\n                            ${g("uv_shifted")}  = uv.xy + T0 +Ti;\n                            return Ri * R0 * uv_shifted;\n                        } else if(${p("mappingTransformSemantic")}==3) {\n                            ${g("T0")}  = ${p("mappingUVTransformation")}[2].xy; // M0 translation only\n                            ${g("Ti")}  = uvtransform[2].xy; // Mi translation only\n                    \n                            ${S("Ri")}  = ${S()}(uvtransform[0].xy, uvtransform[1].xy);//rotation\n                            ${S("R0")}  = ${S()}(${p("mappingUVTransformation")}[0].xy, ${p("mappingUVTransformation")}[1].xy);//rotation\n                            ${g("uv_shifted")}  = uv.xy + T0 +Ti-${g()}(0.5,0.5);\n                            return (Ri * R0 * uv_shifted)+${g()}(0.5,0.5);\n                        }\n        `;return`\n            ${c("applyUVCombination","v2",[$("uv"),m("m3","uvtransform")])}{\n                ${n.NRECompatibility?`\n                    ${n.mappingType>-1?`\n                        ${e}\n                        `:""}\n                    return (uvtransform * ${v()}(uv,1.0)).xy;\n                    `:"return uv;"}\n            }\n            ${n.lightMap?`\n                ${c("applyLightMapUVCombination","v2",[$("uv"),m("m3","uvtransform")])}{\n                    ${n.NRECompatibility?`\n                        ${n.lightMapMappingType>-1?`\n                            ${e}\n                            `:""}\n                        return (uvtransform * ${v()}(uv,1.0)).xy;\n                        `:"return uv;"}\n                }\n                `:""}\n        `},_=function(e,t,a){let[o,i]=r.getDisplacementShaders(e),[l,u]=r.getDecalShaders(e),[m,$]=r.getMappingShaders(e,y(e)),c=n._ShaderChunk,p=n._DeferredShaderChunk;return`\n            ${e.WebGPU?"":"#define PHYSICALDS"}\n\n            ${n._DefaultShaderChunk.normal_viewposition_pars_vertex(e)}\n            ${c.color_pars_vertex(e)}\n\n            ${c.clip_pars_vertex(e)}\n            ${m}\n            ${o}\n\n            ${f({varyingName:"vWorldPosition",varyingType:"v3"})}\n\n            ${e.needObjectSpaceData?`\n                ${f({varyingName:"vObjectSpacePosition",varyingType:"v3"})}\n                ${f({varyingName:"vObjectSpaceNormal",varyingType:"v3"})}\n                `:""}\n\n            ${t?c.shadowmap_pars_vertex(e):""}\n            ${c.tangent_Binormal_pars(e)}\n            ${c.skinning_pars_vertex(e)}\n            ${c.fog_pars_vertex(e)}\n            ${p.oit_pars_vertex(e)}\n            ${a?p.depth_pars_vertex(e):""}\n            ${a?p.picking_pars_vertex(e):""}\n            ${a?p.picking_instancing_pars_vertex(e):""}\n            ${a?p.highlight_pars_vertex(e):""}\n            ${a?p.texcoord_pars_vertex(e):""}\n            ${a?p.gpupos_pars_vertex(e):""}\n            ${l}\n\n            ${(()=>s.FunctionHandler.getMainVertexStart())()}\n\n                ${c.PDSFX_start_vertex(e)}\n                ${c.color_vertex(e)}\n                ${c.skinbase_vertex(e)}\n                ${c.skinnormal_vertex(e)}\n                ${c.skinning_vertex(e)}\n                ${$}\n                ${c.tangent_Binormal_vertex(e)}\n                ${i}\n                ${c.position_vertex(e)}\n                ${c.default_vertex_with_normal(e)}\n                ${c.defaultnormal_vertex(e)}\n                ${u}\n\n                ${c.clip_vertex(e)}\n                ${c.fog_vertex(e)}\n\n                ${n._DefaultShaderChunk.normal_viewposition_vertex(e)}\n\n                ${c._worldpos_vertex(e)}\n                ${h("vWorldPosition")} = worldPosition.xyz;\n\n                ${e.needObjectSpaceData?`\n                    ${h("vObjectSpacePosition")} = position_.xyz;\n                    ${h("vObjectSpaceNormal")} = objectNormal.xyz;\n                    `:""}\n                ${t?c.shadowmap_vertex(e):""}\n                ${p.oit_vertex(e)}\n                ${a?p.depth_vertex(e):""}\n                ${a?p.picking_vertex(e):""}\n                ${a?p.picking_instancing_vertex(e):""}\n                ${a?p.highlight_vertex(e):""}\n                ${a?p.texcoord_vertex(e):""}\n                ${a?p.gpupos_vertex(e):""}\n\n                ${c.PDSFX_end_vertex(e)}\n\n            ${(()=>s.FunctionHandler.getMainVertexEnd())()}\n        `},T=function(e,t,r){const[o,i]=a.getDecalShaders(e),[u,m]=a.getMappingShaders(e,y(e)),[$,c,h]=a.getAnalyticalLightShaders(t,e),[S,_]=a.getIndirectLightShaders(t,e),[T,D,C]=a.getUniformShaders(t,e),[P,N]=a.getEquationsShaders(t,e),M=n._ShaderChunk,b=n._DeferredShaderChunk,w=[{type:"f",name:"roughness"},{type:"f",name:"transparency"},{type:"f",name:"metalness"},{type:"v3",name:"diffuseColor"},{type:"v3",name:"transparentColor"},{type:"f",name:"specularContribution"},{type:"v3",name:"specularTint"},{type:"v3",name:"specularBlendingSR0"},{type:"v3",name:"sr0Color"},{type:"v3",name:"sr90Color"},{type:"f",name:"ior"},{type:"f",name:"adjustedIoR"},{type:"f",name:"F0"}];e.useEmission&&(w.push({type:"v3",name:"emissionColor"}),w.push({type:"f",name:"emissionValue"})),e.dspbrWithTranslucency&&(w.push({type:"f",name:"translucency"}),w.push({type:"v3",name:"translucencyColor"})),t&&(e.anisotropy&&(w.push({type:"f",name:"anisotropy"}),w.push({type:"f",name:"anisotropyAngle"})),e.sheen&&(w.push({type:"f",name:"sheen"}),w.push({type:"f",name:"sheenRoughness"}),w.push({type:"v3",name:"sheenColor"}),w.push({type:"f",name:"sheenEnergyConservationConstant"})),e.clearCoat&&(w.push({type:"f",name:"clearCoat"}),w.push({type:"f",name:"clearCoatRoughness"}),w.push({type:"v3",name:"clearCoatSR0Color"}),w.push({type:"v3",name:"clearCoatSR90Color"})),e.iridescence&&(w.push({type:"f",name:"iridescence"}),w.push({type:"f",name:"iridescenceIoR"}),w.push({type:"f",name:"iridescenceThickness"}),w.push({type:"v3",name:"iridescenceSR0Color"}))),e.subsurface&&(w.push({type:"v3",name:"scatteringColor"}),e.thickness&&w.push({type:"v3",name:"transmittanceColor"})),e.dspbr&&(w.push({type:"v3",name:"specularEnergyConservationConstant"}),w.push({type:"f",name:"diffuseEnergyConservationConstant"}));const U=[{type:"v3",name:"viewNormal"},{type:"v3",name:"view"},{type:"v3",name:"worldPosition"},{type:"v3",name:"viewPosition"}];return(t&&(e.envMap||e.useIBLColor||e.reflectivityEnvMap||e.specGlossFlakes)||e.thickness||e.subsurface)&&U.push({type:"v3",name:"worldNormal"}),e.needObjectSpaceData&&(U.push({type:"v3",name:"objectSpacePosition"}),U.push({type:"v3",name:"objectSpaceNormal"})),e.anisotropy&&(U.push({type:"v3",name:"tangent"}),U.push({type:"v3",name:"binormal"})),e.clearCoat&&(U.push({type:"v3",name:"clearCoatNormal"}),U.push({type:"v3",name:"clearCoatWorldNormal"})),e.subsurface&&U.push({type:"f",name:"curvature"}),e.useSpecularAA&&(U.push({type:"m3",name:"TBNMatrixForSpecularAA"}),U.push({type:"v3",name:"TForSpecularAA"}),U.push({type:"v3",name:"BForSpecularAA"})),e.thickness&&U.push({type:"f",name:"thickness"}),`\n            ${`\n            ${e.WebGPU?"":"#define PHYSICALDS"}\n            \n            ${l.createStructure({structName:"matData",attributes:w})}\n\n            ${l.createStructure({structName:"surfData",attributes:U})}\n            \n            ${e.needObjectSpaceData?`\n                ${f({varyingName:"vObjectSpacePosition",varyingType:"v3"})}\n                ${f({varyingName:"vObjectSpaceNormal",varyingType:"v3"})}\n                `:""}\n            \n            ${l.declareStructure({name:"materialData",structName:"matData",addressSpace:"private",addressSpace:"private"})};\n            ${l.declareStructure({name:"surfaceData",structName:"surfData",addressSpace:"private",addressSpace:"private"})};\n\n            ${x("ROUGHNESS_CLAMP_MIN")}  = 0.025;\n            ${x("ROUGHNESS_CLAMP_MAX")}  = 0.975;\n\n            ${x("PI")}  = 3.14159265359;\n            ${x("INV_PI")}  = 0.31830988618;\n\n            ${v("luminanceVector","private")}  = ${v()}(0.299, 0.587, 0.114);\n     \n            ${f({varyingName:"vWorldPosition",varyingType:"v3"})}\n            ${n._DefaultShaderChunk.normal_viewposition_pars_fragment(e)}\n\n            ${M.color_pars_fragment(e)}\n            ${M.clip_pars_fragment(e)}\n            \n            ${u}\n            ${M.tangent_Binormal_pars_fragment(e)}\n            ${t?n._ShaderChunk.shadowmap_pars_fragment(e):""}\n            ${a.getUtilityShader(t,e)}\n            ${a.getNoiseShader(e)}\n\n            ${$}\n            ${S}\n            ${T}\n            ${P}\n            ${h}\n         \n            ${b.oit_pars_fragment(e)}\n\t\t\t${r?b.picking_pars_fragment(e):""}\n\t\t\t${r?b.picking_instancing_pars_fragment(e):""}\n\t\t\t${r?b.depth_pars_fragment(e):""}\n\t\t\t${r?b.decal_normal_depth_pars_fragment(e):""}\n\t\t\t${r?b.shadowmap_pars_fragment(e):""}\n\t\t\t${r?b.highlight_pars_fragment(e,!1):""}\n            ${r?b.texcoord_pars_fragment(e):""}\n            ${r?b.gpupos_pars_fragment(e):""}\n            ${o}\n            ${M.postprocess_pars_fragment(e)}\n            ${M.fog_pars_fragment(e)}\n        `}\n            ${`\n            ${(()=>s.FunctionHandler.getMainFragmentStart())()}\n                ${t&&e.envMapHDR?`\n                    hdrSize = ${g()}(${p("envMapHDRSize")});\n                    hdrTexelSize = ${g()}(1.0 / ${p("envMapHDRSize")});\n                    mipsSize = ${p("envMapHDRToMipsRatio")} * ${g()}(1.0, 2.0) * hdrSize;\n                    mipsTexelSize = ${g()}(1.0 / mipsSize);\n                    `:""}\n\n                ${e.PDSFX?`\n                    ${M.PDSFX_start_fragment(e)}\n                    ${M.PDSFX_map_fragment(e)}\n                    ${M.PDSFX_mapping_fragment(e)}\n                    `:""}\n\n                ${i}    \n                ${M.clip_fragment(e)} \n                ${m}\n                ${C}\n\n                ${e.PDSFX?`\n                    ${((n,e,t)=>s.FunctionHandler.callFunction(n,e,t))("ComputeCommonValues",null,[])};\n                    ${M.PDSFX_discard_fragment(e)}\n                    ${M.PDSFX_viewNormal_fragment(e)}\n                    ${M.PDSFX_viewPosition_fragment(e)}\n                    `:""}\n                \n                ${d("out0")} = ${((n=null,e=0)=>{var t={name:n,size:e};return l.vec4(t)})()}( 1.0 );\n              \n                ${M.tangent_Binormal_fragment(e)}\n                ${D}  \n\n                ${t?M.shadowmap_fragment(e):""}  \n                ${c}  \n                ${_}                \n                ${e.useLighting?`\n                    ${e.shadowMapDebugMaterial||!e.dspbrWithTranslucency&&!e.subsurface?"":`\n                        ${d("out0")}.x += totalTransmissive.x;\n                        ${d("out0")}.y += totalTransmissive.y;\n                        ${d("out0")}.z += totalTransmissive.z ;\n                        `}\n                    ${e.shadowMapDebugMaterial||!e.useEmission?"":`\n                        ${d("out0")}.x += totalEmission.x;\n                        ${d("out0")}.y += totalEmission.y;\n                        ${d("out0")}.z += totalEmission.z;\n                        `}\n                    `:`\n                    ${d("out0")}.x = albedo.x;\n                    ${d("out0")}.y = albedo.y;\n                    ${d("out0")}.z = albedo.z;\n                    ${e.subsurface?`\n                        ${d("out0")}.x *= materialData.scatteringColor.x;\n                        ${d("out0")}.y *= materialData.scatteringColor.y;\n                        ${d("out0")}.z *= materialData.scatteringColor.z;\n                        `:""}\n                    ${e.invisiblePlaneMaterial?`\n                        ${d("out0")}.x = 1.0;\n                        ${d("out0")}.y = 1.0;\n                        ${d("out0")}.z = 1.0;\n                        `:""}\n                    `} \n                ${e.dspbr&&e.useTransparency&&!e.shadowMapDebugMaterial?`\n                    ${d("out0")}.x /= transToDivide;\n                    ${d("out0")}.y /= transToDivide;\n                    ${d("out0")}.z /= transToDivide;\n                    `:""}\n                \n                ${e.useSSAO?`\n                    if (${d("out0")}.a > 1.0 - 1e-3 && materialData.transparency < 1e-3) {\n                        ${M._ao_fragment(e)}\n                    }\n                    `:""}\n                ${M.postprocess_fragment(e)}\n                ${M.linear_to_gamma_fragment(e)}\n                ${M.PDSFX_end_fragment(e)}\n                ${M.fog_fragment(e)}\n                ${M.backgroundviewmode_lowlight_fragment(e)}\n                ${b._debug_common_face_fragment(e)}\n                ${b.oit_fragment(e)}\n\t\t\t\t${r?b.picking_fragment(e):""}\n\t\t\t\t${r?b.picking_instancing_fragment(e):""}\n\t\t\t\t${r?b.depth_fragment_face(e):""}\n\t\t\t\t${r?b.normal_fragment(e):""}\n\t\t\t\t${r?b.normal_depth_fragment(e):""}\n\t\t\t\t${r?b.shadowmap_fragment(e):""}\n                ${r?b.highlight_fragment_face(e):""}\n                ${r?b.texcoord_fragment(e):""}\n                ${r?b.gpupos_fragment(e):""}\n\n            ${(()=>s.FunctionHandler.getMainFragmentEnd())()}\n        `}\n        `};return new e(function(n,e){let t=e.isDeferredMaterial;n=n&&e.useLighting;let r=T(e,n,t);return{vertexShader:_(e,n,t),fragmentShader:r}})});