define("DS/Shaders/CATCrDImageTextureShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(o,r){o.force=!0,o.useLighting=!1,o.activatePDSFX(),o.transparent=!0,o.side=e.DoubleSide;var a=["vec4 commonFinalColor;"].join("\n");o.setPDSFXGlobalShaderCode("",a);var n={CrD_Image_UniformColor:{type:"v4",value:r.Color},CrD_Image_UniformOpacity:{type:"f",value:r.Opacity},RefImage2DMap:{type:"t2",value:r.RefImage2DMap.map}};o.setPDSFXUniforms(n);o.setPDSFXVaryings({vTexCoord:{type:"v3"}});var t={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},i={ComputeCommonValues:["void ComputeCommonValues() {","commonFinalColor = texture2D(RefImage2DMap, vTexCoord.xy);","commonFinalColor.a = commonFinalColor.a * CrD_Image_UniformOpacity;","commonFinalColor.a = clamp(commonFinalColor.a, 0.0, 1.0);","float rangeMin = 0.03;","float rangeMax = 0.97;","float factor = 0.0;","if(CrD_Image_UniformColor.a > 0.0)","{","if (vTexCoord.x < rangeMin) {","if (vTexCoord.y < rangeMin && vTexCoord.x > vTexCoord.y) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax && vTexCoord.y > vTexCoord.x * ((rangeMax - 1.0) / rangeMin) + 1.0) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","else {","factor = 1.0 - (vTexCoord.x / rangeMin);","}","}","else if (vTexCoord.x > rangeMax) {","if (vTexCoord.y < rangeMin && vTexCoord.y < (rangeMin / (1.0 - rangeMax)) * (1.0 - vTexCoord.x)) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax && vTexCoord.x < vTexCoord.y) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","else {","factor = (vTexCoord.x - rangeMax) / (1.0 - rangeMax);","}","}","else if (vTexCoord.y < rangeMin) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","if ((commonFinalColor.a < 10e-3) && factor > 0.0) {","commonFinalColor = vec4(1.0, 1.0, 1.0, 1.0);","factor = (factor * 0.6) + 0.4;","}","commonFinalColor = mix(commonFinalColor, CrD_Image_UniformColor, factor);","}","if (commonFinalColor.a < 10e-3) {","discard;","}","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return o.setPDSFXOverridableFunctions(t,i),o.needsUpdate=!0,o}}),define("DS/Shaders/DeferredShaders",["DS/Visualization/ThreeJS_R57"],function(e){"use strict";var o={encode_float:["float shift_right(float v, float amt) {","v = floor(v) + 0.5;","return floor(v / exp2(amt));","}","float shift_left(float v, float amt) {","return floor(v * exp2(amt) + 0.5);","}","float mask_last(float v, float bits) {","return mod(v, shift_left(1.0, bits));","}","float extract_bits(float num, float from, float to) {","from = floor(from + 0.5);","to = floor(to + 0.5);","return mask_last(shift_right(num, from), to - from);","}","vec4 encode_float(float val) {","if (val == 0.0)","return vec4(0, 0, 0, 0);","float sign = val > 0.0 ? 0.0 : 1.0;","val = abs(val);","float exponent = floor(log2(val));","float biased_exponent = exponent + 127.0;","float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;","float t = biased_exponent / 2.0;","float last_bit_of_biased_exponent = fract(t) * 2.0;","float remaining_bits_of_biased_exponent = floor(t);","float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;","float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;","float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;","float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;","return vec4(byte4, byte3, byte2, byte1);","}","vec4 packRGBAFace( const in float depth ) {","float depthToUse = depth;","#if defined(GL_OES_standard_derivatives) || defined(GLSL300ES)","float dx = dFdx (depth);","float dy = dFdy (depth);","depthToUse += sqrt(dx*dx + dy*dy) + DEPTH_PRECISION;","#else","depthToUse += 2.0 *DEPTH_PRECISION;","#endif","return packRGBA(depthToUse);","}"].join("\n"),decalNormalStencilDepth:["uniform float decalStencilValue;"].join("\n"),unpackFloat:["vec3 float_to_vec3( float data ) {","vec3 uncompressed;","uncompressed.x = fract( data );","float zInt = floor( data / 255.0 );","uncompressed.z = fract( zInt / 255.0 );","uncompressed.y = fract( floor( data - ( zInt * 255.0 ) ) / 255.0 );","return uncompressed;","}"].join("\n"),picking_instancing_vertex:["if (instanceId > 16777215.0) vInstancePickingColor = vec3(0.0);","else {","vInstancePickingColor.r = floor(instanceId / 65536.0);","vInstancePickingColor.g = floor((instanceId - vInstancePickingColor.r * 65536.0) / 256.0);","vInstancePickingColor.b = floor(instanceId - vInstancePickingColor.r * 65536.0 - vInstancePickingColor.g * 256.0);","vInstancePickingColor /= 255.0;","}"].join("\n"),picking_instancing_fragment:["gl_FragColor = vec4(vInstancePickingColor, 1.0);"].join("\n")},r={uniforms:e.UniformsUtils.merge([{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)}}]),vertexShaderPars:["#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#endif"].join("\n"),vertexShaderBody:["#ifdef USE_MAP_ALPHATEST","    vUvMap = uv.xy * repeatAlphaMap + offsetAlphaMap;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","pickingColor = specialMeshPicking;","#endif"].join("\n"),fragmentShaderPars:["#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#else","uniform vec3 pickingColor;","#endif"].join("\n"),fragmentShaderBody:["#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","   gl_FragColor = vec4( pickingColor, 1.0 );"].join("\n")},a=function(r){return{uniforms:e.UniformsUtils.merge([{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)}}]),fragmentShaderPars:[o.encode_float,"varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif"].join("\n"),fragmentShaderBody:["#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","\tfloat tmp = 0.5 + 0.5 * clipPos.z / clipPos.w;",r?"\tvec4 encode = packRGBAFace(tmp);":"\tvec4 encode = encode_float(tmp);","   gl_FragColor = encode;"].join("\n"),vertexShaderPars:["varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif"].join("\n"),vertexShaderBody:["#ifdef USE_MAP_ALPHATEST","    vUvMap = uv.xy * repeatAlphaMap + offsetAlphaMap;","#endif","   clipPos = gl_Position;"].join("\n")}},n={uniforms:e.UniformsUtils.merge([{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector2(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector2(1,1)},bumpMap:{type:"t",value:null},bumpScale:{type:"f",value:1},offsetBumpMap:{type:"v2",value:new e.Vector2(0,0)},repeatBumpMap:{type:"v2",value:new e.Vector2(1,1)}}]),fragmentShaderPars:["varying vec3 normalView;"].join("\n"),fragmentShaderBody:["   vec3 normal = normalize( normalView );","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif","   gl_FragColor.xyz = normal * 0.5 + 0.5;"].join("\n"),vertexShaderPars:["varying vec3 normalView;"].join("\n"),vertexShaderBody:["vec3 mvNormalDeferred = vec3(modelViewMatrix * vec4(normal, 0.0));","   normalView = normalize( mvNormalDeferred );"].join("\n")},t=function(r,a){r||(a=!1);var n=r?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","gl_FragColor.xy = normalToOct22(normal);","#else","gl_FragColor.xyz = normalize(normal) * 0.5 + 0.5;","#endif"].join("\n"):["   gl_FragColor.x = normalToOct24(normal);","gl_FragColor.z = 0.0;"].join("\n");r?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","gl_FragColor.xy = normalToOct22(normal);","#else","gl_FragColor.xyz = normalize(normal) * 0.5 + 0.5;","#endif"].join("\n"):["   gl_FragColor.x = normalToOct24(normal);","gl_FragColor.z = 0.0;"].join("\n");return{uniforms:e.UniformsUtils.merge([{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector2(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector2(1,1)},bumpMap:{type:"t",value:null},bumpScale:{type:"f",value:1},offsetBumpMap:{type:"v2",value:new e.Vector2(0,0)},repeatBumpMap:{type:"v2",value:new e.Vector2(1,1)},normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new e.Vector2(1,1)}}]),fragmentShaderPars:[a?o.decalNormalStencilDepth:"","vec2 normalToOct22(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","return floor((2047.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","}","float normalToOct24(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","vec2 compNormal = floor((4095.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","return compNormal.x * 4096.0 + compNormal.y;","}","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","varying vec3 normalView;","varying vec4 clipPos;"].join("\n"),fragmentShaderBody:["   #ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","       if ( alpha < ALPHATEST ) discard;","   #endif","   vec3 normal = normalView;","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif",n,a?"gl_FragColor.xy = normalToOct22(normal); gl_FragColor.z = decalStencilValue;":"","   gl_FragColor.w = 0.5 + 0.5 * clipPos.z / clipPos.w;",r?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","gl_FragColor.zw = packForFloat16(gl_FragColor.w)","#endif"].join("\n"):""].join("\n"),vertexShaderPars:["varying vec3 normalView;","varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif"].join("\n"),vertexShaderBody:["vec3 mvNormalDeferred = vec3(modelViewMatrix * vec4(normal, 0.0));","   normalView = normalize( mvNormalDeferred );","   #ifdef USE_MAP_ALPHATEST","vUvMap = uv.xy * repeatAlphaMap.xy + offsetAlphaMap.xy;","   #endif","   clipPos = gl_Position;"].join("\n")}};return{NormalDepthIoRRoughness:t(!1),NormalDepth:t(!0),DecalNormalStencilDepth:t(!0,!0),Normal:n,Depth:a(!1),DepthRGBA:a(!0),PickingFragment:r,Chunks:o}}),define("Shaders/DeferredShaders",["DS/Shaders/DeferredShaders","DS/DSMigration/DSMigration"],function(e,o){return o.deprecateModule("Shaders/DeferredShaders"),e}),define("DS/Shaders/CATCrDFeltPenShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(o,r){o.force=!0,o.useLighting=!1,o.activatePDSFX(),o.transparent=!0,o.side=e.DoubleSide,o.setPDSFXPolygonOffset("Frontward1");var a=["vec4 commonFinalColor;"].join("\n");o.setPDSFXGlobalShaderCode("",a);var n={CrD_Base_UniformColor:{type:"v4",value:new e.Vector4(r.Color[0],r.Color[1],r.Color[2],r.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:r.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:r.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new e.Vector3(r.PlanePosition[0],r.PlanePosition[1],r.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new e.Vector3(r.PlaneNormal[0],r.PlaneNormal[1],r.PlaneNormal[2])},CrD_FeltPen_UniformThickness:{type:"f",value:r.Thickness},CrD_FeltPen_UniformLength:{type:"f",value:r.Length},CrD_FeltPen_UniformResizeUMode:{type:"f",value:r.ResizeUMode},CrD_FeltPen_UniformUMin:{type:"f",value:r.UMin},CrD_FeltPen_UniformUMax:{type:"f",value:r.UMax},CrD_FeltPen_UniformClosedWire:{type:"f",value:r.ClosedWire}};o.setPDSFXUniforms(n);o.setPDSFXVaryings({vTexCoord:{type:"v3"}});var t={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},i={ComputeCommonValues:["void ComputeCommonValues() {","float isOpenedWire = 1.0 - clamp(sign(CrD_FeltPen_UniformClosedWire), 0.0, 1.0);","// Pen handles pressure, we must take it into account when computing pen thickness","float pressure = clamp(1.02 * 1.0, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0","float thickness = CrD_FeltPen_UniformThickness * pressure;","float adjustedLength = max(thickness, CrD_FeltPen_UniformLength);","float thicknessUV = 0.5 * thickness / adjustedLength;","vec2 cornerUV = vTexCoord.xy;","cornerUV.y = 2.0 * (cornerUV.y - 0.5);","float xUVTest1 = clamp(sign(thicknessUV - cornerUV.x), 0.0, 1.0); // if cornerUV.x<thicknessUV","float xUVTest2 = clamp(sign(cornerUV.x - (1.0 - thicknessUV)), 0.0, 1.0); // if cornerUV.x>1.0f - thicknessUV","cornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x / thicknessUV, xUVTest1); // if cornerUV.x<thicknessUV => cornerUV.x = 1.0f - cornerUV.x/thicknessUV","cornerUV.x = mix(cornerUV.x, (cornerUV.x - (1.0 - thicknessUV)) / thicknessUV, xUVTest2); // if cornerUV.x > 1.0f - thicknessUV => (cornerUV.x - (1.0f - thicknessUV))/thicknessUV","float inTheCorner = xUVTest1 + xUVTest2; // xUVTest1 || xUVTest2","float corner = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;","if(isOpenedWire * inTheCorner * corner > 1.0) // true only if isOpenedWire == 1 and inTheCorner == 1 and corner > 1 as isOpenedWire and inTheCorner can only be 0 or 1","{","discard;","}","//-----------------------------------------------------------------------------------------------","// Handle cut by plane","//-----------------------------------------------------------------------------------------------","float cutByPlaneActivated = clamp(sign(CrD_Base_UniformCutByPlane), 0.0, 1.0); // 0 if CutByPlane <= 0, 1 if CutByPlane > 0        ","float screenActivated = clamp(sign(CrD_Base_UniformScreenPlane), 0.0, 1.0); // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0","// We do the work in the view space","// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)","vec4 viewPlaneEq = vGetWorldViewInvTranspMatrix() * vec4(CrD_Base_UniformPlaneNormal, -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition));","// eye and Fragment position","vec4 fragPos = vec4(vGetViewPosition(), 1.0);","vec4 eyePos = vec4(0.0, 0.0, 0.0, 1.0);","// The sign of the plane's equation applied to the previous position gives the side of each point","float eyeClip = dot(viewPlaneEq, eyePos); // => d","float fragClip = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;","// cutByPlaneActivated == 0 => hide = 0.0","// If both values have the same sign, they are on the same side => hide = 0.0","// If there signs are different, they are on opposite side      => hide = 1.0","float hide = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);","//-----------------------------------------------------------------------------------------------","// Handle Resize UV","//-----------------------------------------------------------------------------------------------","float resizeMode = clamp(sign(CrD_FeltPen_UniformResizeUMode), 0.0, 1.0);","float outsideLimit = clamp(sign(CrD_FeltPen_UniformUMin - vTexCoord.x), 0.0, 1.0) + clamp(sign(vTexCoord.x - CrD_FeltPen_UniformUMax), 0.0, 1.0); //if((uv.x < UMin) || (uv.x > UMax)) ","float alpha = mix(CrD_Base_UniformColor.a, 0.0625 * CrD_Base_UniformColor.a, resizeMode * outsideLimit);","commonFinalColor = vec4(CrD_Base_UniformColor.xyz, pressure * alpha * mix(1.0, 0.25, hide));","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return o.setPDSFXOverridableFunctions(t,i),o.needsUpdate=!0,o}}),define("DS/Shaders/FlareShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{FinalBlending:{uniforms:{tDiffuse:{type:"t",value:null},tBlur:{type:"t",value:null},tLensColor:{type:"t",value:null},tLensDirt:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv.xy;","gl_Position = projectionMatrix * computeModelViewPosition(position_);","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tBlur;","uniform sampler2D tLensColor;","uniform sampler2D tLensDirt;","uniform vec2 invSize;","const float ghostDispersal = 0.25;","const int ghosts = 8;","const float distortion = 5.0;","const float haloWidth = 1.0;","const float one_over_sqrt2 = 0.70710678;","varying vec2 vUv;","vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion) {","   return vec4(","      texture2D(tex, texcoord + direction * distortion.r).r,","      texture2D(tex, texcoord + direction * distortion.g).g,","      texture2D(tex, texcoord + direction * distortion.b).b,","      1.0","   );","}","void main() {","   vec4 color = texture2D( tDiffuse, vUv );","   vec2 flippedUV = vec2(1.0) - vUv;","   vec2 uvToCenter = vec2(0.5) - flippedUV;","   vec3 distort = vec3(-invSize.x * distortion, 0.0, invSize.x * distortion);","   vec2 ghostVec = uvToCenter * ghostDispersal;","   vec4 flare = vec4(0.0);","   for (int i = 0; i < ghosts; ++i) {","      vec2 offset = fract(flippedUV + ghostVec * float(i));","      float ghostHeight = length(vec2(0.5) - offset) / one_over_sqrt2;","      ghostHeight = pow(1.0 - ghostHeight, 10.0);","      flare += textureDistorted(tBlur, offset, normalize(ghostVec), distort) * ghostHeight;","   }","   flare *= texture2D(tLensColor, vec2(length(uvToCenter) / one_over_sqrt2, 0.5));","   float dirt = texture2D( tLensDirt, vUv ).r;","   flare *= vec4(0.5) + dirt;","   gl_FragColor = vec4(color.rgb + flare.rgb, color.a);","}"].join("\n")}}}),define("Shaders/FlareShaders",["DS/Shaders/FlareShaders","DS/DSMigration/DSMigration"],function(e,o){return o.deprecateModule("Shaders/FlareShaders"),e}),define("DS/Shaders/CATCrDBallPointShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(o,r){o.activatePDSFX(),o.transparent=!0,o.side=e.DoubleSide,o.setPDSFXPolygonOffset("Frontward1");var a=["vec4 commonFinalColor;","vec3 selectorColor = vec3(0., 0.45, 0.75);","float bezierBlend(float t)","{","return clamp((3.0 * t * t * (1.0 - t) + t * t * t), 0.0, 1.0);","}"].join("\n");o.setPDSFXGlobalShaderCode("",a);var n={CrD_Base_UniformColor:{type:"v4",value:new e.Vector4(r.Color[0],r.Color[1],r.Color[2],r.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:r.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:r.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new e.Vector3(r.PlanePosition[0],r.PlanePosition[1],r.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new e.Vector3(r.PlaneNormal[0],r.PlaneNormal[1],r.PlaneNormal[2])},CrD_BallPoint_UniformCircleSelection:{type:"f",value:0},CrD_BallPoint_UniformRadius:{type:"v2",value:new e.Vector2(0,0)},CrD_BallPoint_UniformCenter:{type:"v2",value:new e.Vector2(0,0)}};o.setPDSFXUniforms(n);o.setPDSFXVaryings({vTexCoord:{type:"v3"}});var t={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},i={ComputeCommonValues:["void ComputeCommonValues() {","vec2 cornerUV = vTexCoord.xy;","float alpha    = CrD_Base_UniformColor.a;","float pressure = clamp(1.02 * 1.0, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0","cornerUV.y = 2.0 * (cornerUV.y - 0.5);","float xUVTest1 = clamp(sign(0.25 - cornerUV.x), 0.0, 1.0); // if cornerUV.x<0.25f","float xUVTest2 = clamp(sign(cornerUV.x - 0.75), 0.0, 1.0); // if cornerUV.x>0.75f","cornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x * 4.0, xUVTest1); // if cornerUV.x<0.25f => cornerUV.x = 1.0 - cornerUV.x * 4.0","cornerUV.x = mix(cornerUV.x, (cornerUV.x - 0.75) * 4.0, xUVTest2); // if cornerUV.x>0.75f => cornerUV.x = (cornerUV.x - 0.75) * 4.0","float inTheCorner = xUVTest1 + xUVTest2; // 0 if 0.25 < u < 0.75, else 1        ","float corner = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;","if(inTheCorner * corner > 1.0) // true only if inTheCorner = 1 and corner > 1 as inTheCorner can only be 0 or 1","{","discard;","}","float falloffU = bezierBlend(cornerUV.x);","// if inTheCorner is 1. then corner is <= 1.0 else we would have already discarded the fragment, so next line is equivalent to:","// if(inTheCorner>0.0 && corner <= 1.0) => alpha = mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * bezierBlend(corner))","// else alpha = alpha","alpha = mix(alpha, mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * bezierBlend(corner)), inTheCorner);","//-----------------------------------------------------------------------------------------------","// Handle cut by plane","//-----------------------------------------------------------------------------------------------","float cutByPlaneActivated = clamp(sign(CrD_Base_UniformCutByPlane), 0.0, 1.0); // 0 if CutByPlane <= 0, 1 if CutByPlane > 0        ","float screenActivated = clamp(sign(CrD_Base_UniformScreenPlane), 0.0, 1.0); // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0","// We do the work in the view space","// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)","vec4 viewPlaneEq = vGetWorldViewInvTranspMatrix() * vec4(CrD_Base_UniformPlaneNormal, -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition));","// eye and Fragment position","vec4 fragPos = vec4(vGetViewPosition(), 1.0);","vec4 eyePos = vec4(0.0, 0.0, 0.0, 1.0);","// The sign of the plane's equation applied to the previous position gives the side of each point","float eyeClip = dot(viewPlaneEq, eyePos); // => d","float fragClip = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;","// cutByPlaneActivated == 0 => hide = 0.0","// If both values have the same sign, they are on the same side => hide = 0.0","// If there signs are different, they are on opposite side      => hide = 1.0","float hide = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);","commonFinalColor = vec4(CrD_Base_UniformColor.xyz, pressure * alpha * mix(1.0, 0.25, hide));","//-----------------------------------------------------------------------------------------------","// handle circle selection","//-----------------------------------------------------------------------------------------------","float circleSelectActivated = clamp(sign(CrD_BallPoint_UniformCircleSelection), 0.0, 1.0); // if CircleSelection > 0 => circleSelectActivated = 1 else circleSelectActivated = 0","// screen coordinates of current fragment - circle center coordinates","vec2 vect = vGetFragCoord().xy - CrD_BallPoint_UniformCenter.xy;","float circleValue = pow(vect.x, 2.0) / pow(CrD_BallPoint_UniformRadius.x, 2.0) + pow(vect.y, 2.0) / pow(CrD_BallPoint_UniformRadius.y, 2.0);","// at the end, coeff is 0 if circleSelectActivated is 0 or if we are outside the selection circle","//             coeff is 1 at the middle of the circle, slowly decreases afterward and reaches 0 on the circle border","float coeff = circleSelectActivated * (1.0 - clamp(circleValue, 0.0, 1.0));","float selectionAlpha = 0.3 * coeff + 0.7;","vec4 blendResult;","blendResult.a = selectionAlpha + commonFinalColor.a * (1.0 - selectionAlpha);","blendResult.rgb = (selectorColor * selectionAlpha + commonFinalColor.xyz * commonFinalColor.a * (1.0 - selectionAlpha)) / selectionAlpha;","commonFinalColor = mix(commonFinalColor, blendResult, sign(coeff));","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return o.setPDSFXOverridableFunctions(t,i),o.needsUpdate=!0,o}}),define("DS/Shaders/StereoShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{oculusDK2:{uniforms:{tEye:{type:"t",value:null},tDiffuse:{type:"t",value:null},eyeToSourceUVScale:{type:"v2",value:new e.Vector2(.33333333,.3333333)},eyeToSourceUVOffset:{type:"v2",value:new e.Vector2(.5,.5)}},vertexShader:["varying vec2 uvr;","varying vec2 uvg;","varying vec2 uvb;","uniform vec2 eyeToSourceUVScale;","uniform vec2 eyeToSourceUVOffset;","void main() {","uvr = uv.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvg = uv2.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvb = tangent.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvr.y = 1.0 - uvr.y;","uvg.y = 1.0 - uvg.y;","uvb.y = 1.0 - uvb.y;","gl_Position = projectionMatrix * computeModelViewPosition(position_);","}"].join("\n"),fragmentShader:["varying vec2 uvr;","varying vec2 uvg;","varying vec2 uvb;","uniform sampler2D tDiffuse;","uniform sampler2D tEye;","void main() {","gl_FragColor = vec4(texture2D(tEye, uvr).r, texture2D(tEye, uvg).g, texture2D(tEye, uvb).b, 1.0);","} "].join("\n")}}});